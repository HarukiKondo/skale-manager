{
  "language": "Solidity",
  "sources": {
    ".coverage_contracts/ConstantsHolder.sol": {
      "content": "/*\n    ConstantsHolder.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IConstants.sol\";\n\n\n/**\n * @title Contains constants and common variables for Skale Manager system\n * @author Artem Payvin\n */\ncontract ConstantsHolder is IConstants, Permissions {\nfunction coverage_0x27a7fff7(bytes32 c__0x27a7fff7) public pure {}\n\n\n    // initial price for creating Node (100 SKL)\n    uint public constant NODE_DEPOSIT = 100 * 1e18;\n\n    // part of Node for Tiny Skale-chain (1/128 of Node)\n    uint8 public constant TINY_DIVISOR = 128;\n\n    // part of Node for Small Skale-chain (1/8 of Node)\n    uint8 public constant SMALL_DIVISOR = 8;\n\n    // part of Node for Medium Skale-chain (full Node)\n    uint8 public constant MEDIUM_DIVISOR = 1;\n\n    // part of Node for Medium Test Skale-chain (1/4 of Node)\n    uint8 public constant MEDIUM_TEST_DIVISOR = 4;\n\n    // typically number of Nodes for Skale-chain (16 Nodes)\n    uint public constant NUMBER_OF_NODES_FOR_SCHAIN = 16;\n\n    // number of Nodes for Test Skale-chain (2 Nodes)\n    uint public constant NUMBER_OF_NODES_FOR_TEST_SCHAIN = 2;\n\n    // number of Nodes for Test Skale-chain (4 Nodes)\n    uint public constant NUMBER_OF_NODES_FOR_MEDIUM_TEST_SCHAIN = 4;\n\n    // 'Fractional' Part of ratio for create Fractional or Full Node\n    uint public constant FRACTIONAL_FACTOR = 128;\n\n    // 'Full' part of ratio for create Fractional or Full Node\n    uint public constant FULL_FACTOR = 17;\n\n    // number of second in one day\n    uint32 public constant SECONDS_TO_DAY = 86400;\n\n    // number of seconds in one month\n    uint32 public constant SECONDS_TO_MONTH = 2592000;\n\n    // number of seconds in one year\n    uint32 public constant SECONDS_TO_YEAR = 31622400;\n\n    // number of seconds in six years\n    uint32 public constant SIX_YEARS = 186624000;\n\n    // initial number of validators\n    uint public constant NUMBER_OF_VALIDATORS = 24;\n\n    // Reward period - 30 days (each 30 days Node would be granted for bounty)\n    uint32 public rewardPeriod = 3600; // Test parameters\n\n    // Allowable latency - 150000 ms by default\n    uint32 public allowableLatency = 150000; // Test parameters\n\n    /**\n     * Delta period - 1 hour (1 hour before Reward period became Validators need\n     * to send Verdicts and 1 hour after Reward period became Node need to come\n     * and get Bounty)\n     */\n    uint32 public deltaPeriod = 300;  // Test parameters\n\n    /**\n     * Check time - 2 minutes (every 2 minutes validators should check metrics\n     * from validated nodes)\n     */\n    uint8 public checkTime = 120; // Test parameters\n\n    /**\n     * Last time when system was underloaded\n     * (allocations on Skale-chain / allocations on Nodes < 75%)\n     */\n    uint public lastTimeUnderloaded = 0;\n\n    /**\n     * Last time when system was overloaded\n     * (allocations on Skale-chain / allocations on Nodes > 85%)\n     */\n    uint public lastTimeOverloaded = 0;\n\n    //Need to add minimal allowed parameters for verdicts\n\n    /**\n     * @dev constructor in Permissions approach\n     * @param contractsAddress needed in Permissions constructor\n     */\n    constructor(address contractsAddress) Permissions(contractsAddress) public {coverage_0x27a7fff7(0xac7dcbd1dc6771dfd7e1bb35716490dfdbdb47ed487e24a288bc0e25af9b1e06); /* function */ \n\n\n    }\n\n    /**\n     * Set reward and delta periods to new one, run only by owner. This function\n     * only for tests.\n     * @param newRewardPeriod - new Reward period\n     * @param newDeltaPeriod - new Delta period\n     */\n    function setPeriods(uint32 newRewardPeriod, uint32 newDeltaPeriod) external onlyOwner {coverage_0x27a7fff7(0x77770854c9422f5aea6fb3db3a8a230f17b2696dd7a299f6e3378f96a332b54a); /* function */ \n\ncoverage_0x27a7fff7(0x3b9c90ce9628fc2d991a2b5f54bca67471959d38eb9d916d6c36655428f6a780); /* line */ \n        coverage_0x27a7fff7(0x0f39fc766c28465cb746ffb183bcabf288dfc4235bd13afb4c4cf22e961617c0); /* statement */ \nrewardPeriod = newRewardPeriod;\ncoverage_0x27a7fff7(0x074a49ecc07f56340c36f0ac8d1551f830ab39013c41acc689929228344968ce); /* line */ \n        coverage_0x27a7fff7(0x761a923a3b18c77ee0bb4f2204a1ec87a4881191a3d3ac15fc097e30234bb8c3); /* statement */ \ndeltaPeriod = newDeltaPeriod;\n    }\n\n    /**\n     * Set new check time. This function only for tests.\n     * @param newCheckTime - new check time\n     */\n    function setCheckTime(uint8 newCheckTime) external onlyOwner {coverage_0x27a7fff7(0xb033377c2315dd1f2002bfd99af2efc904f78b821f49650067d9f17249a5d3ec); /* function */ \n\ncoverage_0x27a7fff7(0x59751c0283f34d7dfb0301f1ce12bdd6a9819efeff7f5c816dc585bbb5b17fd8); /* line */ \n        coverage_0x27a7fff7(0x347b83adea0dd4a1f240dd0456eba59a10928c210e8caca113325b11d85f1e21); /* statement */ \ncheckTime = newCheckTime;\n    }\n\n    /**\n     * Set time if system underloaded, run only by NodesFunctionality contract\n     */\n    function setLastTimeUnderloaded() external allow(\"NodesFunctionality\") {coverage_0x27a7fff7(0x472fb42a7b90fe5007255aa0cbe583625201baac543aa2280491c9e132e76b66); /* function */ \n\ncoverage_0x27a7fff7(0x0217bf24c1b6d56db10f472b8e5c531ba531a57af258d35e5d599d8cbff002cc); /* line */ \n        coverage_0x27a7fff7(0xae69436cba538754516622b7b10641c83fcc648a52bd75a6aef3200ea0c96ab3); /* statement */ \nlastTimeUnderloaded = now;\n    }\n\n    /**\n     * Set time if system iverloaded, run only by SchainsFunctionality contract\n     */\n    function setLastTimeOverloaded() external allow(\"SchainsFunctionality\") {coverage_0x27a7fff7(0x5c6e059e1ce54c194cba94f88eb255c4449f90ef773f50de60b040ce87676d07); /* function */ \n\ncoverage_0x27a7fff7(0x204436aab4292d4b5a33c68cc81cbfe596e484fed28343c4c8a3e2a878755dd6); /* line */ \n        coverage_0x27a7fff7(0x65ee667c9699464a38df1c608c05a7d87baf306362c6498417883496a30780af); /* statement */ \nlastTimeOverloaded = now;\n    }\n\n    /**\n     * Set latency new one in ms, run only by owner. This function\n     * only for tests.\n     * @param newAllowableLatency - new Allowable Latency\n     */\n    function setLatency(uint32 newAllowableLatency) external onlyOwner {coverage_0x27a7fff7(0x90a42193498219369d51dd659d880964e92ea2b1ea713025d4e1bb1609f0e270); /* function */ \n\ncoverage_0x27a7fff7(0x4a9e2c8c88f24eafecf6dda1562941d0e2e39a247d0ddd74ede12c1a6343b283); /* line */ \n        coverage_0x27a7fff7(0x029a5b1cb48999f5d1b39a6762f40f5997876ac00acd40179e63da2b3467f12b); /* statement */ \nallowableLatency = newAllowableLatency;\n    }\n}\n"
    },
    ".coverage_contracts/Permissions.sol": {
      "content": "/*\n    Permissions.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./ContractManager.sol\";\n\n\n/**\n * @title Permissions - connected module for Upgradeable approach, knows ContractManager\n * @author Artem Payvin\n */\ncontract Permissions is Ownable {\nfunction coverage_0x575eb1ae(bytes32 c__0x575eb1ae) public pure {}\n\n\n    ContractManager contractManager;\n\n    /**\n     * @dev allow - throws if called by any account and contract other than the owner\n     * or `contractName` contract\n     * @param contractName - human readable name of contract\n     */\n    modifier allow(string memory contractName) {coverage_0x575eb1ae(0x94544d3d67a31c4fa5173af580161070cdb96ba7f82a4cd1b21263a741f4b91c); /* function */ \n\ncoverage_0x575eb1ae(0x303d23d1ab1a0df4a7af23bf634f52cad20ff0a93dabc501fa8b89c7f3cf9ccc); /* line */ \n        coverage_0x575eb1ae(0xe99fd8f3d03576a27d6a8661fc4213e5c23c95ee2b8273178ca0ec2944c8c449); /* assertPre */ \ncoverage_0x575eb1ae(0x87546008aa167d550e2c30f51363816b611feda442229b25bb840d0c08f7fd37); /* statement */ \nrequire(\n            contractManager.contracts(keccak256(abi.encodePacked(contractName))) == msg.sender || owner == msg.sender,\n            \"Message sender is invalid\");coverage_0x575eb1ae(0xa120f84de4b150c755df48d064bbd82ebf06f7c5f4ae4e4c3a9e71292f85d64c); /* assertPost */ \n\ncoverage_0x575eb1ae(0x5c536ba382a53e26b3821446bc6940a5a5a8253cca68d0884b7da12ea2e8cb2d); /* line */ \n        _;\n    }\n\n    modifier allowTwo(string memory contractName1, string memory contractName2) {coverage_0x575eb1ae(0xc8ca6eb89513eff1a6b1dbf58d50058070c61e9f616c78e5838176cc081cfce1); /* function */ \n\ncoverage_0x575eb1ae(0x2cd119ff981633ac8a95bd081b1d81ef2ab4c1db4437d1e75a77b05ae85834c8); /* line */ \n        coverage_0x575eb1ae(0x72328db7fe213775d2576a62c8a1cecfabc959db909190ea9bee165037992b0a); /* assertPre */ \ncoverage_0x575eb1ae(0x419951e9b15fb890c0390b03218d676befc23e8e310a36d479e2784910c4aac9); /* statement */ \nrequire(\n            contractManager.contracts(keccak256(abi.encodePacked(contractName1))) == msg.sender ||\n            contractManager.contracts(keccak256(abi.encodePacked(contractName2))) == msg.sender ||\n            owner == msg.sender,\n            \"Message sender is invalid\");coverage_0x575eb1ae(0xf34b43fc5347b4b710cd2f68568fa8c83db884c866c30d4ad4c156e8a823d235); /* assertPost */ \n\ncoverage_0x575eb1ae(0x949497029aeaae63846dc73eaa9660e3b1e5ef647cfb00f885945dbc678c3dd0); /* line */ \n        _;\n    }\n\n    modifier allowThree(string memory contractName1, string memory contractName2, string memory contractName3) {coverage_0x575eb1ae(0x6c120ef45415d63e3b122d0c9aa050f1fbe2bbcbbf29d88a39116204443ec4de); /* function */ \n\ncoverage_0x575eb1ae(0x58e591e7f801dfc9fc9bca32fd50de03d7033de4939fdfe4fa3c4a3342e31131); /* line */ \n        coverage_0x575eb1ae(0xad41930561c5773f823b71f065ed52efaffd378ebdcf83a2d95b2b08b4c35c45); /* assertPre */ \ncoverage_0x575eb1ae(0x531c86eee9833b8813d783b46393b82631e1245eec5a180b9511af310d6e4fec); /* statement */ \nrequire(\n            contractManager.contracts(keccak256(abi.encodePacked(contractName1))) == msg.sender ||\n            contractManager.contracts(keccak256(abi.encodePacked(contractName2))) == msg.sender ||\n            contractManager.contracts(keccak256(abi.encodePacked(contractName3))) == msg.sender ||\n            owner == msg.sender,\n            \"Message sender is invalid\");coverage_0x575eb1ae(0xa0168669ec0d2e74ecacc3dbdb82c22b4fb84ddc7d5a100734220add2368082e); /* assertPost */ \n\ncoverage_0x575eb1ae(0xfd0ea93f037b54d419980b6810bed347e44efab7a8efa26fb63adba08355168a); /* line */ \n        _;\n    }\n\n    /**\n     * @dev constructor - sets current address of ContractManager\n     * @param newContractsAddress - current address of ContractManager\n     */\n    constructor(address newContractsAddress) public {coverage_0x575eb1ae(0xad3e910b3876a583dbb9cd0bd8da944a5cde15f6cd1fe4803921607e7575ed6e); /* function */ \n\ncoverage_0x575eb1ae(0x00be9e0cb6d77bfa05963a71cffbc6cc599e01740535fc81e61fd6b46a13c2a2); /* line */ \n        coverage_0x575eb1ae(0xd61d29bfedd41c7e6d9b60be2bfb74ffeefcfcff5b7e279ff3d6964e513f6823); /* statement */ \ncontractManager = ContractManager(newContractsAddress);\n    }\n}\n"
    },
    ".coverage_contracts/ContractManager.sol": {
      "content": "/*\n    ContractManager.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Ownable.sol\";\nimport \"./thirdparty/StringUtils.sol\";\n\n\n/**\n * @title Main contract in upgradeable approach. This contract contain actual\n * contracts for this moment in skale manager system by human name.\n * @author Artem Payvin\n */\ncontract ContractManager is Ownable {\nfunction coverage_0xff601327(bytes32 c__0xff601327) public pure {}\n\n\n    // mapping of actual smart contracts addresses\n    mapping (bytes32 => address) public contracts;\n\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    /**\n     * Adds actual contract to mapping of actual contract addresses\n     * @param contractsName - contracts name in skale manager system\n     * @param newContractsAddress - contracts address in skale manager system\n     */\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external onlyOwner {coverage_0xff601327(0x07fcdfb3f5b7f0d6e5b785c73c9264d34a46d2b456cc4a4e73fca045fb2c8cb2); /* function */ \n\n        // check newContractsAddress is not equal zero\ncoverage_0xff601327(0xd38a7adb77ebefc2fc503a206aaafe9ccb3262cc8cdfd3177edc939744014d8c); /* line */ \n        coverage_0xff601327(0x7c6db695502a048083d2a42f414a0334f460d54ade357de02e41ae872b7229f6); /* assertPre */ \ncoverage_0xff601327(0xe59c6cf0d700dced58e51ed2f279f51241e0091e36c565472213d124aca00bb6); /* statement */ \nrequire(newContractsAddress != address(0), \"New address is equal zero\");coverage_0xff601327(0x8a1e2d5da6c75d7fd3321eec633c07ce669c327ef53cfd52f97723410a76254e); /* assertPost */ \n\n        // create hash of contractsName\ncoverage_0xff601327(0x92818087fc2ed2899668cd3d13b31313a39191cc9637dcb506a09ae90aa03e00); /* line */ \n        coverage_0xff601327(0xd7ea3113ebec253a66183f6d9dbc3201e40a973bc1ad1e3f34a1de34d28cc3b3); /* statement */ \nbytes32 contractId = keccak256(abi.encodePacked(contractsName));\n        // check newContractsAddress is not equal the previous contract's address\ncoverage_0xff601327(0x79a3eb6cdcbfae9be3b2a167a9f04ef440cd07c80311112098dbb0224059052e); /* line */ \n        coverage_0xff601327(0xe8b121957deb44cf0d3e208d488960dcb77354e0606298381bb83e75832e375b); /* assertPre */ \ncoverage_0xff601327(0xf52d1c62354a61c2549b5b4eba9fc01de92ae8b8fca4d537c44e34fbe5f024da); /* statement */ \nrequire(contracts[contractId] != newContractsAddress, \"Contract is already added\");coverage_0xff601327(0x5dd916b83ea363d29b1769fa698b9eb8f99a07ed649e8e99f5df068d24933ff2); /* assertPost */ \n\ncoverage_0xff601327(0xfed0559fe10445371c3d9e30ba3addaea2290ffb4a94d5834f792907710a1543); /* line */ \n        coverage_0xff601327(0xc2805515c5a6deb9b98b056c4085129031f99ecd176685a78fd5b0bba6761c01); /* statement */ \nuint length;\ncoverage_0xff601327(0x85fc52be6a26e414c5a33620459589265df80a977056e1de13b23e5a55a4e654); /* line */ \n        assembly {\n            length := extcodesize(newContractsAddress)\n        }\n        // check newContractsAddress contains code\ncoverage_0xff601327(0x00bff2426740211f924545a446eb2c580c56ac3f02de4cf6cef55a63f1861ca2); /* line */ \n        coverage_0xff601327(0x168a008eb32cfb1218af0b47c9771f86dcd2415de5772460cb118080d4b2f7db); /* assertPre */ \ncoverage_0xff601327(0xc089dc77dce02abec984134aa6e326a6b21b772ee6cd5715c3c0ab2d4f22c329); /* statement */ \nrequire(length > 0, \"Given contracts address is not contain code\");coverage_0xff601327(0x63efac371e835b6f43324c9017b0ba382be62cf87ca2b0782929a1292e332d07); /* assertPost */ \n\n        // add newContractsAddress to mapping of actual contract addresses\ncoverage_0xff601327(0xe8b9555b034bc1e6d145cbf99da5d151cf0894d9ae76776c3df52ccb2d2f57f5); /* line */ \n        coverage_0xff601327(0x838519885969cda2cd4ceb3a699cdf43db1b11d3c77a604e8b3b5b80ca27268f); /* statement */ \ncontracts[contractId] = newContractsAddress;\ncoverage_0xff601327(0xd07c2a542abd44332e85fb680533056cd6de5a19f931f2cad7d47da2dd0f0c4e); /* line */ \n        coverage_0xff601327(0xbd8f44a70e367bb96993447b83eeff6d2ae2ddf9636328ec72168cc85b7a1bc9); /* statement */ \nemit ContractUpgraded(contractsName, newContractsAddress);\n    }\n\n    function getContract(string calldata name) external view returns (address contractAddress) {coverage_0xff601327(0x947edd93699aa8390290be43f615ed6121c9fc9224bca4afd760dc7ad820e8df); /* function */ \n\ncoverage_0xff601327(0x4558aab27b72abd8df306bf80f274aa20a88c438eb5ef92ea648885ba78c3825); /* line */ \n        coverage_0xff601327(0x86dd41de33de083e0dea76bdfd6f7f329d272fc6e81e0573aa6f5739770966b6); /* statement */ \nStringUtils stringUtils = StringUtils(contracts[keccak256(abi.encodePacked(\"StringUtils\"))]);\ncoverage_0xff601327(0xf651de7c171768ad65cd2975b0816cbfe9c0f1927ac2ab726f9958075160363e); /* line */ \n        coverage_0xff601327(0x22e1c9837755597b69f7730e6a8ead671b05644e5573cb6e7550d396058270fa); /* statement */ \ncontractAddress = contracts[keccak256(abi.encodePacked(name))];\ncoverage_0xff601327(0x76fb9484291874cd0a1242b01b2e2bf70fd11d40ce69d83cf7af8003373f8923); /* line */ \n        coverage_0xff601327(0xd41f4ed66967844dd7fdc79e7e8dc52abddf0b0ed605379a631367f90cc60563); /* assertPre */ \ncoverage_0xff601327(0xa5d5ec558ecdd7080d01efb08819727c3a7aa802ac9264e1c9ee02f1454201d8); /* statement */ \nrequire(contractAddress != address(0), stringUtils.strConcat(name,\" contract has not been found\"));coverage_0xff601327(0x74512475d8d4d3c4f4c55b12248b168e5db1cba169a8d63819e4f6a8bd187ee9); /* assertPost */ \n\n    }\n}\n"
    },
    ".coverage_contracts/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\nfunction coverage_0x3c783d81(bytes32 c__0x3c783d81) public pure {}\n\n\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {coverage_0x3c783d81(0x3c32ce56363de1ffea549ee4a131e25a057076057a2d820f8c90e157fc41f062); /* function */ \n\ncoverage_0x3c783d81(0x0d31bf681da14ad2a76a85571b7629c8cf2180a4cac546bc552f5bac1022beff); /* line */ \n        coverage_0x3c783d81(0x1c74df2f99262a3039d82db8db258f9997fe24448cb33364353136a6f1d68d85); /* statement */ \nowner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {coverage_0x3c783d81(0xde7af1221ef3361d4f8684e6dd3371bb30403b54976fa3b2c38419f31280ee9f); /* function */ \n\ncoverage_0x3c783d81(0x7f7a5ec199520e93f6f7860ae73722a2c5aac84b87f3e3b6831b17123171c175); /* line */ \n        coverage_0x3c783d81(0xdddf9b346a5e3c7a33f935f4becd3bd5429c22e6548416dbbc3ac856c09b59db); /* assertPre */ \ncoverage_0x3c783d81(0x23c74944dceb774047ce9bc61b2cd3fd395330a24ffe7bdd93c4a93a75c188c0); /* statement */ \nrequire(msg.sender == owner, \"Sender is not owner\");coverage_0x3c783d81(0x71d31b9cdc34cb9397c1e8a99182873f768d6937d6e331368e5202d548d46502); /* assertPost */ \n\ncoverage_0x3c783d81(0xeb6368959d844788dd7a317c17112f0338cda2b78fb7362b900a3da93e902b51); /* line */ \n        _;\n    }\n\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {coverage_0x3c783d81(0x1eeff29b087822001e179bf7c885acd1cef0e0bf6015a7f319a262e4b87641b9); /* function */ \n\ncoverage_0x3c783d81(0x0219dc9c873b63ac626d07ed4527f8c5ba09d7d42f68b75867fa242ac3dc5ff3); /* line */ \n        coverage_0x3c783d81(0xe4ec043cd92b2ae2d5ecb6d3559634f1046122c417a312a43376c118a99350b9); /* assertPre */ \ncoverage_0x3c783d81(0xabed5f7b57e762830a40b35956723a4c628611fc4a11ed03fba774f8ef9c8965); /* statement */ \nrequire(newOwner != address(0), \"New owner is not set\");coverage_0x3c783d81(0x8958415c164488e964cbc48f9b0a89d64f36880cdfca68e6fae2f649f45096df); /* assertPost */ \n\ncoverage_0x3c783d81(0x67cdf2e15474b3ddb6d4d8eb39db770fcf0cfc8cee9d8786a60b575fbcac9a63); /* line */ \n        coverage_0x3c783d81(0x43e37308bb58c1414e626ea8dd87c1bf8e042115d19abc2e4618fe599d9ce1a0); /* statement */ \nowner = newOwner;\n    }\n\n}\n"
    },
    ".coverage_contracts/thirdparty/StringUtils.sol": {
      "content": "/*\n    StringUtils.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Vadim Yavorsky\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.3;\n\n\ncontract StringUtils {\nfunction coverage_0x717ef7ea(bytes32 c__0x717ef7ea) public pure {}\n\n\n    function strConcat(string calldata _a, string calldata _b) external pure returns (string memory) {coverage_0x717ef7ea(0x6460252c89708a6a218a5c3ed021058f16f0ccaa021e36cb418af1ad24a9279c); /* function */ \n\ncoverage_0x717ef7ea(0x261377c687d1c5e6edec5d125becf688521a9bbe606b3b1ee03e88a6468c0da0); /* line */ \n        coverage_0x717ef7ea(0x7f07122b5432c7e3ecda2c116609525a0d208892acdb891448caaeaf522b1c04); /* statement */ \nbytes memory _ba = bytes(_a);\ncoverage_0x717ef7ea(0x98603e837da1a50a151d411f25be62af0ee114ce26d138e6919ea4f587d18813); /* line */ \n        coverage_0x717ef7ea(0x5682586c3762c191509fa739010186ff71e0691f50c34607144f53295317cf76); /* statement */ \nbytes memory _bb = bytes(_b);\n\ncoverage_0x717ef7ea(0xa420e1c96761d753f41ed5d62d0c6efd9b89ba6f15dfcaf904c33d96be042128); /* line */ \n        coverage_0x717ef7ea(0x58707802a736f71746a6523f2b951fb48f07fe3a95875627c1d8de68f46a83f9); /* statement */ \nstring memory ab = new string(_ba.length + _bb.length);\ncoverage_0x717ef7ea(0x61422d1d44a7e634070364cb00ac543c79f779697fa28a95e726d04ca780f377); /* line */ \n        coverage_0x717ef7ea(0xa08544aab169e3e2f2a38cce161c4cdf1c4dcb4d95422ac5b652340e6c847cea); /* statement */ \nbytes memory strBytes = bytes(ab);\ncoverage_0x717ef7ea(0x034827c893dca55acfe104a7ea288d08ecb2b91b2b0ed5a5317f9c5d897dcaa6); /* line */ \n        coverage_0x717ef7ea(0x8394a9a078c45a27513c644896688dee67ddab76bed66e99e5c432e287dfd2d9); /* statement */ \nuint k = 0;\ncoverage_0x717ef7ea(0x9cddfa741e71c871546980bb36b8fc2d2222e3a8c597a067357cbc650e89e8a7); /* line */ \n        coverage_0x717ef7ea(0x869171d11efee247d418d0a0ba396b893daac39be02aced97242c11d98cecd1a); /* statement */ \nuint i = 0;\ncoverage_0x717ef7ea(0x0f88384d79323b3c1fed304fe3b97a4d4d519d180d500f59ad75fde7d5994336); /* line */ \n        coverage_0x717ef7ea(0x91702cd001866234ba4af13e4ff8285d0855cacd047655027b2875d9fc5d89ff); /* statement */ \nfor (i = 0; i < _ba.length; i++) {\ncoverage_0x717ef7ea(0xa3fae5d872d781fe1c6a2a627cecb77785274a1415375cbbc71ea2055970c575); /* line */ \n            coverage_0x717ef7ea(0xccab46cf011d0bc75afb7a599563793f5f57a37d14b371c60846a248346d580e); /* statement */ \nstrBytes[k++] = _ba[i];\n        }\ncoverage_0x717ef7ea(0xa5b468cc2a279d2dd3ff4dec48c32c91474446a70a36e0c8bd24969cc8fad45d); /* line */ \n        coverage_0x717ef7ea(0xa7725b30d944182794c8e471284ec0b274e91642c958d85a71bfdb76baf8bc93); /* statement */ \nfor (i = 0; i < _bb.length; i++) {\ncoverage_0x717ef7ea(0x953fb786fd5ee44b90f4c25274b856c69d07915f80c442ec899a969136f230b7); /* line */ \n            coverage_0x717ef7ea(0x74a26f1ba229a3b343008a0716e83ec3b7d3df4b2478af31cfd21b734dd81079); /* statement */ \nstrBytes[k++] = _bb[i];\n        }\ncoverage_0x717ef7ea(0xa781b09c80ab4484173668e49759815bbea29cb8b93f5eaa9998f7723e030ab8); /* line */ \n        coverage_0x717ef7ea(0xe8652e7d82c8824f268845e6b3c25df2fc0abc66e4c43c6bcd65f6df07dc5158); /* statement */ \nreturn string(strBytes);\n    }\n\n    function uint2str(uint _i) external pure returns (string memory) {coverage_0x717ef7ea(0x37b4736b43c4f9045104eea0e43e8a6e9b012c530d94c4b77313572fb9ab0935); /* function */ \n\ncoverage_0x717ef7ea(0x433ad363367ec530b2b7a40045ec34dd456e5d8e1f31f8fc5aa00c4ea295fce8); /* line */ \n        coverage_0x717ef7ea(0x463663825e32697272dd50d7d6a1b226751db979a8371cbb03b0885f35fa2fb0); /* statement */ \nif (_i == 0) {coverage_0x717ef7ea(0xf028e96be12889e1b58412778ce46a3419b2b5f8efca0af2d73ccda84baec937); /* branch */ \n\ncoverage_0x717ef7ea(0xc37dbef0f3d5aa6ed4091550bbd123738ff2fe95c5efd7100a93939db254f84b); /* line */ \n            coverage_0x717ef7ea(0x092350609293770aa3d7c22d0f3abe743a4b94c10d0f43fa08ee23eb5717ea48); /* statement */ \nreturn \"0\";\n        }else { coverage_0x717ef7ea(0x86222a51bf4b459bf4469de7ec6b70815dd9282e5f1b013dab4a8b96c0fb84d4); /* branch */ \n}\ncoverage_0x717ef7ea(0xe065e64e436dd87c1bd872209a09976eea5ae9d086db2037ce4dc26f49a772dc); /* line */ \n        coverage_0x717ef7ea(0x06ac542f40c17a43d962090311fac7b26543ad6c097b6bd5fad7d506cdbc0848); /* statement */ \nuint j = _i;\ncoverage_0x717ef7ea(0xf6e7c541e9853c75afee898309c3e759bfdc3842621314d1e3946bbc03daca67); /* line */ \n        coverage_0x717ef7ea(0x5066a6c8f912b3d9a5e40672070c2bc8e8b8f3117c13e724f837ba6a11ab83e1); /* statement */ \nuint i = _i;\ncoverage_0x717ef7ea(0x401512bc7dc92e76f5f34e179f39b90e4c6c0ca4fa2f2b40847706fd41fef7ac); /* line */ \n        coverage_0x717ef7ea(0x1686e8f1c88aec803b3a1f248a6cf7edcb478e31dbd6cad238c41f1449a35c70); /* statement */ \nuint len;\ncoverage_0x717ef7ea(0xe16f1d932e5039dcd34d16f713d7120ad5761f2e6b260390aba4318abe576e3e); /* line */ \n        coverage_0x717ef7ea(0xe9d18e86675baea8c8e46a20bc64aeb56585907ff772fa3a6027cb03c0606db8); /* statement */ \nwhile (j != 0) {\ncoverage_0x717ef7ea(0x5889f9c43c965d978d05290f6100edb0bf20a344400a198614d3b13ef05853a6); /* line */ \n            len++;\ncoverage_0x717ef7ea(0xb40f053bbdbae9e0e8aadc6ed6dd019fe475371fe4ae09070fd8b7a0f2504c22); /* line */ \n            coverage_0x717ef7ea(0xf22f399ac8a91895680f593a63a5fd3f07ee0b5c162733f502a7217615186aec); /* statement */ \nj /= 10;\n        }\ncoverage_0x717ef7ea(0xda0b727347c988d77bf7b2ffb97ee2d9bbcc73aaed37f23512c99bfbbcc2ee19); /* line */ \n        coverage_0x717ef7ea(0x747752e4d0779d18d0ef85a2a3e3c7b508911a260982a608badb6526a3ac6e77); /* statement */ \nbytes memory bstr = new bytes(len);\ncoverage_0x717ef7ea(0xe6caa624401d649cdc768951c81980c3609196b724f00931a9dc5171a5e7887f); /* line */ \n        coverage_0x717ef7ea(0x72ece384381efbf5c3bdd4f7628c065e16aa8c571f91e180d2b4cff413324ee5); /* statement */ \nuint k = len - 1;\ncoverage_0x717ef7ea(0xe1bb6e252a3c711e39515a23ab237700bcff841dbdce6abc8223346f541e2df0); /* line */ \n        coverage_0x717ef7ea(0x6796d9d7e5a547919c6b4ea981498304baebef29a7ac687b81106b9c334d6a9b); /* statement */ \nwhile (i != 0) {\ncoverage_0x717ef7ea(0xc21bdee9cfee290e06d6e6fdb79400e106ed3c5a9fbdfb1b2da2aeecbc03c5f9); /* line */ \n            coverage_0x717ef7ea(0xd181fdf7e7765e94735d90274d731e744c1a38d015d67dd45f827a17ace1b277); /* statement */ \nbstr[k--] = byte(uint8(48 + i % 10));\ncoverage_0x717ef7ea(0x1e746c0ccf313d073dc707bb0323486817cc2c03617b6c7b1cd4ed86bbc87ac0); /* line */ \n            coverage_0x717ef7ea(0x1ee45de227ac697f2cf57bc1a9cfa947c72e5c196b13e3768e6a385fe7ca4b3b); /* statement */ \ni /= 10;\n        }\ncoverage_0x717ef7ea(0x09f5ae3adeabae27c353ea089f506938d92c52ab6ee872dfbf3b5480a4f2b489); /* line */ \n        coverage_0x717ef7ea(0xf62e37837f44c75d9994fb934c6f1ac4cce785f92643a7469f8a0e523ac7b10e); /* statement */ \nreturn string(bstr);\n    }\n\n}"
    },
    ".coverage_contracts/interfaces/IConstants.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Constants - interface of Constants contract\n * Contains only needed functions for current contract\n */\ninterface IConstants {\n    function NODE_DEPOSIT() external view returns (uint);\n    function FRACTIONAL_FACTOR() external view returns (uint);\n    function FULL_FACTOR() external view returns (uint);\n    function SECONDS_TO_DAY() external view returns (uint32);\n    function SECONDS_TO_YEAR() external view returns (uint32);\n    function MEDIUM_DIVISOR() external view returns (uint8);\n    function TINY_DIVISOR() external view returns (uint8);\n    function SMALL_DIVISOR() external view returns (uint8);\n    function MEDIUM_TEST_DIVISOR() external view returns (uint8);\n    function NUMBER_OF_NODES_FOR_SCHAIN() external view returns (uint);\n    function NUMBER_OF_NODES_FOR_TEST_SCHAIN() external view returns (uint);\n    function NUMBER_OF_NODES_FOR_MEDIUM_TEST_SCHAIN() external view returns (uint);\n    function lastTimeUnderloaded() external view returns (uint);\n    function lastTimeOverloaded() external view returns (uint);\n    function setLastTimeOverloaded() external;\n    function checkTime() external view returns (uint8);\n    function rewardPeriod() external view returns (uint32);\n    function allowableLatency() external view returns (uint32);\n    function deltaPeriod() external view returns (uint);\n    function SIX_YEARS() external view returns (uint32);\n    function NUMBER_OF_VALIDATORS() external view returns (uint);\n}"
    },
    ".coverage_contracts/ContractReceiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n /**\n  * Contract that is working with ERC223 tokens\n  * @title ContractReceiver - Standard contract implementation for compatibility with ERC 223 tokens.\n  */\ncontract ContractReceiver {\nfunction coverage_0x8ddb08c0(bytes32 c__0x8ddb08c0) public pure {}\n\n\n    /**\n     * @dev Function that is called when a user or another contract wants to transfer funds.\n     * @param _from Transaction initiator, analogue of msg.sender\n     * @param _value Number of tokens to transfer.\n     * @param _data Data containig a function signature and/or parameters\n     */\n    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external;\n}\n"
    },
    ".coverage_contracts/Decryption.sol": {
      "content": "/*\n    Decryption.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\n\ncontract Decryption {\nfunction coverage_0x2e7cd5c0(bytes32 c__0x2e7cd5c0) public pure {}\n\n\n    function encrypt(uint256 secretNumber, bytes32 key) external pure returns(bytes32 ciphertext) {coverage_0x2e7cd5c0(0x55dd51bfe2417e0f1ab617dc6c74c15b15d922f67a9584ac89aa2330c1670ad7); /* function */ \n\ncoverage_0x2e7cd5c0(0x578b85248a30e17fcf4acf1d7e56cd80c20a974848e31051a6eae15140444611); /* line */ \n        coverage_0x2e7cd5c0(0xd7254f4768af6fa58bacffcacfb22c83741905897d5e3977baab08a1a82678f7); /* statement */ \nbytes32 numberBytes = bytes32(secretNumber);\ncoverage_0x2e7cd5c0(0x64cb75cdfd21913fcc655c753a3dfd6bef2d0052c5efd5340b47bdb3885be153); /* line */ \n        coverage_0x2e7cd5c0(0x6433d31a18f44edbe036e78371a575d3e353fca822012e4cf8fc1ac13eb784ce); /* statement */ \nbytes memory tmp = new bytes(32);\ncoverage_0x2e7cd5c0(0xa405b28cc325497cf3e947f86f098a101eb6ac3f05752c8fad4915b943eaf530); /* line */ \n        coverage_0x2e7cd5c0(0xf13377e83be31182d6abf5cefe13d48f0a4c82587e5d3f8d99c6398b36355b7c); /* statement */ \nfor (uint8 i = 0; i < 32; i++) {\ncoverage_0x2e7cd5c0(0xdf251ae020c389d451a18aead490e0af85acc01e9a9626a55bc25e15959a4d7f); /* line */ \n            coverage_0x2e7cd5c0(0x4c7bf666d374404685c0985cf614988abeb3ea8528fb1265975ec1c50d83831a); /* statement */ \ntmp[i] = numberBytes[i] ^ key[i];\n        }\ncoverage_0x2e7cd5c0(0xf14bb84d73c7e59d7ff4eb68990ba3cd81a5573d27338af2a7dba4e0d083ba65); /* line */ \n        assembly {\n            ciphertext := mload(add(tmp, 32))\n        }\n    }\n\n    function decrypt(bytes32 ciphertext, bytes32 key) external pure returns (uint256 secretNumber) {coverage_0x2e7cd5c0(0xb568ff940a33bafbce223eaae5e7c92146dc95bd3aa6605f6159b93603eaea80); /* function */ \n\ncoverage_0x2e7cd5c0(0x9dd6b5e89097bd891f2c2c3314caed8a84f5a5a71683a8c65a57933a47d3aed9); /* line */ \n        coverage_0x2e7cd5c0(0x64f36f15ead2a239f8b62c2595f3dd386d2e87a10d815e906a26d5c0a2a49541); /* statement */ \nbytes memory tmp = new bytes(32);\ncoverage_0x2e7cd5c0(0x38415e4646122f01cb63d6ed39f9bd3329986ad70b17e6d60a3b33543d3e1b8c); /* line */ \n        coverage_0x2e7cd5c0(0xc9cfe0f01ee5cfbc605672108553cbbc220dcfeb9860e92044205d9db32597b0); /* statement */ \nfor (uint8 i = 0; i < 32; i++) {\ncoverage_0x2e7cd5c0(0xebde3bc743fb109f28d0de05b7f35fe34d0ef6f6bdfd3c1c3b43c98443436760); /* line */ \n            coverage_0x2e7cd5c0(0xa9085c12abe0cb5379e50b4558ea9695b6ee4562374bd42bb7a1f8004edea252); /* statement */ \ntmp[i] = ciphertext[i] ^ key[i];\n        }\ncoverage_0x2e7cd5c0(0xeb3e0520d598ee1629375abee5a9a71279c8790a6f855cd53c77b5a290a394f3); /* line */ \n        coverage_0x2e7cd5c0(0xa55b94560ddd38814a62dd59733593223137424fd53aea580175fb9e8a9771b6); /* statement */ \nbytes32 numberBytes;\ncoverage_0x2e7cd5c0(0x6b3760ab5495ccde4c12f33d42b8b8af5c1f8aa3be00200eb4ae14e9773c03af); /* line */ \n        assembly {\n            numberBytes := mload(add(tmp, 32))\n        }\ncoverage_0x2e7cd5c0(0x9ba91b3131bd9bc01030521572ac7789d5b353f5e1da2a65fdf1b800b8f25d3b); /* line */ \n        coverage_0x2e7cd5c0(0x35c49955102c8dac3cc46b6ecc4d586a05d9122c0497f27f281a32aa48775f94); /* statement */ \nsecretNumber = uint256(numberBytes);\n    }\n}"
    },
    ".coverage_contracts/ECDH.sol": {
      "content": "/*\n    ECDH.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\n\ncontract ECDH {\nfunction coverage_0x54a16165(bytes32 c__0x54a16165) public pure {}\n\n\n    uint256 constant GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n    uint256 constant GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n    uint256 constant N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n    uint256 constant A = 0;\n    // uint256 constant B = 7;\n\n    constructor () public {coverage_0x54a16165(0xec1216faaa14c670b8bf296d993a247d134976ceda78e9450ca6de58e3a83593); /* function */ \n\n\n    }\n\n    function publicKey(uint256 privKey) external pure returns (uint256 qx, uint256 qy) {coverage_0x54a16165(0xb340f97d423853140472a2d584d055a430e7321bb3c48be4e9793f7746ec8041); /* function */ \n\ncoverage_0x54a16165(0xef92ea3e8a37beb84189561cf53128a956a639e76ed863326ed5a756888bfbda); /* line */ \n        coverage_0x54a16165(0xb2acdab7d9ad2f54ab546327e566af09569948013663c3b50fa1f8c4384c93e5); /* statement */ \nuint256 x;\ncoverage_0x54a16165(0x24a4073058bf0801fb74ba576c7c9b095b4eea43c03a313259d675e4bc935034); /* line */ \n        coverage_0x54a16165(0x136e3220b6a752d8ed76034148885743f7546687d8aaf303a45ee55911473fed); /* statement */ \nuint256 y;\ncoverage_0x54a16165(0x8a8665f35a5ed2a4d6f7b374a9fd6b70314fc913cb3117bf404abd26e1f81ea4); /* line */ \n        coverage_0x54a16165(0xba08d91cc77762fbac5bdb622983fcfc902cb7dd515a0003307fa72916376c18); /* statement */ \nuint256 z;\ncoverage_0x54a16165(0x16d631cd93c76bd546ab916dbc16cb2116736df684af3b1a1d41970e63b001d5); /* line */ \n        coverage_0x54a16165(0x7e2a033575aafcf595555d691517a2c5bdcd43c276aaf3f5ab399425cedcc9aa); /* statement */ \n(x, y, z) = ecMul(\n            privKey,\n            GX,\n            GY,\n            1\n        );\ncoverage_0x54a16165(0x36dc1d5f31ff01b4ae7fdc297dcca78b91d3b96d7dad003b5f7d86a9a6e21824); /* line */ \n        coverage_0x54a16165(0xc0364dd3b06b9d1bb790c7bc6cbf93d95985e3340f304a50fb8db5a5214b96da); /* statement */ \nz = inverse(z);\ncoverage_0x54a16165(0x7ad2afe3682ec9f5cd1b65c209bcb8b123238fef0dff4ca82f18caa93516f7bb); /* line */ \n        coverage_0x54a16165(0xf5f0f1b43bcad8aaccb1c29855e00b17c3eb62bd45da0d9418000c7f2214d05e); /* statement */ \nqx = mulmod(x, z, N);\ncoverage_0x54a16165(0xb06e44a150c5c9778052ad7d5c8666266c86a48cfad4311a3917f00fdf3d957a); /* line */ \n        coverage_0x54a16165(0x2b13cfa87c31444a75ca8d028ec45fdaeb16286177eae00ad87dfc042d7fdf7b); /* statement */ \nqy = mulmod(y, z, N);\n    }\n\n    function deriveKey(\n        uint256 privKey,\n        uint256 pubX,\n        uint256 pubY\n    )\n        external\n        pure\n        returns (uint256 qx, uint256 qy)\n    {coverage_0x54a16165(0x4229ae7e48220bfed9055c783cb353a91ee28514842361b1a589aa311b781630); /* function */ \n\ncoverage_0x54a16165(0xcdf03f0e9868009485b31c7c92c6babdc6561b1518e95fca8e9f57197ec34628); /* line */ \n        coverage_0x54a16165(0x754fdc9d5d96d2539038ab6dc62f7ea062f360a70f927fce9d82e88e0d3f8de4); /* statement */ \nuint256 x;\ncoverage_0x54a16165(0xdae43a6ca987f2b8ab431696c167a2361f6c703213143d7e36eb357c28871081); /* line */ \n        coverage_0x54a16165(0x5d91a89a7323332e490add51d9eb336ae43ea8faf3fad802544c99712422d9fb); /* statement */ \nuint256 y;\ncoverage_0x54a16165(0xfc064364e3a2128cb286126551c75e93e80ca736e4b510171007992676271a86); /* line */ \n        coverage_0x54a16165(0x874488c67d4bb812b29f03c6eff992044fa5af05d7dcd8a23043a020825d80ab); /* statement */ \nuint256 z;\ncoverage_0x54a16165(0xb9273076eec191b19b3c77aa55ad8272ee20b41cf812298677cc0815f64b32ea); /* line */ \n        coverage_0x54a16165(0xc27c630f2443f3e2b45dfed973e217012d732d19d57c32f185100517a4e7ff00); /* statement */ \n(x, y, z) = ecMul(\n            privKey,\n            pubX,\n            pubY,\n            1\n        );\ncoverage_0x54a16165(0x67d3170d2ab8078a7f850cefabcb0999ac47b7785adf3a9bf63dbede12c3edc2); /* line */ \n        coverage_0x54a16165(0x3733f4cac3a7996170b7b66336916ae85b250561c2fe52e6ce7874a6f26367a3); /* statement */ \nz = inverse(z);\ncoverage_0x54a16165(0x61114918029f75ffa9e717df2bd582dea26ad00cf2454f48412a092bf1456451); /* line */ \n        coverage_0x54a16165(0xeb7cce57ee688f35e7170f9a769bd617abc6d47fd31b2c375f78012185a5ad97); /* statement */ \nqx = mulmod(x, z, N);\ncoverage_0x54a16165(0xb1dbe9364a1af7a5c0001479052c252b23a529135fbaa1eb5a8ff80eaf7b7141); /* line */ \n        coverage_0x54a16165(0x943d02b4764f74857c6bd5ebd63575cb11cab8b86a3213a624503f7f76490445); /* statement */ \nqy = mulmod(y, z, N);\n    }\n\n    function jAdd(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {coverage_0x54a16165(0x3412f2b547d264bb39be5586e99f10633965b600a894c74c7045f2ec20625227); /* function */ \n\ncoverage_0x54a16165(0x47910006206bf5a564775a2c418a9d9caae85b5f6054aa9d4fb5c689cc113936); /* line */ \n        coverage_0x54a16165(0xce45d83005036bb79a20d17325555f5ed25b068ccab2ca5a0bcd127592087d1b); /* statement */ \n(x3, z3) = (addmod(mulmod(z2, x1, N), mulmod(x2, z1, N), N), mulmod(z1, z2, N));\n    }\n\n    function jSub(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {coverage_0x54a16165(0xfe9559461399db809abcc183a3fdd10e1958a6ad8b18a6dbc3ccabde25a13f9b); /* function */ \n\ncoverage_0x54a16165(0xd719524f2d852a919d97f5855b470b44db6490ef4ca85205d00650b4ba209667); /* line */ \n        coverage_0x54a16165(0x88de61b38bc2c5033dad5ae96065dbffa62bc8531ef3d87509559117e4b78220); /* statement */ \n(x3, z3) = (addmod(mulmod(z2, x1, N), mulmod(N - x2, z1, N), N), mulmod(z1, z2, N));\n    }\n\n    function jMul(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {coverage_0x54a16165(0xe3f3f704d666c2b062af1c02f4d085572333f1953123ff773d8e677546439b95); /* function */ \n\ncoverage_0x54a16165(0xa7d59058df4e39be4891d889ba0abf81b0dedfb788f729d2c6e4022244c6ff88); /* line */ \n        coverage_0x54a16165(0xd4d12a0ca6324932cc25e6141824b9d68d291ec1406473cc0b58ea11c759b83e); /* statement */ \n(x3, z3) = (mulmod(x1, x2, N), mulmod(z1, z2, N));\n    }\n\n    function jDiv(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {coverage_0x54a16165(0xddac427f1f323b171f5751811455cde7657d2fefb574d1bb14da05f27e01a2d9); /* function */ \n\ncoverage_0x54a16165(0x02b7721db0bb4801e03927682be00be24d40d4b0392b589937fb3c9076ecb36d); /* line */ \n        coverage_0x54a16165(0x45758ad2714d6b06ecd0008c7cb485781db2a78d3423ad19d1e863b20b4c96ab); /* statement */ \n(x3, z3) = (mulmod(x1, z2, N), mulmod(z1, x2, N));\n    }\n\n    function inverse(uint256 a) public pure returns (uint256 invA) {coverage_0x54a16165(0xb95a47f309b3ea096de45db3aaf9bcaa53d9f2f0a4b4c75c9d95c9849830f851); /* function */ \n\ncoverage_0x54a16165(0xa2875061a48ef8d65a000fd1f26e3d7bb8261993086a1ea28f289e852ab775d0); /* line */ \n        coverage_0x54a16165(0x8fcd51f552a3b487848245ae2dc836bcd21c5dbc10fab2c70081fddb1d616d10); /* statement */ \nuint256 t = 0;\ncoverage_0x54a16165(0xdc4b92230e526be8550a904b5f2acee44a34d003f895bcdb2c57f66164fb9f5d); /* line */ \n        coverage_0x54a16165(0x3583f10982d261d405f20d5fd26399ed79f7e262e55e90c81a046f313f2bede8); /* statement */ \nuint256 newT = 1;\ncoverage_0x54a16165(0x079897d5c46faa456e70e6f193dde93387365379debbab439fc89c970c59ebb0); /* line */ \n        coverage_0x54a16165(0x35fe792a879fa4d647a7524babae31fab6ee32cbb89786f70e13b465e41737bd); /* statement */ \nuint256 r = N;\ncoverage_0x54a16165(0xc99920ec8888a7640c15d8e863268f4b93bc3645f37a0e6d12087db469cdf3bb); /* line */ \n        coverage_0x54a16165(0x97d7fa9fbf440912524a6501e71a865d53e706fec3692932d9c11b4f10e1aae7); /* statement */ \nuint256 newR = a;\ncoverage_0x54a16165(0x00688314452f4b57929355d1d8d602d37ba551b1441763491b969e024e1f4779); /* line */ \n        coverage_0x54a16165(0x0a6a31758bf6b2dd464f18b915ee336ba64cf8e6c4787054ab396b590f958413); /* statement */ \nuint256 q;\ncoverage_0x54a16165(0xb0e96647f743158cfd0468086121a59e36c9038b9c0a8ad1bce74e18a7e97ff4); /* line */ \n        coverage_0x54a16165(0xcfd5c0d73b26c706561f234a8abf1dbfb4eac3b5dc9e1963011f44267b03fe75); /* statement */ \nwhile (newR != 0) {\ncoverage_0x54a16165(0x84f55aa3cb197393dc8e93e3fd4c30e516aa609dee3a93da340d3d8177092300); /* line */ \n            coverage_0x54a16165(0x485f03733d342046117dad7a460b30a7ca076bb783bcf4bc515621db37be78b6); /* statement */ \nq = r / newR;\ncoverage_0x54a16165(0x2201054bc35c5c6fd03b8d7e971ce0a6bd463f346418f50a7f2ab92d563945f7); /* line */ \n            coverage_0x54a16165(0xc2f01e82f4fbfc603ebca1939e65282386f6eb53d88d9868bab6c0e9d6d90e46); /* statement */ \n(t, newT) = (newT, addmod(t, (N - mulmod(q, newT, N)), N));\ncoverage_0x54a16165(0x005e9f8e54dd5a8d467702fd143de52772c5d95d5e448e65ca1742ad0add7848); /* line */ \n            coverage_0x54a16165(0x6b16a139c7036e53896c4eb9ee8636129dcf2711d52cec3a3634faaec6c341b5); /* statement */ \n(r, newR) = (newR, r - q * newR);\n        }\ncoverage_0x54a16165(0x271173c630669c8eb711954ee724ed88fb7e0d715c2048bc3df36354a4b9b659); /* line */ \n        coverage_0x54a16165(0xca8cadead1c1ed5f6cffa33a5493e1bf68df59dd25cd23d2f8acf3c8bcc66bba); /* statement */ \nreturn t;\n    }\n\n    function ecAdd(\n        uint256 x1,\n        uint256 y1,\n        uint256 z1,\n        uint256 x2,\n        uint256 y2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {coverage_0x54a16165(0xe553e2228255cbf0a43cd256ffab5ce9f0379b9817b6b08df739fd4f262da364); /* function */ \n\ncoverage_0x54a16165(0x706edd0024636157cab75c87401b572dee9c49b33ce36789c8f53c5bfce79b9d); /* line */ \n        coverage_0x54a16165(0x43e971f3b1c4ee5d0a97f6df4b6208be2e17d8a00d31cfcb4efd486d64724702); /* statement */ \nuint256 ln;\ncoverage_0x54a16165(0x96cea72082568f5d407c099d68a779a8ac76e596fb85b778e6b5eea1d5f1a24d); /* line */ \n        coverage_0x54a16165(0x0ee3928d26e3ea2faa65e49165e661f16b4e15d07a9d08eb085a660885cb0992); /* statement */ \nuint256 lz;\ncoverage_0x54a16165(0xcb8d6001b8069772fc6b7bdb3f89d7b5aaec67a877b4ffedb02dcd90aea63bfd); /* line */ \n        coverage_0x54a16165(0xd083ef641b43d67b0fc7c2f0adc0912d8ce81b63f7d054b4dee64e8feddef29a); /* statement */ \nuint256 da;\ncoverage_0x54a16165(0xb59442455d8b3cb51233b5d5b1b6a06ffef0bc71e621bd78848ba8d3ad722a5a); /* line */ \n        coverage_0x54a16165(0xfbd485f6e0fc9d87571ba1147df376c8fb212b5c6097833a91c3caea4cc1b998); /* statement */ \nuint256 db;\n\ncoverage_0x54a16165(0x54cc9cf11de9f6941b8a59034a09c2bf3c7a476785597cc6b35df2a83025f3b8); /* line */ \n        coverage_0x54a16165(0x35fb1ec7e3e5625f0e7594b4709b9c57682c149f02ba7947f0ab665aa97df29d); /* statement */ \nif ((x1 == 0) && (y1 == 0)) {coverage_0x54a16165(0xeff9f99f1b56945015470e47662d69418bee4d7b12c6ca18bd27c5758e1b6645); /* branch */ \n\ncoverage_0x54a16165(0x7ee0be7954deaf66cf8bafd13fa816c9e429b14bf6395f8a7b3cc94958d60845); /* line */ \n            coverage_0x54a16165(0x1cb3a9424271d44ab2f2edc6f39a0b103a5d8756c4eaff3919cb6ca7bc49a57e); /* statement */ \nreturn (x2, y2, z2);\n        }else { coverage_0x54a16165(0x3a6df41d95c9cabfdb8d81045775e9ba29c76046096c79dc4b475645bec4ceaa); /* branch */ \n}\n\ncoverage_0x54a16165(0xaa2cff910b0ec9784ae9eae6724a8ba8aaad76de6a943e04cb3d6cee0f5779f3); /* line */ \n        coverage_0x54a16165(0x7b99f037f1d0161114ea9893645f001d6448e7f8e8e633373abea03cc6613916); /* statement */ \nif ((x2 == 0) && (y2 == 0)) {coverage_0x54a16165(0xd386aeb20d48b38210d19fd936fdc813bbd047eeb7600aff3b8e986be72ea7ec); /* branch */ \n\ncoverage_0x54a16165(0xc5590e31417a67f7077db6624f2ee01d8d01684b6a95b2e9ee613705cc2b4953); /* line */ \n            coverage_0x54a16165(0xed2be58d2c6172e8197e8b7b9f1247ab0f063c2b300f9c5dd3429a48d85b9df9); /* statement */ \nreturn (x1, y1, z1);\n        }else { coverage_0x54a16165(0xf6f605d2b4a5d50b651a78f86ae00ac7a1b5cda451ccf7d99600bd34b09bc6bb); /* branch */ \n}\n\ncoverage_0x54a16165(0x559164c0b40bbab59d5d1779d0680d2d705fcf14752cb84c0bd3adc8304dd2ec); /* line */ \n        coverage_0x54a16165(0x3e725ede18ed04bedb87f9feefa3767d95ec3749f5cd269e51da137e4c87de13); /* statement */ \nif ((x1 == x2) && (y1 == y2)) {coverage_0x54a16165(0x0b152c5174bf665e69ffacba30a55f47645554c5d54f70287d9acc35ed2c6970); /* branch */ \n\ncoverage_0x54a16165(0x66752d82bddbcf6c0deeed4060564fbb559bf40531ab9624dee886e537bd08f2); /* line */ \n            coverage_0x54a16165(0x8213ebec0191bf2558b2cdc6670bf7c51e62b9f20100e31a8f8c77f7349d638e); /* statement */ \n(ln, lz) = jMul(\n                x1,\n                z1,\n                x1,\n                z1\n            );\ncoverage_0x54a16165(0x3a352cc82d0b1b9d4035ba8eb18df4664349f8b4432bd2d6ab066e2d18bde94e); /* line */ \n            coverage_0x54a16165(0x38f6ca41a9a58b428adc211762246ccc307a8e87d967235aa0100d3b3fb410c5); /* statement */ \n(ln, lz) = jMul(\n                ln,\n                lz,\n                3,\n                1\n            );\ncoverage_0x54a16165(0x86d9851bcff44d67248bfe784a58bda4ecd0868488b955fbdc04e5d5d8f8e665); /* line */ \n            coverage_0x54a16165(0x109d64ebc3fa636f45f2db7648667f449531b58bf2251a9b5d066225b443eb1a); /* statement */ \n(ln, lz) = jAdd(\n                ln,\n                lz,\n                A,\n                1\n            );\ncoverage_0x54a16165(0x79debb607d5574f56f2736913ddcc9440f221accd28c489ef9f1b21330a8d7ca); /* line */ \n            coverage_0x54a16165(0x494011b9da331ab555aa3aaedef6d8d5c18fbbc3422e8d9271e59abbada82575); /* statement */ \n(da, db) = jMul(\n                y1,\n                z1,\n                2,\n                1\n            );\n        } else {coverage_0x54a16165(0x668e10d26e76b7dffb44c5756456db2a950becc2baf35113dd91f16219a95bf6); /* branch */ \n\ncoverage_0x54a16165(0x90db8b66eea4bcef274b85bc88c34ad4cbfa2539e7238c228b346a5423cb0d46); /* line */ \n            coverage_0x54a16165(0xee90a3bcf3c3f979f239a62834ce11766d46ef9f3dfbef9325448273322fd7bc); /* statement */ \n(ln, lz) = jSub(\n                y2,\n                z2,\n                y1,\n                z1\n            );\ncoverage_0x54a16165(0xab96dc188df4e5529fb8deffe760fb3d3dc500c01f29e56ec50845bea27074d7); /* line */ \n            coverage_0x54a16165(0x7dcbdbdb355117f334d68635fe75932f34d81e2f4ca4242413513c6f24541b4d); /* statement */ \n(da, db) = jSub(\n                x2,\n                z2,\n                x1,\n                z1\n            );\n        }\ncoverage_0x54a16165(0xd304afc2ed81e0fb262aeee72fb27b809fed34c1fe89feb69015adaa5f50e014); /* line */ \n        coverage_0x54a16165(0x2b39a66ddee88df08069f5611e51c3123b5a3fc32467d2633f8ec8771f44bf7a); /* statement */ \n(ln, lz) = jDiv(\n            ln,\n            lz,\n            da,\n            db\n        );\n\ncoverage_0x54a16165(0x6210d49cf3597d135d654bc42662bcf7ecbdace2bb552c4e64cde2001e9eb51d); /* line */ \n        coverage_0x54a16165(0x6892f807895d796a13db67a4112adc82519f54aab5aa5981e9737e4dd1e1145d); /* statement */ \n(x3, da) = jMul(\n            ln,\n            lz,\n            ln,\n            lz\n        );\ncoverage_0x54a16165(0x2fbf1f2e88b21c7a31c8691c57dab9eb3074ed52c0f1165d56a55801b6d5f386); /* line */ \n        coverage_0x54a16165(0xeb8b8227715ab8e5aa51097d4df6a4b370204f06ceff192d620e43302238e78e); /* statement */ \n(x3, da) = jSub(\n            x3,\n            da,\n            x1,\n            z1\n        );\ncoverage_0x54a16165(0x685635c461b39dc723e22c26dbce3ba93b9a61ad71f2de317824ddd1ed7b80f8); /* line */ \n        coverage_0x54a16165(0x0d65e6c85703d4c207cf33cbb1be23effc4b679d75d114643108bfd0991a754e); /* statement */ \n(x3, da) = jSub(\n            x3,\n            da,\n            x2,\n            z2\n        );\n\ncoverage_0x54a16165(0x95ee6f7a48678be1dc75d7a456ea7472411f83256089a5a7f85c8bc3474b9bfd); /* line */ \n        coverage_0x54a16165(0xda0142e87aa57087161a3ccc0bc3a5a4313c55eac866c01b5ef47db323da264c); /* statement */ \n(y3, db) = jSub(\n            x1,\n            z1,\n            x3,\n            da\n        );\ncoverage_0x54a16165(0xf973fee3a625c8c92a21289282d4f6c8dc8414607c36fea74f3531791bc5bdbe); /* line */ \n        coverage_0x54a16165(0x93a0711aab85b7c667efa7d08d32e0a2f6c9f8e739bb438563eaf7f489f93933); /* statement */ \n(y3, db) = jMul(\n            y3,\n            db,\n            ln,\n            lz\n        );\ncoverage_0x54a16165(0x0dd9b0d694fd9efb567c175ee2efc0d5199eb2a85aab2e9a43ced9f7cb8fce68); /* line */ \n        coverage_0x54a16165(0x251caf91ddd7d1b92c242c8fd020f272f1c9f709c271454f8ba880b413ec4243); /* statement */ \n(y3, db) = jSub(\n            y3,\n            db,\n            y1,\n            z1\n        );\n\ncoverage_0x54a16165(0x34f3a189d09c2856c971758b4d6f7b1945888cebf12204aa8f5be087705c669d); /* line */ \n        coverage_0x54a16165(0x254f1ff1c9ca23da753033b68d4d215697d6fed8a1c7a00709834de5339c9e81); /* statement */ \nif (da != db) {coverage_0x54a16165(0xe46500075b525075373167c46225a0ba6c17112d96ed663d1e1c3b168032c54d); /* branch */ \n\ncoverage_0x54a16165(0x9bf01b55e4b9fbd5943f26a39afe3249ac019d501731b0f28fd72ec7a1ba0341); /* line */ \n            coverage_0x54a16165(0x278434ce69aad28646860f6ff1d7e1c704a6ddb5ba48ffcc9064cd53d6c6a497); /* statement */ \nx3 = mulmod(x3, db, N);\ncoverage_0x54a16165(0x7b51a78f760e35909e012f938eb277554e02a5e0852776ccf1fa7d156d4c8103); /* line */ \n            coverage_0x54a16165(0x18a678bec36201823cc1dab0d2f2d2436541ce1732b56796032ab8f3ab7c84eb); /* statement */ \ny3 = mulmod(y3, da, N);\ncoverage_0x54a16165(0x81505165f927469c5eca8993db838110d1c09c1cee3f523e7e9f913feabd1ace); /* line */ \n            coverage_0x54a16165(0xceac914aa62050474366529df722ba24284527f72c5e29623ca548381437dc13); /* statement */ \nz3 = mulmod(da, db, N);\n        } else {coverage_0x54a16165(0x1d5331265b2ccd9a5178d9c280b9c4372c91124fa2045c5645da6e7910261631); /* branch */ \n\ncoverage_0x54a16165(0x4af26b212c7115611e97e0cc8c3e68aa4158ef6c8011f5a980bba05d2c22cfdf); /* line */ \n            coverage_0x54a16165(0x6fb13cd724d20301b095f71f67553b3769cbc97bb797ee416b88a656422b27d9); /* statement */ \nz3 = da;\n        }\n    }\n\n    function ecDouble(\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {coverage_0x54a16165(0xe2d835e7e94d17aff8cc8bc1f46392cdf401814ec8d63d50acd0c44c08b5d2a7); /* function */ \n\ncoverage_0x54a16165(0xdde97ef2988ba5a8eb3936205ea7b49e16f4f1610a0273d5009805a0d572fdeb); /* line */ \n        coverage_0x54a16165(0x8f157d0811bafe8ecebe571340ca211bd852a47eb6f79d83f3069c9bf9b57ad5); /* statement */ \n(x3, y3, z3) = ecAdd(\n            x1,\n            y1,\n            z1,\n            x1,\n            y1,\n            z1\n        );\n    }\n\n    function ecMul(\n        uint256 d,\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {coverage_0x54a16165(0x50967edd9a02be0d4f75ed920e65912db47cbe40e951753abf4ae0b8a36933ab); /* function */ \n\ncoverage_0x54a16165(0xd7693f6aacf4508fa6b93869fc2ede0a13dd4035eb6d32d86e512c61d776f79b); /* line */ \n        coverage_0x54a16165(0xd6cc227d985eb6117125bf022cf1d817a66f3e62a5ac41244c11a56fd056cb30); /* statement */ \nuint256 remaining = d;\ncoverage_0x54a16165(0xa8d899379d9b5817e292ef0f06f531ea168797fee234985f669465619681b9c0); /* line */ \n        coverage_0x54a16165(0x93dc6ab9008796865b9e6e1761764d66c2ed0d856d7db1d5e3b08d13af6ea369); /* statement */ \nuint256 px = x1;\ncoverage_0x54a16165(0xecbbb1459b460feb34054d69bb939b047e27af2390b1018022f2d5376c6916ae); /* line */ \n        coverage_0x54a16165(0x90938b51b8d937527f72f150eb0cc6fcb82c8904c04d4846b0b313a37d0efae4); /* statement */ \nuint256 py = y1;\ncoverage_0x54a16165(0x9d4ef3e5803c183e45a68b29c952546327926f1e37b7e8ac75e786275911d7ac); /* line */ \n        coverage_0x54a16165(0x179add24ac43ea4db03dcf1a12caed9941aff9ef33741edfd8505692add9ede6); /* statement */ \nuint256 pz = z1;\ncoverage_0x54a16165(0x22e6cce4395d0b4e945ac6b233f9cfdf734477f37975838b1531ff4f104495a6); /* line */ \n        coverage_0x54a16165(0xf4a6cfdfa58158058baa41f0bf192c11144bf2f3db3a1aa086745b116258ff4c); /* statement */ \nuint256 acx = 0;\ncoverage_0x54a16165(0xa3bc84fad6f3c9bee75439313c83df0d8d0d35c660c0de94acd7b98ff83676c9); /* line */ \n        coverage_0x54a16165(0x1b75659761f3adf7d614fcb77cb2fbb5b01951ffdf60c8f7849231fa07b31102); /* statement */ \nuint256 acy = 0;\ncoverage_0x54a16165(0x6a4f430416bbbc25d365f01be9c5288483777ec5ef119860fbd3215369af42bb); /* line */ \n        coverage_0x54a16165(0xcc06cb509c1e52b3e9cdc1d30ed4472154e5328c4fb28cb07c58311f5b4cf778); /* statement */ \nuint256 acz = 1;\n\ncoverage_0x54a16165(0x0158c00377dc7ff5eda80cfcd28514365e592b45f0ca7c6ddfc5efce0198a1f8); /* line */ \n        coverage_0x54a16165(0x9c061a158089509e2df41a8adff2fef9459b480d53c61109224a409d5e7cd32a); /* statement */ \nif (d == 0) {coverage_0x54a16165(0x905c30f430bc8b57cdf1544d86120a4b980b58fc34a0bd30dc8a2f5688e484f8); /* branch */ \n\ncoverage_0x54a16165(0x1c4c0a848973f5a21d476383882903e1e440e226fbdec4644093750fad640fed); /* line */ \n            coverage_0x54a16165(0x4cd7aa19d347674df7e488fb8bb513fa3ddeca0ef9d0a04b67688859b062f951); /* statement */ \nreturn (0, 0, 1);\n        }else { coverage_0x54a16165(0xf5e888e5c39635a344e97784c6be44bd7af91a748eed2a1532e557b434917af5); /* branch */ \n}\n\ncoverage_0x54a16165(0xd6046bdbf09517c1d26a77e7eff0069634ba28c424ca994895b038905a86356e); /* line */ \n        coverage_0x54a16165(0x5060cacef5c93ca691056a7f4a80c7bd4cf289368210c44ea89488ee5ca89d0d); /* statement */ \nwhile (remaining != 0) {\ncoverage_0x54a16165(0x850134d67c5f8187e9ef2e8a6edf8f82b88e0de0ee6a1d17b6055ccd9fac1b01); /* line */ \n            coverage_0x54a16165(0xbd6b0d64c19d054628336baaf9e1a40fdac6a44b1ace5c0e84da84ab3a129e8d); /* statement */ \nif ((remaining & 1) != 0) {coverage_0x54a16165(0x073ecea86d045fb9ab51fe60d82715058953a45eedf2f4bd487e5cbfc70710aa); /* branch */ \n\ncoverage_0x54a16165(0x559e4e909a027e2cca675f6cc69944c94e9176af39388b38e15ab3e2eeaccc19); /* line */ \n                coverage_0x54a16165(0xc72e1440ae685995da23dc8add805189bcd5850656620ae68e1771006bd5ddeb); /* statement */ \n(acx, acy, acz) = ecAdd(\n                    acx,\n                    acy,\n                    acz,\n                    px,\n                    py,\n                    pz\n                );\n            }else { coverage_0x54a16165(0x4450b0c784ffd877694fce9dc8eb57f60331a2578e528d3cec3af0ec67a9e346); /* branch */ \n}\ncoverage_0x54a16165(0xd2b2c61f6e02a7f9a5af80ff8cace7a5f2d62981942491074977f31b02ca95f5); /* line */ \n            coverage_0x54a16165(0x23c864c0114703a52a5c3c6bff1425e7d9a9f9dd7ae86ed06facb99271520537); /* statement */ \nremaining = remaining / 2;\ncoverage_0x54a16165(0x3709624d47972479890fcfd59da6d63ff59c31e15bdb44f41a7e58d98f03e12d); /* line */ \n            coverage_0x54a16165(0x6cac487bd9fce22e67e3d27d741790531b51ed0505b31e6430936be20da420e5); /* statement */ \n(px, py, pz) = ecDouble(px, py, pz);\n        }\n\ncoverage_0x54a16165(0x29457faf9dc5941d497314b46c09ec1832c99b53ef765e9f709c63e5f86e19f5); /* line */ \n        coverage_0x54a16165(0x7a23e652466527186ed53904950fa12bd317e866e069c6e51474009191c9e7fd); /* statement */ \n(x3, y3, z3) = (acx, acy, acz);\n    }\n}\n"
    },
    ".coverage_contracts/GroupsData.sol": {
      "content": "/*\n    GroupsData.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IGroupsData.sol\";\n\n\ninterface ISkaleDKG {\n    function openChannel(bytes32 groupIndex) external;\n    function deleteChannel(bytes32 groupIndex) external;\n    function isChannelOpened(bytes32 groupIndex) external view returns (bool);\n}\n\n\n/**\n * @title GroupsData - contract with some Groups data, will be inherited by\n * SchainsData and ValidatorsData.\n */\ncontract GroupsData is IGroupsData, Permissions {\nfunction coverage_0x03b7aa14(bytes32 c__0x03b7aa14) public pure {}\n\n\n    // struct to note which Node has already joined to the group\n    struct GroupCheck {\n        mapping (uint => bool) check;\n    }\n\n    struct Group {\n        bool active;\n        bytes32 groupData;\n        uint[] nodesInGroup;\n        uint recommendedNumberOfNodes;\n        // BLS master public key\n        uint[4] groupsPublicKey;\n        bool succesfulDKG;\n    }\n\n    // contain all groups\n    mapping (bytes32 => Group) public groups;\n    // mapping for checking Has Node already joined to the group\n    mapping (bytes32 => GroupCheck) exceptions;\n\n    // name of executor contract\n    string executorName;\n\n    /**\n     * @dev constructor in Permissions approach\n     * @param newExecutorName - name of executor contract\n     * @param newContractsAddress needed in Permissions constructor\n     */\n    constructor(string memory newExecutorName, address newContractsAddress) public Permissions(newContractsAddress) {coverage_0x03b7aa14(0xe2afd6b38ce9ede5581cd535a584a9ff974689b8252f8f0ff719fb862b01d781); /* function */ \n\ncoverage_0x03b7aa14(0xfec469a4cf5f2f49856c21aaaaabe57c45c73e5cdfd4d9c29308fe055da1789d); /* line */ \n        coverage_0x03b7aa14(0x8624667a3b044cb051da8ad7bb8e5d619d8ef40425e04820c11519f99dcbdf55); /* statement */ \nexecutorName = newExecutorName;\n    }\n\n    /**\n     * @dev addGroup - creates and adds new Group to mapping\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     * @param amountOfNodes - recommended number of Nodes in this Group\n     * @param data - some extra data\n     */\n    function addGroup(bytes32 groupIndex, uint amountOfNodes, bytes32 data) external allow(executorName) {coverage_0x03b7aa14(0x55fe1eee7c5920b9c20553b2cf3963dd19ccd93f93ca70437124bec556c0496e); /* function */ \n\ncoverage_0x03b7aa14(0x1945825c5b8c87b195a9803f4c31badaf28ec2808900f0f8b3052a5daee2f12c); /* line */ \n        coverage_0x03b7aa14(0xe90267c55ee173b578bcd8bbdfafe768c9bb19864af5044c8c130824e3387145); /* statement */ \ngroups[groupIndex].active = true;\ncoverage_0x03b7aa14(0x4b56fe94b4b643b4fda00969ed51f34bab4bb925c29a2c8287d74d67392e051f); /* line */ \n        coverage_0x03b7aa14(0x2dc367caa24e18ca5558e366e48411f0ac1f0c48c578e4f53a258d3ed3b1e500); /* statement */ \ngroups[groupIndex].recommendedNumberOfNodes = amountOfNodes;\ncoverage_0x03b7aa14(0x482b23d72b6e093b02c1a47e0d4f035e8b4f5ec5b32abb93eb01d3f26b79a940); /* line */ \n        coverage_0x03b7aa14(0x3d9eed84db24800fafc3ba104e9a31f617e126bac73958f0bc1db04f907fb80f); /* statement */ \ngroups[groupIndex].groupData = data;\n        // Open channel in SkaleDKG\ncoverage_0x03b7aa14(0x7783bccc5bda273aeb6055a640ee542610524afc24ef178e48761927a543d37a); /* line */ \n        coverage_0x03b7aa14(0xaef11f8dd72b010def5132222d18f6abdb1bdece22e4c1f7cd26a19a0312d16e); /* statement */ \naddress skaleDKGAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SkaleDKG\")));\ncoverage_0x03b7aa14(0x2d06b4ec33de1b8f7ef1a44fb6ef53706ecadfbbbf43b33aa1a06f556b1b3a39); /* line */ \n        coverage_0x03b7aa14(0x7649fa50951af01fee98254f01fea64532921cc47979f8aa7534c0a00a1eed3d); /* statement */ \nISkaleDKG(skaleDKGAddress).openChannel(groupIndex);\n    }\n\n    /**\n     * @dev setException - sets a Node like exception\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     * @param nodeIndex - index of Node which would be notes like exception\n     */\n    function setException(bytes32 groupIndex, uint nodeIndex) external allow(executorName) {coverage_0x03b7aa14(0x9981fbfe37f349649d8a4e2147cf8fd90fb46679be9e19e6f1e7ace7f8c5c4d1); /* function */ \n\ncoverage_0x03b7aa14(0xe9b65eabf0587b307b2c2af6803732188e1d7bc69137e2c119b1dcebc9dc8959); /* line */ \n        coverage_0x03b7aa14(0xb8520bd7565c3e2903f1e52612b0cb6be53e65dd7418cb5f1445de62b2a99877); /* statement */ \nexceptions[groupIndex].check[nodeIndex] = true;\n    }\n\n    /**\n     * @dev setPublicKey - sets BLS master public key\n     * function could be run only by SkaleDKG\n     * @param groupIndex - Groups identifier\n     * @param publicKeyx1 }\n     * @param publicKeyy1 } parts of BLS master public key\n     * @param publicKeyx2 }\n     * @param publicKeyy2 }\n     */\n    function setPublicKey(\n        bytes32 groupIndex,\n        uint publicKeyx1,\n        uint publicKeyy1,\n        uint publicKeyx2,\n        uint publicKeyy2) external allow(\"SkaleDKG\")\n    {coverage_0x03b7aa14(0x8564b9b5593a57468026cbd9b39a64ea1cbb48ebd8a30cd741830fd210eb06aa); /* function */ \n\ncoverage_0x03b7aa14(0xd90d565b0cc57ae0b1a622932406524778bee021710ed698e5f5c054f6776b3a); /* line */ \n        coverage_0x03b7aa14(0xfc2f1593b78de6dc49a821375d689456b729ccc1cc3e5001cb9dd775d409bde4); /* statement */ \ngroups[groupIndex].groupsPublicKey[0] = publicKeyx1;\ncoverage_0x03b7aa14(0xca16a43ac47859750c9be5dfa59af0d2e3d92f72465044b2e5e21dc4144888fb); /* line */ \n        coverage_0x03b7aa14(0x99a400ca1eaaf26423ea8975d03aa1672836eae4a1b6d521179c962e99180097); /* statement */ \ngroups[groupIndex].groupsPublicKey[1] = publicKeyy1;\ncoverage_0x03b7aa14(0x20417a15244e45e77679f556f687de20bc822ba2c04b51de1980fb7ce9809301); /* line */ \n        coverage_0x03b7aa14(0xa84a899a638b036b3aa8c297c9037e137cd384ce5ece03829624667207544fed); /* statement */ \ngroups[groupIndex].groupsPublicKey[2] = publicKeyx2;\ncoverage_0x03b7aa14(0xbc75cd036bc5e207a78eef6f0d43effdf489976b9b41378ce16a45bdf8424636); /* line */ \n        coverage_0x03b7aa14(0xc4bcf393bcd898fc03bb50a3f0e23aa2f512063f8c1cd1fcf5976df516e421ce); /* statement */ \ngroups[groupIndex].groupsPublicKey[3] = publicKeyy2;\n    }\n\n    /**\n     * @dev setNodeInGroup - adds Node to Group\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     * @param nodeIndex - index of Node which would be added to the Group\n     */\n    function setNodeInGroup(bytes32 groupIndex, uint nodeIndex) external allow(executorName) {coverage_0x03b7aa14(0xd1353f187ee90724b5b88690736638c58bd44a8bee899baa150b86a268c18a42); /* function */ \n\ncoverage_0x03b7aa14(0x0353b4ca086b76010c64e0d967864c489d3005ced6a53c4dae3ce93b824920db); /* line */ \n        coverage_0x03b7aa14(0xe63968a83279d0aadb71d8f0f91f771f97babc1ddf603505775e7722cac8910d); /* statement */ \ngroups[groupIndex].nodesInGroup.push(nodeIndex);\n    }\n\n    /**\n     * @dev removeNodeFromGroup - removes Node out of the Group\n     * function could be run only by executor\n     * @param indexOfNode - Nodes identifier\n     * @param groupIndex - Groups identifier\n     */\n    function removeNodeFromGroup(uint indexOfNode, bytes32 groupIndex) external allow(executorName) {coverage_0x03b7aa14(0xa4a4ce6f2864d1f6a52e1e0de142e8eb34b87ee8e5d24400471cf7323d2ea644); /* function */ \n\ncoverage_0x03b7aa14(0x56daf687213bf6304efdc1e3f771c38ae1f6da6e0eca1345f4c25290ebcc04da); /* line */ \n        coverage_0x03b7aa14(0xfed5ca7f48136a3f6515ada3501c08ba640854b4f27f17f2c942c3ae1ea225e6); /* statement */ \nuint size = groups[groupIndex].nodesInGroup.length;\ncoverage_0x03b7aa14(0xc4189511a8b3e126c86178c64871e8179a9b62febb50fbcdaa2a074e9ff53765); /* line */ \n        coverage_0x03b7aa14(0x014faf60c18673a446cedf6aab1a6724a64761dd4797fb62e0c844fa08bd803f); /* statement */ \nif (indexOfNode < size) {coverage_0x03b7aa14(0xe820a9addc8c0f86852b70a67329760c4fce8292e1de26a186c8bc114cb29949); /* branch */ \n\ncoverage_0x03b7aa14(0xcdd18d585c861e87443a638d44240f43a783685ef3419210500a434f48a507ac); /* line */ \n            coverage_0x03b7aa14(0xd52de35dee5cffedca4a314aed128d2fb56181ee4b8c1a33d167cc5fba537d9b); /* statement */ \ngroups[groupIndex].nodesInGroup[indexOfNode] = groups[groupIndex].nodesInGroup[size - 1];\n        }else { coverage_0x03b7aa14(0xbb4a916a1c5be748d242b67f8255de2e3aa2fa885395afd3e9ca578ac30bb259); /* branch */ \n}\ncoverage_0x03b7aa14(0xbf24290ecf1b610c10131221b6f7cab2618d143eba5bf4d57c461d8e606e7a6b); /* line */ \n        delete groups[groupIndex].nodesInGroup[size - 1];\ncoverage_0x03b7aa14(0x7374b84daeda13670d5914939bade8bfda6477cf9490f0f70fe64e05271a60b9); /* line */ \n        groups[groupIndex].nodesInGroup.length--;\n    }\n\n    /**\n     * @dev removeAllNodesInGroup - removes all added Nodes out the Group\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     */\n    function removeAllNodesInGroup(bytes32 groupIndex) external allow(executorName) {coverage_0x03b7aa14(0x02bad545719ee4e55666f749f97193c7b968cbe5384c902d681223e0804250f1); /* function */ \n\ncoverage_0x03b7aa14(0xc50a6e757b6e99d56b2e3205bb40e0c6d25a7713f7f6cb0b9194107f058786a4); /* line */ \n        delete groups[groupIndex].nodesInGroup;\ncoverage_0x03b7aa14(0x1a155fc6dab2b9f530d539423faa2a5b275349455082997ea361ccd6b5c2574a); /* line */ \n        coverage_0x03b7aa14(0x0e2dbe143adf57a861fc457c178459e8233d059dbc8f9f97e663f45111549960); /* statement */ \ngroups[groupIndex].nodesInGroup.length = 0;\n    }\n\n    /**\n     * @dev setNodesInGroup - adds Nodes to Group\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     * @param nodesInGroup - array of indexes of Nodes which would be added to the Group\n    */\n    function setNodesInGroup(bytes32 groupIndex, uint[] calldata nodesInGroup) external allow(executorName) {coverage_0x03b7aa14(0x9525d8f4afca864b2d0f77ab1d6044866a125604d778e266abb92cc2a258eb2b); /* function */ \n\ncoverage_0x03b7aa14(0x322167c6962aa2f07b897cb3c4943bfce7b549221079b8b1a61e4048384d61d0); /* line */ \n        coverage_0x03b7aa14(0x7b74a3adba523ec375a20d531f8757f8827a18d069e956875fcd0e39597138de); /* statement */ \ngroups[groupIndex].nodesInGroup = nodesInGroup;\n    }\n\n    // /**\n    //  * @dev setNewAmountOfNodes - set new recommended number of Nodes\n    //  * function could be run only by executor\n    //  * @param groupIndex - Groups identifier\n    //  * @param amountOfNodes - recommended number of Nodes in this Group\n    // */\n    // function setNewAmountOfNodes(bytes32 groupIndex, uint amountOfNodes) external allow(executorName) {\n    //     groups[groupIndex].recommendedNumberOfNodes = amountOfNodes;\n    // }\n\n    // /**\n    //  * @dev setNewGroupData - set new extra data\n    //  * function could be run only be executor\n    //  * @param groupIndex - Groups identifier\n    //  * @param data - new extra data\n    //  */\n    // function setNewGroupData(bytes32 groupIndex, bytes32 data) external allow(executorName) {\n    //     groups[groupIndex].groupData = data;\n    // }\n\n    function setGroupFailedDKG(bytes32 groupIndex) external allow(\"SkaleDKG\") {coverage_0x03b7aa14(0x15d659ebc10af40ad9a9a1229b80551d707fe22b6b40a6f48b0e9e8fc21c6d3e); /* function */ \n\ncoverage_0x03b7aa14(0xe3a80f8fea8790b0215e988e91249cd75f6960ff05550cc46aaed56cc13ed731); /* line */ \n        coverage_0x03b7aa14(0xbaededc5f4003528568eafd690ee0e8c1c0fb1225b67ed3109a97fd83c3c95b9); /* statement */ \ngroups[groupIndex].succesfulDKG = false;\n    }\n\n    /**\n     * @dev removeGroup - remove Group from storage\n     * function could be run only be executor\n     * @param groupIndex - Groups identifier\n     */\n    function removeGroup(bytes32 groupIndex) external allow(executorName) {coverage_0x03b7aa14(0x95f58c6f2f87e5388170d66bb3eea6c555741e54a65621b38102028f93f1f628); /* function */ \n\ncoverage_0x03b7aa14(0x2b27f92cf1175735f79f8331ed133133fcd5661210ad2091c05a8d86257bf56c); /* line */ \n        coverage_0x03b7aa14(0xc6128f74e3fc2a8b0265acb69032518e38e0acb8838176d14f9fee6636008113); /* statement */ \ngroups[groupIndex].active = false;\ncoverage_0x03b7aa14(0xf457ed7da3827e59e5e66be8bf5723c23caed890c82ae2d79d0f3011b280605c); /* line */ \n        delete groups[groupIndex].groupData;\ncoverage_0x03b7aa14(0xc4f1e3e32c98b1062780f843b2f9f274d6453a646d92ceaa6cbaa0a29340be4c); /* line */ \n        delete groups[groupIndex].recommendedNumberOfNodes;\ncoverage_0x03b7aa14(0x374c52cb4c6ecc11c760d8af2eb9321aa076c1c9ef0fd04056b62c5e872e6116); /* line */ \n        delete groups[groupIndex].groupsPublicKey;\ncoverage_0x03b7aa14(0x8a9eaee26a6b8c1a26971cb125ba552df4f6f3507899d808cad57bb4391c29d5); /* line */ \n        delete groups[groupIndex];\n        // delete channel\ncoverage_0x03b7aa14(0xbe73d05eea8f45b786687db6e776064f8023d9cf052dc4d979538f726638e9c5); /* line */ \n        coverage_0x03b7aa14(0x0a30b0185d3b123b371793f253a04812a141b81853a97be46b938ce2e3111ac1); /* statement */ \naddress skaleDKGAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SkaleDKG\")));\n\ncoverage_0x03b7aa14(0x86c9dca2e1e373584b390c8b42a2f4082a2a52e038efb895105a3e0d4b8f03b6); /* line */ \n        coverage_0x03b7aa14(0x13f667c4150469407979bcf0bb61cdee42f6d9d3a0b88ad209d763e203b222bf); /* statement */ \nif (ISkaleDKG(skaleDKGAddress).isChannelOpened(groupIndex)) {coverage_0x03b7aa14(0xaf9a3c3955388ff6ead6a9b516132fffd34b91177d58f24f8ad4412988a9a9c5); /* branch */ \n\ncoverage_0x03b7aa14(0xd2dec363f1912eb392fff96c2255b2e8f1c0fffab4edccebb7b65e1b09a47731); /* line */ \n            coverage_0x03b7aa14(0x5f63ef3a2182c8236080cfccee3b265f430cd5038128c231f98e69da8c9ab264); /* statement */ \nISkaleDKG(skaleDKGAddress).deleteChannel(groupIndex);\n        }else { coverage_0x03b7aa14(0xfe6930ff74c60941c117262366100112806976ffb9e7d02823a824ba408d58a3); /* branch */ \n}\n    }\n\n    /**\n     * @dev removeExceptionNode - remove exception Node from Group\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     */\n    function removeExceptionNode(bytes32 groupIndex, uint nodeIndex) external allow(executorName) {coverage_0x03b7aa14(0xcbdc267b2994aebd676afa052cea971b43adabc9480b09317bc82b114f77f659); /* function */ \n\ncoverage_0x03b7aa14(0x3773ee6c9970a7f3d9b6a5edf613e5370266b901c792d1994bdd800a8abc475d); /* line */ \n        coverage_0x03b7aa14(0x3d80e6def7cb49767bed209cabda347294d4ba81d95a1d95b07e65d71f3a6040); /* statement */ \nexceptions[groupIndex].check[nodeIndex] = false;\n    }\n\n    /**\n     * @dev isGroupActive - checks is Group active\n     * @param groupIndex - Groups identifier\n     * @return true - active, false - not active\n     */\n    function isGroupActive(bytes32 groupIndex) external view returns (bool) {coverage_0x03b7aa14(0x92b862d0a42662f88282181b7c11634913cd4a16fe42a011c4183ff8a3030f51); /* function */ \n\ncoverage_0x03b7aa14(0xb63921dc40a8c8111f60068e5d4867b5f00ed0d28d67ffe662d2b30b1210e0ce); /* line */ \n        coverage_0x03b7aa14(0xef6c1d2be5116b4e3f351e02934e2a26bd568c43bdb53379960eefc7585e39f1); /* statement */ \nreturn groups[groupIndex].active;\n    }\n\n    /**\n     * @dev isExceptionNode - checks is Node - exception at given Group\n     * @param groupIndex - Groups identifier\n     * @param nodeIndex - index of Node\n     * return true - exception, false - not exception\n     */\n    function isExceptionNode(bytes32 groupIndex, uint nodeIndex) external view returns (bool) {coverage_0x03b7aa14(0x9204e0deff839d7c2df5865ea42352c47677e5a8f3a2aa70d5406b79c09aa00e); /* function */ \n\ncoverage_0x03b7aa14(0x5edc04b4b27f12dcb5e8c957887e9ff0f12aae865410220e8c765032de55348d); /* line */ \n        coverage_0x03b7aa14(0x36a44e90123d561f723811a00a27c94d1fdb54173fb344498d5095e5f0f8e945); /* statement */ \nreturn exceptions[groupIndex].check[nodeIndex];\n    }\n\n    /**\n     * @dev getGroupsPublicKey - shows Groups public key\n     * @param groupIndex - Groups identifier\n     * @return publicKey(x1, y1, x2, y2) - parts of BLS master public key\n     */\n    function getGroupsPublicKey(bytes32 groupIndex) external view returns (uint, uint, uint, uint) {coverage_0x03b7aa14(0x0e4034e5c0e129cbdbe83957ca2fbd27905968b15b6d50a3d7d331293937c1bd); /* function */ \n\ncoverage_0x03b7aa14(0x75607e87aea9ff10b5e9ce3239122dbb4e2bc7d1305192240b47ceade22513dc); /* line */ \n        coverage_0x03b7aa14(0x836e618d4e20fd828231f0889e0f3613d8eff52109d01e0e33156d7fb926e1c9); /* statement */ \nreturn (\n            groups[groupIndex].groupsPublicKey[0],\n            groups[groupIndex].groupsPublicKey[1],\n            groups[groupIndex].groupsPublicKey[2],\n            groups[groupIndex].groupsPublicKey[3]\n        );\n    }\n\n    function isGroupFailedDKG(bytes32 groupIndex) external view returns (bool) {coverage_0x03b7aa14(0xc34dfeb1f0e2e797b1c2b8de93b36c4bf91b5fe87c591c8c1132da96c19e27d0); /* function */ \n\ncoverage_0x03b7aa14(0x558f25cfca9a36f229988556e2f65effc21f048f13f048eadb238e81ac59e962); /* line */ \n        coverage_0x03b7aa14(0x54918176a552e4cffa7fc673a278117ae76377e6595cb857d5fea2adcc649055); /* statement */ \nreturn !groups[groupIndex].succesfulDKG;\n    }\n\n    /**\n     * @dev getNodesInGroup - shows Nodes in Group\n     * @param groupIndex - Groups identifier\n     * @return array of indexes of Nodes in Group\n     */\n    function getNodesInGroup(bytes32 groupIndex) external view returns (uint[] memory) {coverage_0x03b7aa14(0x35cf4b936ed8aeb599bebf83a90f5a1945d5b7ca910ca20368e06948a3f405f0); /* function */ \n\ncoverage_0x03b7aa14(0x5899d708c870cc17c32094f34b410b76e8379fbc49f88d9fc16938aea4cf6901); /* line */ \n        coverage_0x03b7aa14(0xe35fd0366389eaba42314a7058e51488565e9161477214893002a1bfa7c83311); /* statement */ \nreturn groups[groupIndex].nodesInGroup;\n    }\n\n    /**\n     * @dev getGroupsData - shows Groups extra data\n     * @param groupIndex - Groups identifier\n     * @return Groups extra data\n     */\n    function getGroupData(bytes32 groupIndex) external view returns (bytes32) {coverage_0x03b7aa14(0x8a652de1100ed433618ab8281840af87b203a2aaa27d7745e3b219beebf2dfb1); /* function */ \n\ncoverage_0x03b7aa14(0xb4021c2f957da0eaa19c7f316ce7cf0eb4fa4b1d3a5812ba5c5d144e951287b0); /* line */ \n        coverage_0x03b7aa14(0x452247bf9e0ef3ea22dbe0c1f0516640fc9c253e76248412dd746ee68043983b); /* statement */ \nreturn groups[groupIndex].groupData;\n    }\n\n    /**\n     * @dev getRecommendedNumberOfNodes - shows recommended number of Nodes\n     * @param groupIndex - Groups identifier\n     * @return recommended number of Nodes\n     */\n    function getRecommendedNumberOfNodes(bytes32 groupIndex) external view returns (uint) {coverage_0x03b7aa14(0x357fb6f89bf7a47380613a0d35c433e411b260f7e92531b9b07299ef4efabfa6); /* function */ \n\ncoverage_0x03b7aa14(0xd50ac2008551ab396c831450a198484cf46c662440d527a0931593092e9692bd); /* line */ \n        coverage_0x03b7aa14(0xe6ded83062c5528be383c86f9736a394e3707327afcde01aa7423c183ccfc9cf); /* statement */ \nreturn groups[groupIndex].recommendedNumberOfNodes;\n    }\n\n    /**\n     * @dev getNumberOfNodesInGroup - shows number of Nodes in Group\n     * @param groupIndex - Groups identifier\n     * @return number of Nodes in Group\n     */\n    function getNumberOfNodesInGroup(bytes32 groupIndex) external view returns (uint) {coverage_0x03b7aa14(0x228e5f61f2683dd05f2c81ec6a304a6002c84250b42a41e964f6f9d8e21c9790); /* function */ \n\ncoverage_0x03b7aa14(0x52bc9f0381f787806bfb06c15fa69709aae3a693da33250278f920fcde4234c8); /* line */ \n        coverage_0x03b7aa14(0x5e6cefead2b6301c50ce28af35c1f4a33868cac42eadffb4ba2fc605dad57b80); /* statement */ \nreturn groups[groupIndex].nodesInGroup.length;\n    }\n}\n"
    },
    ".coverage_contracts/interfaces/IGroupsData.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title GroupsData - interface of GroupsData\n */\ninterface IGroupsData {\n    function addGroup(bytes32 groupIndex, uint amountOfNodes, bytes32 data) external;\n    function removeAllNodesInGroup(bytes32 groupIndex) external;\n    // function setNewAmountOfNodes(bytes32 groupIndex, uint amountOfNodes) external;\n    // function setNewGroupData(bytes32 groupIndex, bytes32 data) external;\n    function setNodeInGroup(bytes32 groupIndex, uint nodeIndex) external;\n    function setNodesInGroup(bytes32 groupIndex, uint[] calldata nodesInGroup) external;\n    function removeExceptionNode(bytes32 groupIndex, uint nodeIndex) external;\n    function removeGroup(bytes32 groupIndex) external;\n    function setException(bytes32 groupIndex, uint nodeIndex) external;\n    function isGroupActive(bytes32 groupIndex) external view returns (bool);\n    function isExceptionNode(bytes32 groupIndex, uint nodeIndex) external view returns (bool);\n    function getGroupsPublicKey(bytes32 groupIndex) external view returns (uint, uint, uint, uint);\n    function getNodesInGroup(bytes32 schainId) external view returns (uint[] memory);\n    function getGroupData(bytes32 groupIndex) external view returns (bytes32);\n    function getRecommendedNumberOfNodes(bytes32 groupIndex) external view returns (uint);\n    function getNumberOfNodesInGroup(bytes32 groupIndex) external view returns (uint);\n    function isGroupFailedDKG(bytes32 groupIndex) external view returns (bool);\n    function removeNodeFromGroup(uint nodeIndex, bytes32 groupIndex) external;\n    function setPublicKey(\n        bytes32 groupIndex,\n        uint pubKeyx1,\n        uint pubKeyy1,\n        uint pubKeyx2,\n        uint pubKeyy2) external;\n    function setGroupFailedDKG(bytes32 groupIndex) external;\n}"
    },
    ".coverage_contracts/GroupsFunctionality.sol": {
      "content": "/*\n    GroupsFunctionality.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IGroupsData.sol\";\n\n\n/**\n * @title SkaleVerifier - interface of SkaleVerifier\n */\ninterface ISkaleVerifier {\n    function verify(\n        uint sigx,\n        uint sigy,\n        uint hashx,\n        uint hashy,\n        uint pkx1,\n        uint pky1,\n        uint pkx2,\n        uint pky2) external view returns (bool);\n}\n\n\n/**\n * @title GroupsFunctionality - contract with some Groups functionality, will be inherited by\n * ValidatorsFunctionality and SchainsFunctionality\n */\ncontract GroupsFunctionality is Permissions {\nfunction coverage_0xeca4dd85(bytes32 c__0xeca4dd85) public pure {}\n\n\n    // informs that Group is added\n    event GroupAdded(\n        bytes32 groupIndex,\n        bytes32 groupData,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // informs that an exception set in Group\n    event ExceptionSet(\n        bytes32 groupIndex,\n        uint exceptionNodeIndex,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // informs that Group is deleted\n    event GroupDeleted(\n        bytes32 groupIndex,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // informs that Group is upgraded\n    event GroupUpgraded(\n        bytes32 groupIndex,\n        bytes32 groupData,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // informs that Group is generated\n    event GroupGenerated(\n        bytes32 groupIndex,\n        uint[] nodesInGroup,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // name of executor contract\n    string executorName;\n    // name of data contract\n    string dataName;\n\n    /**\n     * @dev contructor in Permissions approach\n     * @param newExecutorName - name of executor contract\n     * @param newDataName - name of data contract\n     * @param newContractsAddress needed in Permissions constructor\n     */\n    constructor(string memory newExecutorName, string memory newDataName, address newContractsAddress) Permissions(newContractsAddress) public {coverage_0xeca4dd85(0x3fbdceed071c1805d5f040d451bc007617ce1dde0dfcd92e5143490d1ea2bd0e); /* function */ \n\ncoverage_0xeca4dd85(0x82550ca9f106cc84e18675dbf1c725c23607817edbec11979cfee1f0c296febf); /* line */ \n        coverage_0xeca4dd85(0xf95c4c3d032e43dfb25da7f8e762e447bbb288baa6d802ee2751541d7266421f); /* statement */ \nexecutorName = newExecutorName;\ncoverage_0xeca4dd85(0x2209970d70343712ddc29e8b0ab2e6e489fe85ae395a2b43e86f671f390a76db); /* line */ \n        coverage_0xeca4dd85(0xb905160e19bc1d4c313320373b9b80022abce13ec21b1f912a1f125f71139d4e); /* statement */ \ndataName = newDataName;\n    }\n\n    /**\n     * @dev verifySignature - verify signature which create Group by Groups BLS master public key\n     * @param groupIndex - Groups identifier\n     * @param signatureX - first part of BLS signature\n     * @param signatureY - second part of BLS signature\n     * @param hashX - first part of hashed message\n     * @param hashY - second part of hashed message\n     * @return true - if correct, false - if not\n     */\n    function verifySignature(\n        bytes32 groupIndex,\n        uint signatureX,\n        uint signatureY,\n        uint hashX,\n        uint hashY) external view returns (bool)\n    {coverage_0xeca4dd85(0xb8d4b9064d1009254ac2039d603d3a5aab48a31a348ad2066a1bf9beb7fdfb71); /* function */ \n\ncoverage_0xeca4dd85(0xa6551bee737d9d383b0038918fbce4f251cb1a17de00199d9c5961992b0e966c); /* line */ \n        coverage_0xeca4dd85(0xa01ad92a9215e95655523401977c759c25049c07966cc383e0e2aa54fbb300ac); /* statement */ \naddress groupsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xeca4dd85(0x780ef444feda02b3fd1e5f105db855cb3ebb3e0adb2ae9484f751be212e053aa); /* line */ \n        coverage_0xeca4dd85(0xb8a23f83dbfa9e477ebbef5d0260d300ca4eff2867603fd7d3d655248d95bc8f); /* statement */ \nuint publicKeyx1;\ncoverage_0xeca4dd85(0xa2a43b0ad75e560d7eb7b0836600bafa975708d791d083f1bb020771dfe3abc0); /* line */ \n        coverage_0xeca4dd85(0xb147e22dfbacdf29a3287a190a2be15b251ada1f9353d5023f3a1fd58d0fb78d); /* statement */ \nuint publicKeyy1;\ncoverage_0xeca4dd85(0x0a32b8e4a6c5e06563994e06e2dd686faf2fbcebdca93703fb8e2e472bd1eada); /* line */ \n        coverage_0xeca4dd85(0x7246b1327a78a6b89db4353cee2b74f2e24225d266988ab29678c293ec9c51c6); /* statement */ \nuint publicKeyx2;\ncoverage_0xeca4dd85(0xa21203ebf6a49cf63569a6bdff8ec43b87b0afbbe25b041c8f2d791446a9124e); /* line */ \n        coverage_0xeca4dd85(0xfd6ae977b5dcf739f6e87ad679852e7fbc723093ddb2d9feab7690e97abc0756); /* statement */ \nuint publicKeyy2;\ncoverage_0xeca4dd85(0xe78375a5013746c672bc2a5a5ba20ffecd0f74ab80a0e8f80ee641cc2798e0c5); /* line */ \n        coverage_0xeca4dd85(0x7a4115789af83f5554d02cddf3ffbb8bb133e3425b35454714b01e23ddad34c1); /* statement */ \n(publicKeyx1, publicKeyy1, publicKeyx2, publicKeyy2) = IGroupsData(groupsDataAddress).getGroupsPublicKey(groupIndex);\ncoverage_0xeca4dd85(0x81e03eb154ef61be5084a5957fa700257e9f88d40662986c620f481ab6a4f13e); /* line */ \n        coverage_0xeca4dd85(0x86011467728f6db53536c404c3113867892d14c079e66e7f1b5752723ee46915); /* statement */ \naddress skaleVerifierAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SkaleVerifier\")));\ncoverage_0xeca4dd85(0x5ea7dc48c6eae63f445b10c608a2d25e1e88a190da6be07c63d9a1aa49a6cb71); /* line */ \n        coverage_0xeca4dd85(0xf3b7c031a86f1d330efc8689c1a9fe618ca3c184a622d85324649835105c1ce8); /* statement */ \nreturn ISkaleVerifier(skaleVerifierAddress).verify(\n            signatureX, signatureY, hashX, hashY, publicKeyx1, publicKeyy1, publicKeyx2, publicKeyy2\n        );\n    }\n\n    /**\n     * @dev addGroup - creates and adds new Group to Data contract\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     * @param newRecommendedNumberOfNodes - recommended number of Nodes\n     * @param data - some extra data\n     */\n    function addGroup(bytes32 groupIndex, uint newRecommendedNumberOfNodes, bytes32 data) public allow(executorName) {coverage_0xeca4dd85(0xc3852aac363655e024a5940663b43bae64d7b0e374aef848772225de36f1923f); /* function */ \n\ncoverage_0xeca4dd85(0x00843b623d46e6540d0503db63e0069038d6b678f94d800d51b6609e3931e6b1); /* line */ \n        coverage_0xeca4dd85(0x7dbd48bc05bdc20d79d824a021bc39d6b51ec36e1baf0c5bb30129fd12cce9d7); /* statement */ \naddress groupsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xeca4dd85(0x769acb31c10540ab5b1bf256c6170cf1a63c415a872a908bd5443522d9cebc74); /* line */ \n        coverage_0xeca4dd85(0x70b9ad3031091883fb600518182667e48cafe21ff6f4e43a7a33888f4bb151c3); /* statement */ \nIGroupsData(groupsDataAddress).addGroup(groupIndex, newRecommendedNumberOfNodes, data);\ncoverage_0xeca4dd85(0xbec579a5f06ba86e11fbb32181e5bde510326b207833446bee4bce05387c1445); /* line */ \n        coverage_0xeca4dd85(0x1b32bdc07d916901610f808ed5786fd4f3dadec182a83405d9d11961ddb1a09c); /* statement */ \nemit GroupAdded(\n            groupIndex,\n            data,\n            uint32(block.timestamp),\n            gasleft());\n    }\n\n    /**\n     * @dev deleteGroup - delete Group from Data contract\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     */\n    function deleteGroup(bytes32 groupIndex) public allow(executorName) {coverage_0xeca4dd85(0x7cde8a9d30c8927bdd866a58db05b3df4ba2e241bd3e7547629c1b6bf3050e17); /* function */ \n\ncoverage_0xeca4dd85(0x188f72f2e678b4dddee35bed82bf50cd150915972b23c07375bf5b793a5ac2af); /* line */ \n        coverage_0xeca4dd85(0x05e9f2a201ce3eabbb62910b2474a2c7833ae3f1b38d1a214f6483bb1b87912b); /* statement */ \naddress groupsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xeca4dd85(0x7e07ce3ed4bdc1e7f96906d07463ca0d97678097a0d7346532a13cd4026d6ff7); /* line */ \n        coverage_0xeca4dd85(0x45780866b53fb87530e676bee0f8361a65e3eaea9be52b7cc830989f319c429b); /* assertPre */ \ncoverage_0xeca4dd85(0x1019af7bd5d49c397486fec37a4a093b562629c39618c4d8a2d530d3c678abaf); /* statement */ \nrequire(IGroupsData(groupsDataAddress).isGroupActive(groupIndex), \"Group is not active\");coverage_0xeca4dd85(0x996c41165ef3c912aae2360a3acdc9ace141c7918a61a60ca68792ca0fc7f7cf); /* assertPost */ \n\ncoverage_0xeca4dd85(0x1ca451b6c5977397a6e7d6d02baeaeeaab84adc965edaf05aa2ac56bae79d7f3); /* line */ \n        coverage_0xeca4dd85(0x56f36449f14c5b11079e7645ce98a3bdafee7495364fe939d3283b7315463849); /* statement */ \nIGroupsData(groupsDataAddress).removeGroup(groupIndex);\ncoverage_0xeca4dd85(0x11107657a5b3fa85769d8295cd5eea8e2913c49538ab306787e9ed571b5d0624); /* line */ \n        coverage_0xeca4dd85(0x3587c590bcf64bafc42dab1c6cfd2214f4e4b42512d9a6d8ed45f6049d19462d); /* statement */ \nIGroupsData(groupsDataAddress).removeAllNodesInGroup(groupIndex);\ncoverage_0xeca4dd85(0x852c8d0c516c0054c3c5cf3489efd222c63e9723576bf3d0e9d277c4c4792ff0); /* line */ \n        coverage_0xeca4dd85(0x5263c19c75488607fbd251792d71c074b617a66b89e40edee7c95144e7eb895a); /* statement */ \nemit GroupDeleted(groupIndex, uint32(block.timestamp), gasleft());\n    }\n\n    /**\n     * @dev upgradeGroup - upgrade Group at Data contract\n     * function could be run only by executor\n     * @param groupIndex - Groups identifier\n     * @param newRecommendedNumberOfNodes - recommended number of Nodes\n     * @param data - some extra data\n     */\n    function upgradeGroup(bytes32 groupIndex, uint newRecommendedNumberOfNodes, bytes32 data) public allow(executorName) {coverage_0xeca4dd85(0x978c49b6613ac6f946f84e6540f0a65268f25c2ecc244ee1ea861ccd3ab6d6e8); /* function */ \n\ncoverage_0xeca4dd85(0x2f7d3b6e0fa35febf63987c7861fea8d3fc09dc2aad784b94db6ddaa78bd6498); /* line */ \n        coverage_0xeca4dd85(0x210c3a75422d753e87a1926d9b15d27c8f080e1fcc4cce1ed04b58213fba4751); /* statement */ \naddress groupsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xeca4dd85(0x56348e08aa9cee1a6c758efab8c66f1a1e752566b219e3e417f31f14575bd823); /* line */ \n        coverage_0xeca4dd85(0x283899007c8d3319e315c2c627dd229a38016e30f515eec04092c26f190b52d5); /* assertPre */ \ncoverage_0xeca4dd85(0x7cdb22a4a22a9ef2eacb132c2b1fd6ae987879644a0043b63dcab238b33b2265); /* statement */ \nrequire(IGroupsData(groupsDataAddress).isGroupActive(groupIndex), \"Group is not active\");coverage_0xeca4dd85(0x67653223de5da2501fd67fa39606f4e8a01c43f98f04d2d51421436461d62bbb); /* assertPost */ \n\ncoverage_0xeca4dd85(0xecdcd9bdb980be32dd0399d62bbb063d9ca05bcd0b54c1d3a36f51b8e3f92316); /* line */ \n        coverage_0xeca4dd85(0xda3c7cb5c06390baac036af374d52d138a94b6db9563fcc4bab134cb3b1d49b6); /* statement */ \nIGroupsData(groupsDataAddress).removeGroup(groupIndex);\ncoverage_0xeca4dd85(0xe4e1e840946a4bc9b8f5d48446def84221a0f170ed35d8f70bf1ddf4e6022992); /* line */ \n        coverage_0xeca4dd85(0xc4bdea23076a4d4f861553d088beca5ec163588eab23b207077ce2f3cb1d835c); /* statement */ \nIGroupsData(groupsDataAddress).removeAllNodesInGroup(groupIndex);\ncoverage_0xeca4dd85(0x72034428d4498582826d050e03649e2bdaaa8bc4df257e1ed8c620c2560740c4); /* line */ \n        coverage_0xeca4dd85(0xf2ffbb3b117125332e19ddab44e3d8d5e93783c90ce2a3845e0a508c4bfe3db0); /* statement */ \nIGroupsData(groupsDataAddress).addGroup(groupIndex, newRecommendedNumberOfNodes, data);\ncoverage_0xeca4dd85(0xde69a7c9232eff88069a535409fa2a6784c15daf8183925197fbf2d3ca4b73c1); /* line */ \n        coverage_0xeca4dd85(0xf046c4e9b2db06d9511b567a6b05e1be7583e23ce863d5fc675af4fe2dd28c0a); /* statement */ \nemit GroupUpgraded(\n            groupIndex,\n            data,\n            uint32(block.timestamp),\n            gasleft());\n    }\n\n    /**\n     * @dev findNode - find local index of Node in Schain\n     * @param groupIndex - Groups identifier\n     * @param nodeIndex - global index of Node\n     * @return local index of Node in Schain\n     */\n    function findNode(bytes32 groupIndex, uint nodeIndex) internal view returns (uint index) {coverage_0xeca4dd85(0x8f3cd25f07a3bf47db66fdb3cfc92610a370d1279991914020df656b944bd1db); /* function */ \n\ncoverage_0xeca4dd85(0xc32207824cb163fe870f8cafc1b0ce3a8560d31edc93eefdfd9b2e4bdb3412e8); /* line */ \n        coverage_0xeca4dd85(0x92890fa856f05655090ffb0fccd0c68b7f81126604dca937f663575b8dfdcd8c); /* statement */ \naddress groupsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xeca4dd85(0x02246cccc142ee8603aab0dbbf9080d529f4a748fa7f3e6462a2d30cedcca949); /* line */ \n        coverage_0xeca4dd85(0x516d61abcfb8e06804ebe485012884e95305bd512f33b3a86fcb39c38efa8e97); /* statement */ \nuint[] memory nodesInGroup = IGroupsData(groupsDataAddress).getNodesInGroup(groupIndex);\ncoverage_0xeca4dd85(0xc2cb95336f7f78cf4b35f4a801f0a686840471f832618a5ce8f70c74da9700ce); /* line */ \n        coverage_0xeca4dd85(0x303fa6254a9e6629296c538877c77ebe65a28b4bac3b0fb5aba337cb93f84fad); /* statement */ \nfor (index = 0; index < nodesInGroup.length; index++) {\ncoverage_0xeca4dd85(0x8ed82badcb790f5648326abfd466d0a2167ece3ade6467b28026a17d05e4a4ea); /* line */ \n            coverage_0xeca4dd85(0xfff37ac7506cc90a0dd7b5fea05881f6b0fe7cc1ccc2e78cb45049e40a9869dd); /* statement */ \nif (nodesInGroup[index] == nodeIndex) {coverage_0xeca4dd85(0xebfbb427d03f63dfd64c7d106d56492307a76463cabc68f2a575be02349a309f); /* branch */ \n\ncoverage_0xeca4dd85(0xb8eb544989184e637892d3eaa9cc93e95ad05b1dfcef9a40f0616dbea5da8f14); /* line */ \n                coverage_0xeca4dd85(0x900ae1df1dcbd425b9a97d1a22853be9ec51105d163fac8c92eb309623cb862e); /* statement */ \nreturn index;\n            }else { coverage_0xeca4dd85(0x7be70ae76275769bf444055607290ed00092426abd7c6124d5ce11aa983dbd27); /* branch */ \n}\n        }\ncoverage_0xeca4dd85(0xf6e2f43facc477046bf9b3c14dbf3f9a4aeb6a4f79022268115cd5500489b1ac); /* line */ \n        coverage_0xeca4dd85(0x37da52e846694550a83519d719306a0d14116df4532b3310e1d1bca9f9db728c); /* statement */ \nreturn index;\n    }\n\n    /**\n     * @dev generateGroup - abstract method which would be implemented in inherited contracts\n     * function generates group of Nodes\n     * @param groupIndex - Groups identifier\n     * return array of indexes of Nodes in Group\n     */\n    function generateGroup(bytes32 groupIndex) internal returns (uint[] memory);\n\n    function swap(uint[] memory array, uint index1, uint index2) internal pure {coverage_0xeca4dd85(0xdadb33c79cf01049555fcecc46777d70818c8f7fae7a087df820b9ca2c311670); /* function */ \n\ncoverage_0xeca4dd85(0xeddbd0357efcd316694b8e95e884a0d8c085e54b8b713da1e2949e0fda8a24ba); /* line */ \n        coverage_0xeca4dd85(0x4efc99a127df8470402f943ad91a1e6d821adff4272edf1b092951350fe35569); /* statement */ \nuint buffer = array[index1];\ncoverage_0xeca4dd85(0xa93c0a7f07a6284e85321be4d6e29614156a1e2646a5d146728bb8bdae3bf76e); /* line */ \n        coverage_0xeca4dd85(0x5560303db82c2fb1c7084e8a89fa6a39d5ae67065162a32dc295c078de63bf5b); /* statement */ \narray[index1] = array[index2];\ncoverage_0xeca4dd85(0x5793b289adf2673dc564ba929b66789d6b8c71dddb25039f2648bfe90a63489f); /* line */ \n        coverage_0xeca4dd85(0x2bbba25e5673f2fa3b6baef5ac250a137c938c083f6692df355fa00f36cf5674); /* statement */ \narray[index2] = buffer;\n    }\n}\n"
    },
    ".coverage_contracts/interfaces/IManagerData.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface IManagerData {\n    function setMinersCap(uint newMinersCap) external;\n    function setStageTimeAndStageNodes(uint newStageNodes) external;\n    function minersCap() external view returns (uint);\n    function startTime() external view returns (uint32);\n    function stageTime() external view returns (uint32);\n    function stageNodes() external view returns (uint);\n}"
    },
    ".coverage_contracts/interfaces/INodesData.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title NodesData - interface of NodesData contract\n * Contains only needed functions for current contract\n */\ninterface INodesData {\n    function nodesIPCheck(bytes4 ip) external view returns (bool);\n    function nodesNameCheck(bytes32 name) external view returns (bool);\n    // function nodesLink(uint nodeIndex) external view returns (uint, bool);\n    // function getNumberOfFractionalNodes() external view returns (uint);\n    // function getNumberOfFullNodes() external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function addNode(\n        address from,\n        string calldata name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        bytes calldata publicKey)\n    external returns (uint);\n    // function addFractionalNode(uint nodeIndex) external;\n    // function addFullNode(uint nodeIndex) external;\n    function setNodeLeaving(uint nodeIndex) external;\n    function setNodeLeft(uint nodeIndex) external;\n    // function removeFractionalNode(uint subarrayLink) external;\n    // function removeFullNode(uint subarrayLink) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function numberOfLeavingNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint32);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function removeNode(uint nodeIndex) external;\n    // function addSpaceToFractionalNode(uint subarrayLink, uint space) external;\n    // function fullNodes(uint indexOfNode) external view returns (uint, uint);\n    // function fractionalNodes(uint indexOfNode) external view returns (uint, uint);\n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    // function removeSpaceFromFractionalNode(uint subarrayLink, uint space) external returns (bool);\n    // function getNumberOfFreeFullNodes(uint needNodes) external view returns (bool);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    // function enoughNodesWithFreeSpace(uint8 space, uint needNodes) external view returns (bool);\n    function getNumberOfNodes() external view returns (uint);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint32);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes memory);\n    // function getActiveFractionalNodes() external view returns (uint[] memory);\n    // function getActiveFullNodes() external view returns (uint[] memory);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodesWithFreeSpace(uint8 freeSpace) external view returns (uint[] memory);\n}\n"
    },
    ".coverage_contracts/interfaces/INodesFunctionality.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface INodesFunctionality {\n    function createNode(address from, uint value, bytes calldata data) external returns (uint);\n    function initExit(address from, uint nodeIndex) external returns (bool);\n    function completeExit(address from, uint nodeIndex) external returns (bool);\n    function removeNode(address from, uint nodeIndex) external;\n    function removeNodeByRoot(uint nodeIndex) external;\n}"
    },
    ".coverage_contracts/interfaces/ISchainsData.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title SchainsData - interface of SchainsData contract\n * Contains only needed functions for current contract\n */\ninterface ISchainsData {\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function sumOfSchainsResources() external view returns (uint);\n    function addSchainForNode(uint nodeIndex, bytes32 schainId) external;\n    function setSchainPartOfNode(bytes32 schainId, uint8 partOfNode) external;\n    function getLengthOfSchainsForNode(uint nodeIndex) external view returns (uint);\n    function schainsForNodes(uint nodeIndex, uint indexOfSchain) external view returns (bytes32);\n    function getSchainOwner(bytes32 schainId) external view returns (address);\n    function initializeSchain(\n        string calldata name,\n        address from,\n        uint lifetime,\n        uint deposit) external;\n    function setSchainIndex(bytes32 schainId, address from) external;\n    function removeSchain(bytes32 schainId, address from) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function isTimeExpired(bytes32 schainId) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isSchainExist(bytes32 schainId) external view returns (bool);\n    function getSchainsPartOfNode(bytes32 schainId) external view returns (uint8);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n}\n"
    },
    ".coverage_contracts/interfaces/ISchainsFunctionality.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface ISchainsFunctionality {\n    function addSchain(address from, uint value, bytes calldata data) external;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function rotateNode(uint nodeIndex, bytes32 schainId) external returns (uint);\n    function exitFromSchain(uint nodeIndex) external returns (bool);\n}"
    },
    ".coverage_contracts/interfaces/ISchainsFunctionalityInternal.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface ISchainsFunctionalityInternal {\n    function getNodesDataFromTypeOfSchain(uint typeOfSchain) external view returns (uint, uint8);\n    function createGroupForSchain(\n        string calldata schainName,\n        bytes32 schainId,\n        uint numberOfNodes,\n        uint8 partOfNode) external;\n    function findSchainAtSchainsForNode(uint nodeIndex, bytes32 schainId) external view returns (uint);\n    function deleteGroup(bytes32 groupIndex) external;\n    function selectNodeToGroup(bytes32 groupIndex) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 groupHash) external;\n    function removeNodeFromExceptions(bytes32 groupHash, uint nodeIndex) external;\n    function excludeNodeFromSchain(uint nodeIndex, bytes32 groupHash) external;\n    function isEnoughNodes(bytes32 groupIndex) external view returns (uint[] memory);\n}"
    },
    ".coverage_contracts/interfaces/ISkaleToken.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface ISkaleToken {\n    function transfer(address to, uint256 value) external returns (bool success);\n    function mint(\n        address operator,\n        address account,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external returns (bool);\n    function CAP() external view returns (uint);\n}"
    },
    ".coverage_contracts/interfaces/IValidatorsFunctionality.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface IValidatorsFunctionality {\n    function addValidator(uint nodeIndex) external;\n    function upgradeValidator(uint nodeIndex) external;\n    function sendVerdict(\n        uint fromValidatorIndex,\n        uint toNodeIndex,\n        uint32 downtime,\n        uint32 latency) external;\n    function calculateMetrics(uint nodeIndex) external returns (uint32, uint32);\n    function deleteValidatorByRoot(uint nodeIndex) external;\n}"
    },
    ".coverage_contracts/ManagerData.sol": {
      "content": "/*\n    ManagerData.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IManagerData.sol\";\n\n\n/**\n * @title ManagerData - Data contract for SkaleManager\n */\ncontract ManagerData is IManagerData, Permissions {\nfunction coverage_0x08d9a91d(bytes32 c__0x08d9a91d) public pure {}\n\n\n    // miners capitalization\n    uint public minersCap;\n    // start time\n    uint32 public startTime;\n    // time of current stage\n    uint32 public stageTime;\n    // amount of Nodes at current stage\n    uint public stageNodes;\n\n    //name of executor contract\n    string executorName;\n\n    /**\n     * @dev constuctor in Permissions approach\n     * @param newExecutorName - name of executor contract\n     * @param newContractsAddress needed in Permissions constructor\n     */\n    constructor(string memory newExecutorName, address newContractsAddress) Permissions(newContractsAddress) public {coverage_0x08d9a91d(0xc6defa78baa3e0ea342a5e0df19f26dab627e3ccd1ecf29ed05e7b72e9e747f6); /* function */ \n\ncoverage_0x08d9a91d(0x7355adfddfd0d657727b792002703adb7efb20e7cd80f0c7132de3e5c00548b6); /* line */ \n        coverage_0x08d9a91d(0x981cef256bf934e674d531e4d7c1e7344b1a07d2c437851e6a4becdf1f155e34); /* statement */ \nstartTime = uint32(block.timestamp);\ncoverage_0x08d9a91d(0xdd2485bef2c4fb0f899289a8befffe44e5873af026121d5236082c9327b8645b); /* line */ \n        coverage_0x08d9a91d(0x5d80721d9e0d036d5ba370bbff3213e03cfa3e3ee2add56a0362f5ccadd97fd0); /* statement */ \nexecutorName = newExecutorName;\n    }\n\n    /**\n     * @dev setMinersCap - sets miners capitalization\n     */\n    function setMinersCap(uint newMinersCap) external allow(executorName) {coverage_0x08d9a91d(0x6f26de608d46253db3aa039c5c601899af8c94e68f8178149f4d04142353554b); /* function */ \n\ncoverage_0x08d9a91d(0x2f0677df53e42515cc5c09a60a442a013311f0bcd3b3c165c130392f69201de9); /* line */ \n        coverage_0x08d9a91d(0xf00f6a1e54e0e2a80898d0a6a41d01ce28048c9840dc3f7f17e396ffa930ce98); /* statement */ \nminersCap = newMinersCap;\n    }\n\n    /**\n     * @dev setStageTimeAndStageNodes - sets new stage time and new amount of Nodes at this stage\n     */\n    function setStageTimeAndStageNodes(uint newStageNodes) external allow(executorName) {coverage_0x08d9a91d(0x00aba4730fdda884fe109e501a4a9e5d07136b580ac279c18b70db1196af9057); /* function */ \n\ncoverage_0x08d9a91d(0xab8d83770a1b09e6aa601cf8d7b8069d77c3331f9eaf6ecc7a02b7ec050a053c); /* line */ \n        coverage_0x08d9a91d(0xd1abe6242b69b09defe29de260f60b4447034742ddf649f5d255bdaa854423a2); /* statement */ \nstageNodes = newStageNodes;\ncoverage_0x08d9a91d(0x9ad3e3f0bcbb3560ecf132e2cc655b337966b24e3a535b72864af44dc7ce335c); /* line */ \n        coverage_0x08d9a91d(0xd8416dea4595d93280618225c9ed1f9f0c24fcd47207d4ba4a6816956009c6f2); /* statement */ \nstageTime = uint32(block.timestamp);\n    }\n\n}\n"
    },
    ".coverage_contracts/Migrations.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) external restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) external restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}"
    },
    ".coverage_contracts/NodesData.sol": {
      "content": "/*\n    NodesData.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IConstants.sol\";\nimport \"./interfaces/INodesData.sol\";\n\n\n/**\n * @title NodesData - Data contract for NodesFunctionality\n */\ncontract NodesData is INodesData, Permissions {\nfunction coverage_0xde509cdf(bytes32 c__0xde509cdf) public pure {}\n\n\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        //address owner;\n        bytes publicKey;\n        uint32 startDate;\n        uint32 lastRewardDate;\n        // uint8 freeSpace;\n        // uint indexInSpaceMap;\n        //address secondAddress;\n        NodeStatus status;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    // struct to note Full or Fractional Node and link to subarray\n    // struct NodeLink {\n    //     uint subarrayLink;\n    //     bool isNodeFull;\n    // }\n\n    // // struct to note nodeIndex and remaining space\n    // struct NodeFilling {\n    //     uint nodeIndex;\n    //     uint freeSpace;\n    // }\n\n    // array which contain all Nodes\n    Node[] public nodes;\n\n    SpaceManaging[] public spaceOfNodes;\n    // array which contain links to subarrays of Fractional and Full Nodes\n    // NodeLink[] public nodesLink;\n    // mapping for checking which Nodes and which number of Nodes owned by user\n    mapping (address => CreatedNodes) public nodeIndexes;\n    // mapping for checking is IP address busy\n    mapping (bytes4 => bool) public nodesIPCheck;\n    // mapping for checking is Name busy\n    mapping (bytes32 => bool) public nodesNameCheck;\n    // mapping for indication from Name to Index\n    mapping (bytes32 => uint) public nodesNameToIndex;\n    // mapping for indication from space to Nodes\n    mapping (uint8 => uint[]) public spaceToNodes;\n\n    // // array which contain only Fractional Nodes\n    // NodeFilling[] public fractionalNodes;\n    // // array which contain only Full Nodes\n    // NodeFilling[] public fullNodes;\n\n\n    uint public numberOfActiveNodes = 0;\n    uint public numberOfLeavingNodes = 0;\n    uint public numberOfLeftNodes = 0;\n\n    constructor(address newContractsAddress) Permissions(newContractsAddress) public {coverage_0xde509cdf(0x3594604af84e9ce1a1cfc6030f46ca53a225b012140b69e6077656792edc966a); /* function */ \n\n\n    }\n\n    function getNodesWithFreeSpace(uint8 freeSpace) external view returns (uint[] memory) {coverage_0xde509cdf(0x40e0f93c3091e1d4e2f6d2122cb35bcaca546ce75d219eca0b0de1305b246dba); /* function */ \n\ncoverage_0xde509cdf(0x5289c40241154feda30f6a423c9d1db8805df773171dc08e22f69020bd2a69a9); /* line */ \n        coverage_0xde509cdf(0xf5e1e03dae0091cb6aa315313f2baebfa0db4151c12aae092560e7e28be69f7a); /* statement */ \nuint[] memory nodesWithFreeSpace = new uint[](this.countNodesWithFreeSpace(freeSpace));\ncoverage_0xde509cdf(0x47c568c2bb78226a34411e3eb1473abe8de38ff780d6f747053a0a557ba66635); /* line */ \n        coverage_0xde509cdf(0xc64679f72dc8502cf88b2062f6e5068d38c2ac9e5166686b04b36855e14f6b09); /* statement */ \nuint cursor = 0;\ncoverage_0xde509cdf(0x42f3b21f6c79a7467ac624aa198411fed04d8d5d7dbf51c2f034f2a5ece9f49a); /* line */ \n        coverage_0xde509cdf(0x483949721dc100bab47d96c5880adeec583c4f34c4fa598d154cbedc1dc4602a); /* statement */ \nfor (uint8 i = freeSpace; i <= 128; ++i) {\ncoverage_0xde509cdf(0x757186110e48893e50e8134809401e56126e231fc77b689e3089a8776b2337fc); /* line */ \n            coverage_0xde509cdf(0x614d90d7497b61bf33d330d84d5050844b3f08c8a31cff70f13356324f36bec5); /* statement */ \nfor (uint j = 0; j < spaceToNodes[i].length; j++) {\ncoverage_0xde509cdf(0xbc632fbb3ec23f6c353644af75aa18017d7dff1a0a75abf6ef5c5e128aec0915); /* line */ \n                coverage_0xde509cdf(0xa429f7b5a159ae1ffb9aa8ae0a3ff6f299bc8375094a112fa841fb1796a0e7b4); /* statement */ \nnodesWithFreeSpace[cursor] = spaceToNodes[i][j];\ncoverage_0xde509cdf(0x17aead9cebb04349375e9d308b77666f4ae432a1cc0bfe4d2763f2d0c4a31d60); /* line */ \n                ++cursor;\n            }\n        }\ncoverage_0xde509cdf(0x15e4bf4c2eec4fd7a451b911df2016013a77df8d9e9db2bb03501cca8a8c0f95); /* line */ \n        coverage_0xde509cdf(0xe98cabd4a0c53ffca97874998f7874851aad042c34864318bf8e8533f5aa0496); /* statement */ \nreturn nodesWithFreeSpace;\n    }\n\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count) {coverage_0xde509cdf(0xd1055ea0bc8b31588e6483ebffaab045076036228b951fdcb5838950c0c38322); /* function */ \n\ncoverage_0xde509cdf(0xcc675c8088c65e4e0c91756f1c909d4d6b971e0b2c22bef66b8df0639d8ceec4); /* line */ \n        coverage_0xde509cdf(0x7970d8de330846980ffc0ac9836fccb6db4c7f2f37f094a811059193b77ce249); /* statement */ \ncount = 0;\ncoverage_0xde509cdf(0x768cdfcb15e4208be69db46621408e2e26c4fff60e0b15794b7338bb389146b9); /* line */ \n        coverage_0xde509cdf(0xd74deff2b285882f3d611a8c3edba0e7114dfbddf85f49b5c93ce95b7f69db5d); /* statement */ \nfor (uint8 i = freeSpace; i <= 128; ++i) {\ncoverage_0xde509cdf(0x77a8d587bfc4e67085fcdd304bdb8b371292870c2e98e7fc71c98a119e0f88db); /* line */ \n            coverage_0xde509cdf(0x20a597cde828e688b4444eb7c0fc994d28c8e2d0b0e92ad25c0b15c476aaf7f3); /* statement */ \ncount += spaceToNodes[i].length;\n        }\n    }\n\n    /**\n     * @dev addNode - adds Node to array\n     * function could be run only by executor\n     * @param from - owner of Node\n     * @param name - Node name\n     * @param ip - Node ip\n     * @param publicIP - Node public ip\n     * @param port - Node public port\n     * @param publicKey - Ethereum public key\n     * @return index of Node\n     */\n    function addNode(\n        address from,\n        string calldata name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        bytes calldata publicKey\n    )\n        external\n        allow(\"NodesFunctionality\")\n        returns (uint nodeIndex)\n    {coverage_0xde509cdf(0x1e176691a1f9e6c0cb2d42bf63c3350dec2d2c3ca85ea0488d5b2fee703f8c42); /* function */ \n\ncoverage_0xde509cdf(0xe863a550aa34ee495439233f74ddfe26f099e531ffcea53f5c3ec8b4fd60b593); /* line */ \n        coverage_0xde509cdf(0xc723245ad1325a070a19a3a7f3338c77e83015d6c02d0212f52558931625f6ea); /* statement */ \nnodes.push(Node({\n            name: name,\n            ip: ip,\n            publicIP: publicIP,\n            port: port,\n            //owner: from,\n            publicKey: publicKey,\n            startDate: uint32(block.timestamp),\n            lastRewardDate: uint32(block.timestamp),\n            status: NodeStatus.Active\n        }));\ncoverage_0xde509cdf(0xaf8e046a89630b421548ba25c661e48f7bb1f308f58f0600787d76e12caa03df); /* line */ \n        coverage_0xde509cdf(0x7b08497ea46ac9556ab7b87ae2e943055b7402e5bd2b5714078b47130dde46f0); /* statement */ \nnodeIndex = nodes.length - 1;\ncoverage_0xde509cdf(0x83ad45c3e2adba20b84a26fdb3fd6ab1067694726a7b0a80fdfa369cdbf36a53); /* line */ \n        coverage_0xde509cdf(0xa343fc9d06e48db357ff9bbe0bd04de5e6b07069ea3e525b71c784dcdf15a9f1); /* statement */ \nbytes32 nodeId = keccak256(abi.encodePacked(name));\ncoverage_0xde509cdf(0x0de8dd24185081735c0dec19ef24cd0b486054551d9a48ae064d3c7341453086); /* line */ \n        coverage_0xde509cdf(0x72d1c98bd9a94d094cbc6c375095ab7571c82e8cb77fcce25aefdef7307a7154); /* statement */ \nnodesIPCheck[ip] = true;\ncoverage_0xde509cdf(0x13223bf08d44386a1f3ffce8c7758f23dcebbdcef0d9b78f32d547f1a3c77d14); /* line */ \n        coverage_0xde509cdf(0x51ace250072e6ff37489c3599a54a37e767032dce6b4b0b7b3494824f41f903f); /* statement */ \nnodesNameCheck[nodeId] = true;\ncoverage_0xde509cdf(0x5314fb993ac024cd64a9546ab22821ff63ff7c2a64ad11120daed9cf3c71a6ca); /* line */ \n        coverage_0xde509cdf(0xa49abf7d8de315ef0ecded494d03d26c773e1f6aa80052b9c562900fbcc471d8); /* statement */ \nnodesNameToIndex[nodeId] = nodeIndex;\ncoverage_0xde509cdf(0x0cb8726f41acf05926940ab5f1a76a538f6638c91e9299234ef01c99970829c6); /* line */ \n        coverage_0xde509cdf(0x5f576aea0ee1878d0fbc85ef9422e690e2e3807caa353028850cde8e10833473); /* statement */ \nnodeIndexes[from].isNodeExist[nodeIndex] = true;\ncoverage_0xde509cdf(0x1bc9390ebe86e2011219c06e54440218e1e9589b0a6d36b188933033d2f9676a); /* line */ \n        nodeIndexes[from].numberOfNodes++;\ncoverage_0xde509cdf(0x5573a1125c9502f3cf53fcc83168b582c6d478d56b10ef21167a58b09f20e411); /* line */ \n        coverage_0xde509cdf(0x54badf00812eb47e8b02076ae03a656b241ecbab030696ad2e908d0f874eee13); /* statement */ \nspaceOfNodes.push(SpaceManaging({\n            freeSpace: 128,\n            indexInSpaceMap: spaceToNodes[128].length\n        }));\ncoverage_0xde509cdf(0x831751e41e10387013afebdb5830f6c82326cf9b13e72e66de38eca7898061c6); /* line */ \n        coverage_0xde509cdf(0xc0945bbcca574f8b2b4154296ce9866a094d3a2e68f3c9cb6f855032f7936556); /* statement */ \nspaceToNodes[128].push(nodeIndex);\ncoverage_0xde509cdf(0x54da37d7cba1c66c531f65d4432a4a2596d7dc8e956dfb68753a686986457d52); /* line */ \n        numberOfActiveNodes++;\n    }\n\n    // /**\n    //  * @dev addFractionalNode - adds Node to array of Fractional Nodes\n    //  * function could be run only by executor\n    //  * @param nodeIndex - index of Node\n    //  */\n    // function addFractionalNode(uint nodeIndex) external allow(\"NodesFunctionality\") {\n    //     fractionalNodes.push(NodeFilling({\n    //         nodeIndex: nodeIndex,\n    //         freeSpace: 128\n    //     }));\n    //     nodesLink.push(NodeLink({\n    //         subarrayLink: fractionalNodes.length - 1,\n    //         isNodeFull: false\n    //     }));\n    // }\n\n    // /**\n    //  * @dev addFullNode - adds Node to array of Full Nodes\n    //  * function could be run only by executor\n    //  * @param nodeIndex - index of Node\n    //  */\n    // function addFullNode(uint nodeIndex) external allow(\"NodesFunctionality\") {\n    //     fullNodes.push(NodeFilling({\n    //         nodeIndex: nodeIndex,\n    //         freeSpace: 128\n    //     }));\n    //     nodesLink.push(NodeLink({\n    //         subarrayLink: fullNodes.length - 1,\n    //         isNodeFull: true\n    //     }));\n    // }\n\n    /**\n     * @dev setNodeLeaving - set Node Leaving\n     * function could be run only by NodesFunctionality\n     * @param nodeIndex - index of Node\n     */\n    function setNodeLeaving(uint nodeIndex) external allow(\"NodesFunctionality\") {coverage_0xde509cdf(0x866c65e6b25253e674744bb2682cdae8aba63c2fdddaaa9d542355b98e1bb27b); /* function */ \n\ncoverage_0xde509cdf(0xe8df342a5fc8d9aec218754174f05cfb76a635758b88b3add64ab4828657fcae); /* line */ \n        coverage_0xde509cdf(0xd1d82d19c830d4ff8b8c1c8587bb5d265148ff020b3c0ada20c06e610e72b912); /* statement */ \nnodes[nodeIndex].status = NodeStatus.Leaving;\ncoverage_0xde509cdf(0x38258b3610e100c56295ff8a5ca507da69d71bc7155e9f9c9a11554f7f8def17); /* line */ \n        numberOfActiveNodes--;\ncoverage_0xde509cdf(0xcb93b8b33331f571687e6f8cbda80af4677ebdbd5001b3d230cd931addf1701f); /* line */ \n        numberOfLeavingNodes++;\n    }\n\n    /**\n     * @dev setNodeLeft - set Node Left\n     * function could be run only by NodesFunctionality\n     * @param nodeIndex - index of Node\n     */\n    function setNodeLeft(uint nodeIndex) external allow(\"NodesFunctionality\") {coverage_0xde509cdf(0x4bb63b7331cce0bfcc9cac157c1d1ac5c89e246a8ef0c8459c8661340e0ab543); /* function */ \n\ncoverage_0xde509cdf(0xe2fa935378613e777c6719c85351ca15c49fd36468affeb8442e34f1272fdfa8); /* line */ \n        coverage_0xde509cdf(0xb0905955633bfb09b249401b8672ea63f40fdabab89ab7b61d189a32c3bb289b); /* statement */ \nnodesIPCheck[nodes[nodeIndex].ip] = false;\ncoverage_0xde509cdf(0xd9e980d81f8bc1db2c90cbad641f530e11e84abd474a48a8b9a39ff38b753477); /* line */ \n        coverage_0xde509cdf(0x3577413444eca57ecae90fbb03715b70a881cfad235e2b54fe43004216f5033b); /* statement */ \nnodesNameCheck[keccak256(abi.encodePacked(nodes[nodeIndex].name))] = false;\n        // address ownerOfNode = nodes[nodeIndex].owner;\n        // nodeIndexes[ownerOfNode].isNodeExist[nodeIndex] = false;\n        // nodeIndexes[ownerOfNode].numberOfNodes--;\ncoverage_0xde509cdf(0xfbb29cdb77cfac6175fd53166899c34ef097497895c10acd08deb4acb7bdbbf7); /* line */ \n        delete nodesNameToIndex[keccak256(abi.encodePacked(nodes[nodeIndex].name))];\ncoverage_0xde509cdf(0xe16e1e8a1f08a6e83faf44768050a637c4359f1a151545a65b348f08931bb250); /* line */ \n        coverage_0xde509cdf(0x577aca387664dbfe1dc4ba3b9307449931595ce618d4fc533b896f889721a143); /* statement */ \nif (nodes[nodeIndex].status == NodeStatus.Active) {coverage_0xde509cdf(0x9811fbc01449cf6c085c433e188584edd32dc629c229b9134b6bdce4578b0df9); /* branch */ \n\ncoverage_0xde509cdf(0x661a08b2f3ce3671173edb8f45453d91f6bd4d91b6385383b0ee7aa4d67c55e2); /* line */ \n            numberOfActiveNodes--;\n        } else {coverage_0xde509cdf(0x6f8b9b63598a6e756e228732cb2143d3abc0dbf8d17efb930901ea3bc530997f); /* branch */ \n\ncoverage_0xde509cdf(0x51357ce0f2b92477cab0ff98b9aacb1d1461df9506ea02aaa8bb8912e1ece08f); /* line */ \n            numberOfLeavingNodes--;\n        }\ncoverage_0xde509cdf(0xb3ea87fcb7be0694058e851485cec1f8c5bad4ad1947a5cb3c198dbbd9bb6896); /* line */ \n        coverage_0xde509cdf(0x50e490d2b47bf9c47ab6c4ea68c246fb7f7b62a07a23c7e802de544d9e3add18); /* statement */ \nnodes[nodeIndex].status = NodeStatus.Left;\ncoverage_0xde509cdf(0x6daa3d8dd24c382632b8fc222512aab64de2b44f36efbea104d8282c274b42ff); /* line */ \n        numberOfLeftNodes++;\n    }\n\n    // /**\n    //  * @dev removeFractionalNode - removes Node from Fractional Nodes array\n    //  * function could be run only by NodesFunctionality\n    //  * @param subarrayIndex - index of Node at array of Fractional Nodes\n    //  */\n    // function removeFractionalNode(uint subarrayIndex) external allow(\"NodesFunctionality\") {\n    //     if (subarrayIndex != fractionalNodes.length - 1) {\n    //         uint secondNodeIndex = fractionalNodes[fractionalNodes.length - 1].nodeIndex;\n    //         fractionalNodes[subarrayIndex] = fractionalNodes[fractionalNodes.length - 1];\n    //         nodesLink[secondNodeIndex].subarrayLink = subarrayIndex;\n    //     }\n    //     delete fractionalNodes[fractionalNodes.length - 1];\n    //     fractionalNodes.length--;\n    // }\n\n    // /**\n    //  * @dev removeFullNode - removes Node from Full Nodes array\n    //  * function could be run only by NodesFunctionality\n    //  * @param subarrayIndex - index of Node at array of Full Nodes\n    //  */\n    // function removeFullNode(uint subarrayIndex) external allow(\"NodesFunctionality\") {\n    //     if (subarrayIndex != fullNodes.length - 1) {\n    //         uint secondNodeIndex = fullNodes[fullNodes.length - 1].nodeIndex;\n    //         fullNodes[subarrayIndex] = fullNodes[fullNodes.length - 1];\n    //         nodesLink[secondNodeIndex].subarrayLink = subarrayIndex;\n    //     }\n    //     delete fullNodes[fullNodes.length - 1];\n    //     fullNodes.length--;\n    // }\n\n    function removeNode(uint nodeIndex) external allow(\"NodesFunctionality\") {coverage_0xde509cdf(0x094bc1c2c2ab4124be9c23d6d07fb471afa8c39814ec650982a9ab13e18c428d); /* function */ \n\ncoverage_0xde509cdf(0xc08c8d0ea6a4ed9cd9051d2361476438e0834bd90e72dce28733dba49873b57a); /* line */ \n        coverage_0xde509cdf(0x0359715c6425f4c8ef86fcb89b6c83beb2969efa6a62c6fdb73e7787d5f1a91b); /* statement */ \nuint8 space = spaceOfNodes[nodeIndex].freeSpace;\ncoverage_0xde509cdf(0xf72dce2ab2fc34004159c5f12ecfd506806980ec4316fb5d4094e30bd1887714); /* line */ \n        coverage_0xde509cdf(0x34497a6d5d627d62effa8590e9064c63ff48cb41855b82373f156e987d4cbf00); /* statement */ \nuint indexInArray = spaceOfNodes[nodeIndex].indexInSpaceMap;\ncoverage_0xde509cdf(0x0521a2848af67c99e576469115aaadf797d3300af6df9ac32804411f2baa77ed); /* line */ \n        coverage_0xde509cdf(0xb5c82000a1707785a9b69e52f1bd5dbe2838e5923192437ef6a3c1492713ecc7); /* statement */ \nif (indexInArray < spaceToNodes[space].length - 1) {coverage_0xde509cdf(0x3ca189c4e61d62d1f8623779c55182d1f90897e86742b35a98a9c78a1fd0f4d9); /* branch */ \n\ncoverage_0xde509cdf(0xbf21ccb426cf16fa9d2c63b010e631bd65f21224e1833c0b9c3d380b8609c23c); /* line */ \n            coverage_0xde509cdf(0x8aea5383f1493c3a3354fdba731825fd9b9b70448f4b4d61f4e4aa8d1e97d01f); /* statement */ \nuint shiftedIndex = spaceToNodes[space][spaceToNodes[space].length - 1];\ncoverage_0xde509cdf(0xc2766ca812412f777b41f9c02f43627610b92f5b064a8c8651b5653291737a98); /* line */ \n            coverage_0xde509cdf(0x94c684cdb1411d45fdc6cb0eabf28d142ee3359aad085d141312c81f4a83331c); /* statement */ \nspaceToNodes[space][indexInArray] = shiftedIndex;\ncoverage_0xde509cdf(0x7ff2ea2254b14d15dcbf63ab911540c78214b8d72520d5549995f587f2f0ac6d); /* line */ \n            coverage_0xde509cdf(0x7a666f37bb21b3c9f520500b65cd785d45d477052a13647c48417c1b59bb8be0); /* statement */ \nspaceOfNodes[shiftedIndex].indexInSpaceMap = indexInArray;\ncoverage_0xde509cdf(0x700d12ff70c685b66546992e5e1d4e46d8fb004b8a33093cd577c923cf6b7528); /* line */ \n            spaceToNodes[space].length--;\n        } else {coverage_0xde509cdf(0x5fe37f70cf0cfb9da9e2825082d88a95e980aaa1d12f1bde2f5ff918a2e393c8); /* branch */ \n\ncoverage_0xde509cdf(0x2d41dbed9c9be7a80200b6bd74dff5f699c59a1804e1f65447d0d3c573b8b378); /* line */ \n            spaceToNodes[space].length--;\n        }\ncoverage_0xde509cdf(0xb68c87cc6d3555a593272e767505bcd9a2454bcfc1a24206e7d011e704b2afca); /* line */ \n        delete spaceOfNodes[nodeIndex].freeSpace;\ncoverage_0xde509cdf(0xf508adfb9ebf9272ffed557af373c46b40d28bb4feab33172981e5da2e601125); /* line */ \n        delete spaceOfNodes[nodeIndex].indexInSpaceMap;\n    }\n\n    /**\n     * @dev removeSpaceFromFractionalNode - occupies space from Fractional Node\n     * function could be run only by SchainsFunctionality\n     * @param nodeIndex - index of Node at array of Fractional Nodes\n     * @param space - space which should be occupied\n     */\n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external allow(\"SchainsFunctionalityInternal\") returns (bool) {coverage_0xde509cdf(0x6c858b0ee33924f0e1d03093a89229cdef55ec1513cd8c32daab66de81b29343); /* function */ \n\ncoverage_0xde509cdf(0xb2366d3a3a5d6ce4c626650ba6680906b2ad596e19f0a007d2a600f00fa24d45); /* line */ \n        coverage_0xde509cdf(0xbd401cd40f761cabfb8937e4bca0fb12a9097e7d1000e6e11a60378c4a89ecad); /* statement */ \nif (spaceOfNodes[nodeIndex].freeSpace < space) {coverage_0xde509cdf(0x6074c8596a8cfd737ed9c8a022df5580a3e182c651b4de802e003e2e0e27ca6c); /* branch */ \n\ncoverage_0xde509cdf(0xe653e154983c1290ff0de44d3019b9f2d32b6eb5150acf12bc5afe90629a5d77); /* line */ \n            coverage_0xde509cdf(0xfc1bd51aab93d0f6cd415b2ab461bc1ca337ccce5f3d648432a9114507adf0d8); /* statement */ \nreturn false;\n        }else { coverage_0xde509cdf(0xfb3e8f160b158bd94391a5d3294d5cc7041c6152bfedc312d208ccdcf28ead85); /* branch */ \n}\ncoverage_0xde509cdf(0x495c91a4f45eca520f6124436ab1b8249ed7fdc7cdedb985352002197a6ffbed); /* line */ \n        coverage_0xde509cdf(0x1005414fa2951155029c6036f31b758cdb5f627617f839bed5cc16db95aa0151); /* statement */ \nif (space > 0) {coverage_0xde509cdf(0xaa4b97b0782fc880180039583ab8b3d3f4700103c0a31629527edf422f7cf154); /* branch */ \n\ncoverage_0xde509cdf(0x94b8c6c49dba740b90eaa90f8a16553b7efb71aeb1b5be54813bd42dd0b28982); /* line */ \n            coverage_0xde509cdf(0x4e1a8274cd16f0bc8b4691c05e83ed8d20c361ffd736a3b1fd720b0d7d7e7b72); /* statement */ \nmoveNodeToNewSpaceMap(\n                nodeIndex,\n                spaceOfNodes[nodeIndex].freeSpace - space\n            );\n        }else { coverage_0xde509cdf(0x98eda483d5ded745dbf147f0e83e529ed6b9c447c9bc591373dac88666de46ef); /* branch */ \n}\ncoverage_0xde509cdf(0x766720ebad0921ffdcb7b0e2a4ffd6b0091cf511bd685aa80f6c0b620cedda12); /* line */ \n        coverage_0xde509cdf(0xe96579c27b4cf8ed2f7285226214eaf1c3aafba3773ae08749e037add8f2c62a); /* statement */ \nreturn true;\n    }\n\n    // /**\n    //  * @dev removeSpaceFromFullNodes - occupies space from Full Node\n    //  * function could be run only by SchainsFunctionality\n    //  * @param subarrayLink - index of Node at array of Full Nodes\n    //  * @param space - space which should be occupied\n    //  */\n    // function removeSpaceFromFullNode(uint subarrayLink, uint space) external allow(\"SchainsFunctionalityInternal\") returns (bool) {\n    //     if (fullNodes[subarrayLink].freeSpace < space) {\n    //         return false;\n    //     }\n    //     fullNodes[subarrayLink].freeSpace -= space;\n    //     return true;\n    // }\n\n    /**\n     * @dev adSpaceToFractionalNode - returns space to Fractional Node\n     * function could be run only be SchainsFunctionality\n     * @param nodeIndex - index of Node at array of Fractional Nodes\n     * @param space - space which should be returned\n     */\n    function addSpaceToNode(uint nodeIndex, uint8 space) external allow(\"SchainsFunctionality\") {coverage_0xde509cdf(0xf57f35f4562e53c86dfcf267e2519f6b7a1a5ce3f1109963ba5a451c91fdb17a); /* function */ \n\ncoverage_0xde509cdf(0x31f0bc476c9dba6d15d26d1d5e7ffcf7f66b5ea20f508df378422e2bbf93df2e); /* line */ \n        coverage_0xde509cdf(0xe90cf04ffe28366c1b0a7b0e7d27a45b643d50be778c15b8ba00c183e6c667c3); /* statement */ \nif (space > 0) {coverage_0xde509cdf(0x4c4998dbc96580ea87dc4603a5152cb950d92b8f09e41e7a3f9ba49e8e17f495); /* branch */ \n\ncoverage_0xde509cdf(0xff019469cc1828c0b0b8c34c40eb908fdeab569079bddae15655a9084d450826); /* line */ \n            coverage_0xde509cdf(0xc66b78e5a1f855f0b147d59650f67d90a4e694212179739baf7ebcdb01d4109d); /* statement */ \nmoveNodeToNewSpaceMap(\n                nodeIndex,\n                spaceOfNodes[nodeIndex].freeSpace + space\n            );\n        }else { coverage_0xde509cdf(0x428b7b3a10b5c33c6affa1bdc1b8bda99e790b6ee7de96313b28a51c9519c445); /* branch */ \n}\n    }\n\n    // /**\n    //  * @dev addSpaceToFullNode - returns space to Full Node\n    //  * function could be run only by SchainsFunctionality\n    //  * @param subarrayLink - index of Node at array of Full Nodes\n    //  * @param space - space which should be returned\n    //  */\n    // function addSpaceToFullNode(uint subarrayLink, uint space) external allow(\"SchainsFunctionality\") {\n    //     fullNodes[subarrayLink].freeSpace += space;\n    // }\n\n    /**\n     * @dev changeNodeLastRewardDate - changes Node's last reward date\n     * function could be run only by SkaleManager\n     * @param nodeIndex - index of Node\n     */\n    function changeNodeLastRewardDate(uint nodeIndex) external allow(\"SkaleManager\") {coverage_0xde509cdf(0x2db7526dfbc4593c9fd9a6272ae29ca86b0cd665574478dc4afa82e130e4ecc9); /* function */ \n\ncoverage_0xde509cdf(0xbd18812e8a72b29fb7369fe11475898964a18fac46961131512ee1a0f49293cb); /* line */ \n        coverage_0xde509cdf(0x57cec999e64648afb27f3156f35604666ee5397cac95e10a20b5919849382c00); /* statement */ \nnodes[nodeIndex].lastRewardDate = uint32(block.timestamp);\n    }\n\n    /**\n     * @dev isNodeExist - checks existence of Node at this address\n     * @param from - account address\n     * @param nodeIndex - index of Node\n     * @return if exist - true, else - false\n     */\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool) {coverage_0xde509cdf(0xaee9fac6a59c0993fe835475d427b984e0302f71d37a45b04525df93095be0cf); /* function */ \n\ncoverage_0xde509cdf(0x7e63ab923336f5ea2deddefddd9387fbecb383210b6d43344a39ac8cd79b3d7f); /* line */ \n        coverage_0xde509cdf(0x91ef7c81406890a886d729812218227da5c9b63ddd27a33a13e93482858bdce1); /* statement */ \nreturn nodeIndexes[from].isNodeExist[nodeIndex];\n    }\n\n    /**\n     * @dev isTimeForReward - checks if time for reward has come\n     * @param nodeIndex - index of Node\n     * @return if time for reward has come - true, else - false\n     */\n    function isTimeForReward(uint nodeIndex) external view returns (bool) {coverage_0xde509cdf(0x26f2bbad56fadcf90458b4c757aa8f3fe0bfc75075111df8f3e5ffeff43996de); /* function */ \n\ncoverage_0xde509cdf(0x62db6e5c84cd9918366dbe659c4400c5dd177dc1c41b4ea1a48db250b88b0d91); /* line */ \n        coverage_0xde509cdf(0x985b863d829a4cd366bfab14810a6e1792adc65d443f8733f2ff33f6ca616a09); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0xde509cdf(0xfa5cc6aa25f03d065992261f7768c4f321695385a1a76c508dc681cdc027b877); /* line */ \n        coverage_0xde509cdf(0xe796d2e4bd73a37a80278852541b6beccbcbbb3990f9a91845c9834b63fabe91); /* statement */ \nreturn nodes[nodeIndex].lastRewardDate + IConstants(constantsAddress).rewardPeriod() <= block.timestamp;\n    }\n\n    /**\n     * @dev getNodeIP - get ip address of Node\n     * @param nodeIndex - index of Node\n     * @return ip address\n     */\n    function getNodeIP(uint nodeIndex) external view returns (bytes4) {coverage_0xde509cdf(0x8e1a013ba030a73dde38e04450263aca77ba7d82ca9175997d1d4c44fb7322dc); /* function */ \n\ncoverage_0xde509cdf(0x271262a683bbecab18a146489499390dbea99b58674c72eaca8a439e3a2d9f51); /* line */ \n        coverage_0xde509cdf(0xdf4ae81af590aab015b8ae1d78e2b3ae15f1fb34bdcc6f899bf279a9b61a6fb4); /* statement */ \nreturn nodes[nodeIndex].ip;\n    }\n\n    /**\n     * @dev getNodePort - get Node's port\n     * @param nodeIndex - index of Node\n     * @return port\n     */\n    function getNodePort(uint nodeIndex) external view returns (uint16) {coverage_0xde509cdf(0xec5eabcb83019e1bbf262d703a57f3d62d0f78a810ccc4e32bf699d5b67ac03e); /* function */ \n\ncoverage_0xde509cdf(0x00f2769443f833fb9045dceafc1de84bd34fbd6fb56a2c10244be2485025830c); /* line */ \n        coverage_0xde509cdf(0xc00186aea433ac94cb7bdf71bd3aa4df471a0c36c17db4006d459c4c49f11acc); /* statement */ \nreturn nodes[nodeIndex].port;\n    }\n\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes memory) {coverage_0xde509cdf(0x97d62c5da619ecb8e9b57d85427acfa6204d1b8806210811939bf6e3e956ecb6); /* function */ \n\ncoverage_0xde509cdf(0xbf51510805c4b501749596e8f7802da63b26444069755f3bb42758cdc61d9683); /* line */ \n        coverage_0xde509cdf(0x6672ac7760fa067c713b59c72630abe94cf85d24a856b18610ddf3784dd6ae69); /* statement */ \nreturn nodes[nodeIndex].publicKey;\n    }\n\n    /**\n     * @dev isNodeLeaving - checks if Node status Leaving\n     * @param nodeIndex - index of Node\n     * @return if Node status Leaving - true, else - false\n     */\n    function isNodeLeaving(uint nodeIndex) external view returns (bool) {coverage_0xde509cdf(0x98754bc129593606ac3f5e4e3cc0b88623d2f30dabd2fe26237214ebad39a933); /* function */ \n\ncoverage_0xde509cdf(0x5d49332e96e57f09fa605900a479d1c2e03c062329864649eb82ed93f329db7e); /* line */ \n        coverage_0xde509cdf(0x33ccf764aa5450f312422349e263e3f6e1f6b1848c55b1ed0c2486477d546140); /* statement */ \nreturn nodes[nodeIndex].status == NodeStatus.Leaving;\n    }\n\n    /**\n     * @dev isNodeLeft - checks if Node status Left\n     * @param nodeIndex - index of Node\n     * @return if Node status Left - true, else - false\n     */\n    function isNodeLeft(uint nodeIndex) external view returns (bool) {coverage_0xde509cdf(0x86ef2aa4b9e3fb96e3a9802a0d1b3a1e11b549eab2e6c13111e962c7208300b2); /* function */ \n\ncoverage_0xde509cdf(0xc90abb78073a727f77475c91929d0535e3607082c9057675391af6a1a32da671); /* line */ \n        coverage_0xde509cdf(0x7c8d989d0cd9d41b6a562bc97d02a3823741a182c1a0eb9599b7ef5b63835c40); /* statement */ \nreturn nodes[nodeIndex].status == NodeStatus.Left;\n    }\n\n    /**\n     * @dev getNodeLastRewardDate - get Node last reward date\n     * @param nodeIndex - index of Node\n     * @return Node last reward date\n     */\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint32) {coverage_0xde509cdf(0xd7a5f153c895ca619090f3e2ba3d37057023f2dd7401b5a5c7d745c3d76e4741); /* function */ \n\ncoverage_0xde509cdf(0xd27239a0c71f8a2553bf861cf101b17fcb1d8477a56a0af05200629e563516fe); /* line */ \n        coverage_0xde509cdf(0x5d0896ffbfbdaf385bba13b7818ad7e2e803d93f72845fe1281eb54fcf0e1219); /* statement */ \nreturn nodes[nodeIndex].lastRewardDate;\n    }\n\n    /**\n     * @dev getNodeNextRewardDate - get Node next reward date\n     * @param nodeIndex - index of Node\n     * @return Node next reward date\n     */\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint32) {coverage_0xde509cdf(0xd59b02e4942898b884ee366b7818af442dcb936cdd02059c01ccdfa54ea17d98); /* function */ \n\ncoverage_0xde509cdf(0x0f39b628d69d949bd4e7d6f1ad26b0b175ede9a761619f30f2cc24bd9de8757e); /* line */ \n        coverage_0xde509cdf(0xcf97aed7a271eb5898d78ccd84e2de99bd87f821f938d536def25feea1b50a5e); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0xde509cdf(0xfc6603fec7922a48a119e00d5e2791ca59b164a1d3e220f7be1b8811595959b3); /* line */ \n        coverage_0xde509cdf(0x3324fecc00260a04917ae6c414b51e2a0a66da9065b68630c774d36a6ed8a206); /* statement */ \nreturn nodes[nodeIndex].lastRewardDate + IConstants(constantsAddress).rewardPeriod();\n    }\n\n    /**\n     * @dev getNumberOfNodes - get number of Nodes\n     * @return number of Nodes\n     */\n    function getNumberOfNodes() external view returns (uint) {coverage_0xde509cdf(0xe9d271c1fae4d01384af90b2a229e9c77a52534e6f4c52c0ffcffcac17cbc2de); /* function */ \n\ncoverage_0xde509cdf(0x5822e97c1339f9dc444f8f60561d0e65e98e93e1bc1224fedcbc6bd9644ec61a); /* line */ \n        coverage_0xde509cdf(0x202860b1026a06aa2f7a6901f339352b703dd0a3bc44e06bbcd6b252c0ba2d1f); /* statement */ \nreturn nodes.length;\n    }\n\n    // /**\n    //  * @dev getNumberOfFractionalNodes - get number of Fractional Nodes\n    //  * @return number of Fractional Nodes\n    //  */\n    // function getNumberOfFractionalNodes() external view returns (uint) {\n    //     return fractionalNodes.length;\n    // }\n\n    // /**\n    //  * @dev getNumberOfFullNodes - get number of Full Nodes\n    //  * @return number of Full Nodes\n    //  */\n    // function getNumberOfFullNodes() external view returns (uint) {\n    //     return fullNodes.length;\n    // }\n\n    /**\n     * @dev getNumberOfFullNodes - get number Online Nodes\n     * @return number of active nodes plus number of leaving nodes\n     */\n    function getNumberOnlineNodes() external view returns (uint) {coverage_0xde509cdf(0x4d3e991d2e2bb09c7bda15efed7020c4a5c3b9518b6354c7259a132db7b913db); /* function */ \n\ncoverage_0xde509cdf(0x3307e82c6d8fb1f9a01d864e92cc56a88956353285aa621d8f1332d858e5be08); /* line */ \n        coverage_0xde509cdf(0xc7a55c7ce43738fd7c0de677bbb9c01dbfa240753f5f39fd170c53d5198eed38); /* statement */ \nreturn numberOfActiveNodes + numberOfLeavingNodes;\n    }\n\n    // /**\n    //  * @dev enoughNodesWithFreeSpace - get number of free Fractional Nodes\n    //  * @return numberOfFreeFractionalNodes - number of free Fractional Nodes\n    //  */\n    // function enoughNodesWithFreeSpace(uint8 space, uint needNodes) external view returns (bool nodesAreEnough) {\n    //     uint numberOfFreeNodes = 0;\n    //     for (uint8 i = space; i <= 128; i++) {\n    //         numberOfFreeNodes += spaceToNodes[i].length;\n    //         if (numberOfFreeNodes == needNodes) {\n    //             return true;\n    //         }\n    //     }\n    //     return false;\n    // }\n\n    // /**\n    //  * @dev getnumberOfFreeNodes - get number of free Full Nodes\n    //  * @return numberOfFreeFullNodes - number of free Full Nodes\n    //  */\n    // function enoughNodesWithFreeSpace(uint needNodes, unt ) external view returns (bool nodesAreEnough) {\n    //     for (uint indexOfNode = 0; indexOfNode < nodes.length; indexOfNode++) {\n    //         if (nodes[indexOfNode].freeSpace == 128 && isNodeActive(nodes[indexOfNode].nodeIndex)) {\n    //             numberOfFreeFullNodes++;\n    //             if (numberOfFreeFullNodes == needNodes) {\n    //                 return true;\n    //             }\n    //         }\n    //     }\n    //     return false;\n    // }\n\n    /**\n     * @dev getActiveNodeIPs - get array of ips of Active Nodes\n     * @return activeNodeIPs - array of ips of Active Nodes\n     */\n    function getActiveNodeIPs() external view returns (bytes4[] memory activeNodeIPs) {coverage_0xde509cdf(0x66f394f386359ebf600a9c10980b17143cc8000e66379b7f3b557deeccff78d0); /* function */ \n\ncoverage_0xde509cdf(0xb2569dc08337f1b794107cb3d07d2382aa8f8e0401669ee3aabd2334a96dbabe); /* line */ \n        coverage_0xde509cdf(0x816dc4e21a445ff9a66dc8c1eb7d66e11856c60318237db6cb6571e0e031c072); /* statement */ \nactiveNodeIPs = new bytes4[](numberOfActiveNodes);\ncoverage_0xde509cdf(0x89b6306c5034f061b41567672b873bd7871f3e4d6ce281c3fb2b73eaa2f3e86a); /* line */ \n        coverage_0xde509cdf(0x44f2a042058dabbf8c1ea8de1eb91375ad3ae4a8688b19f95fb236906d151d43); /* statement */ \nuint indexOfActiveNodeIPs = 0;\ncoverage_0xde509cdf(0xbbaefa0a5ef22bf7328a4afcdca1e8a833a8e59c12e0e48e295ec6472767c1c1); /* line */ \n        coverage_0xde509cdf(0x424f11ee28bce49dc15bcb13a3e0c206f279da9be8ff46ef944408e8d9f3c7ae); /* statement */ \nfor (uint indexOfNodes = 0; indexOfNodes < nodes.length; indexOfNodes++) {\ncoverage_0xde509cdf(0x1b94b7d8de322c2f24c2d5ccf37936a9df263b4e17b03bed68a27278d444f2c5); /* line */ \n            coverage_0xde509cdf(0x18794fd6ee54b617c6592d0368fea1b94cda6acb68fcc89d38c41b04c1bef48f); /* statement */ \nif (isNodeActive(indexOfNodes)) {coverage_0xde509cdf(0x8a4b984cab95a45b74bb0afd4144983a5fb01352b885cceadcb37549e1638581); /* branch */ \n\ncoverage_0xde509cdf(0x083b74072b9d59c0b16133ebf17b9dc9b8bfb1a15b05fb36b1fde7a5eef4a270); /* line */ \n                coverage_0xde509cdf(0x033932c2d6cad6afae89ae47556949ef5a3e29352e5313f0cfa1c0c296215591); /* statement */ \nactiveNodeIPs[indexOfActiveNodeIPs] = nodes[indexOfNodes].ip;\ncoverage_0xde509cdf(0x6c19f32a90653f9c730d5f200c4d42ba51933b249e8c4b00b1a9ef5d55be7a86); /* line */ \n                indexOfActiveNodeIPs++;\n            }else { coverage_0xde509cdf(0xb3e67205baaf2ae13a7660a22f26a568ac383b5063fca66be3db663090c9fc21); /* branch */ \n}\n        }\n    }\n\n    /**\n     * @dev getActiveNodesByAddress - get array of indexes of Active Nodes, which were\n     * created by msg.sender\n     * @return activeNodesbyAddress - array of indexes of Active Nodes, which were created\n     * by msg.sender\n     */\n    function getActiveNodesByAddress() external view returns (uint[] memory activeNodesByAddress) {coverage_0xde509cdf(0x914a05b90058131b6798af0d19444bbd60c78b253e5be45d6760fca106b30931); /* function */ \n\ncoverage_0xde509cdf(0x4bf25199f791461fed6b57b8341d6e7a3b28a283db6bb9f570e8a8db07e92187); /* line */ \n        coverage_0xde509cdf(0xe460caeb12c5b95925f6569c273c6f031fda936420b8ce407f9af45cde38235c); /* statement */ \nactiveNodesByAddress = new uint[](nodeIndexes[msg.sender].numberOfNodes);\ncoverage_0xde509cdf(0xe41d9bb9651b257697616bc280967cd9fe1a7dc9e95fed5700e27e812e63e7d0); /* line */ \n        coverage_0xde509cdf(0xea42e32af397d63075f32479ca6169dace7d3be1e460c956439a8343ad9a4429); /* statement */ \nuint indexOfActiveNodesByAddress = 0;\ncoverage_0xde509cdf(0x538896da19313f6090654c203f8d7bba87bf2aac8b4186a87a802d6b69b5afd9); /* line */ \n        coverage_0xde509cdf(0x7bf856020af18145756bc716948f7490b843173009e44b1bf6fc93a37f5d5e95); /* statement */ \nfor (uint indexOfNodes = 0; indexOfNodes < nodes.length; indexOfNodes++) {\ncoverage_0xde509cdf(0x3b6e3ca67adec48aad1d76e1f194ad4ac5ec441b3cb9aea2cc57a8c46ef8a147); /* line */ \n            coverage_0xde509cdf(0xac4858433125d351303450b41080a3eba29916e237a886738a2186e1f5f4ce72); /* statement */ \nif (nodeIndexes[msg.sender].isNodeExist[indexOfNodes] && isNodeActive(indexOfNodes)) {coverage_0xde509cdf(0x4bf23cf7202826553c56f17fd806cd289c39cd954364d43f1a090139d323c4b2); /* branch */ \n\ncoverage_0xde509cdf(0x596c219e979520146796a1f6c7bec437b9cd24252507b000b097209ec878064a); /* line */ \n                coverage_0xde509cdf(0x098aec764ebcb1eabc8ef6185b6b7db1a92dcb52c3faa0f66e2e8083e8d5f67e); /* statement */ \nactiveNodesByAddress[indexOfActiveNodesByAddress] = indexOfNodes;\ncoverage_0xde509cdf(0x28c90d72961706c050f8a8ac1bc53775c4fac3d7977ddcb4dc69500304cedc04); /* line */ \n                indexOfActiveNodesByAddress++;\n            }else { coverage_0xde509cdf(0x5d97234a3b2728e6900baf89bc8facb944a97d7474c82d3e44aa1816e98f43aa); /* branch */ \n}\n        }\n    }\n\n    // function getActiveFractionalNodes() external view returns (uint[] memory) {\n    //     uint[] memory activeFractionalNodes = new uint[](fractionalNodes.length);\n    //     for (uint index = 0; index < fractionalNodes.length; index++) {\n    //         activeFractionalNodes[index] = fractionalNodes[index].nodeIndex;\n    //     }\n    //     return activeFractionalNodes;\n    // }\n\n    // function getActiveFullNodes() external view returns (uint[] memory) {\n    //     uint[] memory activeFullNodes = new uint[](fullNodes.length);\n    //     for (uint index = 0; index < fullNodes.length; index++) {\n    //         activeFullNodes[index] = fullNodes[index].nodeIndex;\n    //     }\n    //     return activeFullNodes;\n    // }\n\n    /**\n     * @dev getActiveNodeIds - get array of indexes of Active Nodes\n     * @return activeNodeIds - array of indexes of Active Nodes\n     */\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds) {coverage_0xde509cdf(0x9ab909bd3b5d6ac4e9ddb551407a05bf06cce93387fc6d251d68ff0d40128ef8); /* function */ \n\ncoverage_0xde509cdf(0x93daa3bbce1b38512ba54575f684db5e00bf3cd3acc46685beff17ff337cdd55); /* line */ \n        coverage_0xde509cdf(0x549608332c2679b46805f6cc434650b1200c0afd1cdfb1c809411fc15e943e79); /* statement */ \nactiveNodeIds = new uint[](numberOfActiveNodes);\ncoverage_0xde509cdf(0x79718ca6a62379619d97d73b25f9c700643d0562b364f13d0b66b637739efdb0); /* line */ \n        coverage_0xde509cdf(0xa1268e48113a3eff6d04c9b1a79a9e2ebae8a22113277c628f157754fdb44ea6); /* statement */ \nuint indexOfActiveNodeIds = 0;\ncoverage_0xde509cdf(0x4071f1945fa946e93cc7e92d4069f35feae1e5b7d98a86ecdd670df722d82d7e); /* line */ \n        coverage_0xde509cdf(0x11d98e1be6dac3d5eff568ce53543ef1e2989f2de66758f53cac5039c67e1058); /* statement */ \nfor (uint indexOfNodes = 0; indexOfNodes < nodes.length; indexOfNodes++) {\ncoverage_0xde509cdf(0x7b869ce0422b8f697bf63368c0451acae40cf7464378e78b8071b2cc1f0783bc); /* line */ \n            coverage_0xde509cdf(0xe9a34fded851beb3a47bcd388cda5fc2fbee9d863b34f57b6fd8394ccd3f4a31); /* statement */ \nif (isNodeActive(indexOfNodes)) {coverage_0xde509cdf(0x90c356f8b06c1cdf824a2e6984bca4780ad02cf91afb47a751c178b48c31f2a9); /* branch */ \n\ncoverage_0xde509cdf(0x7a2239e8d8379c5c2b13cef7407a4b1e33699174134d92dbcbe0974cf7330a55); /* line */ \n                coverage_0xde509cdf(0x0e0f372fab0770eac86ef3f061b1a5e9bf7ad3bb6417aedb40ffd2c09b5e8145); /* statement */ \nactiveNodeIds[indexOfActiveNodeIds] = indexOfNodes;\ncoverage_0xde509cdf(0xc849ee376225f26e5691b2f9c59d1b155eb5c72f00ab1b0cb7651cec03b2bcca); /* line */ \n                indexOfActiveNodeIds++;\n            }else { coverage_0xde509cdf(0x34605efedec07862d763b33251c5673ef9c641284a6e5f13172a2835752d937d); /* branch */ \n}\n        }\n    }\n\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus) {coverage_0xde509cdf(0x9cff4fcc4c275bdc1920779cf25b4e2e41aa1cdaf65ffe82fdd149db79d61aa5); /* function */ \n\ncoverage_0xde509cdf(0xfcda8f5ef7d7a48a1bcbe1cc0cae5c33b2c789bce408585c4dee15cf791d14dd); /* line */ \n        coverage_0xde509cdf(0xba9ae72f9ede79bf444216730dbde147ac92954c1f941de983a76c25cac1b07d); /* statement */ \nreturn nodes[nodeIndex].status;\n    }\n\n    /**\n     * @dev isNodeActive - checks if Node status Active\n     * @param nodeIndex - index of Node\n     * @return if Node status Active - true, else - false\n     */\n    function isNodeActive(uint nodeIndex) public view returns (bool) {coverage_0xde509cdf(0x9bdf9ec8c9483993694c200e2e0be8436f186242609220a5095f7c050352ed7f); /* function */ \n\ncoverage_0xde509cdf(0x7966499539bed2ae753cd5bd0c04ad0187b1809313418fed149dcab82e1e5cd3); /* line */ \n        coverage_0xde509cdf(0xa276523487ad45e9a359b71d0ac03337af3630c48b6200e8f485288159dedb47); /* statement */ \nreturn nodes[nodeIndex].status == NodeStatus.Active;\n    }\n\n    function moveNodeToNewSpaceMap(uint nodeIndex, uint8 newSpace) internal {coverage_0xde509cdf(0x2fcc596228afea8894303f7911cb1c2bae542db70061249b717428ceaf390d0c); /* function */ \n\ncoverage_0xde509cdf(0x65f32e628d3448a8ff710937dae4ec20fa17656e85fff56797b0e4850b04cddc); /* line */ \n        coverage_0xde509cdf(0x8a51039b0a2dec74c3920992572682b1e53b5a74aed601be8f0d4b0c89002ae1); /* statement */ \nuint8 previousSpace = spaceOfNodes[nodeIndex].freeSpace;\ncoverage_0xde509cdf(0xefd348c726d6ca80f65487cbfd0cfd76c6e3de23bdbfa912c81f3b322677b4c3); /* line */ \n        coverage_0xde509cdf(0x392dee8977d2b34b34be997a97236a8b3797fdabf8e084ee70c7044077b8e9af); /* statement */ \nuint indexInArray = spaceOfNodes[nodeIndex].indexInSpaceMap;\ncoverage_0xde509cdf(0x9ad7941195a8cbbbf0c3836731983155909522fa76cbfddf2ce0483fdef2d1f7); /* line */ \n        coverage_0xde509cdf(0xba2305aa290f7368ca44211a744eb24b7549c8aedf356bfaeb1e814a9f65f6c2); /* statement */ \nif (indexInArray < spaceToNodes[previousSpace].length - 1) {coverage_0xde509cdf(0x041601a72399f5d879179a38f5066c1fc689126fee7807cc2b501effceb075fa); /* branch */ \n\ncoverage_0xde509cdf(0xe7f4cc98c8e8ba5f6028fd9266fe137a8f18affbe7983c046e5cf10857e4c962); /* line */ \n            coverage_0xde509cdf(0xecd94b6788719f1b239333936080ea7312aec8ae303a14ace401bff60b02dedb); /* statement */ \nuint shiftedIndex = spaceToNodes[previousSpace][spaceToNodes[previousSpace].length - 1];\ncoverage_0xde509cdf(0x7e6e531bbb6cb570791e91b76b8bedb7df11d30abc06394465752af2920c1442); /* line */ \n            coverage_0xde509cdf(0xb165dbe2546589d4b82ab7110579a6ecc948a36a86df23f3e1c82335b03ba2a5); /* statement */ \nspaceToNodes[previousSpace][indexInArray] = shiftedIndex;\ncoverage_0xde509cdf(0x65156fdbf9b5136d3e337989f246a0c5b1c0003d9f06124ff43d0333b73cb1b5); /* line */ \n            coverage_0xde509cdf(0xb2f4bad0b45254e5cf229a98d851b43b991d213eceb1e6d8f38de546bbf11e89); /* statement */ \nspaceOfNodes[shiftedIndex].indexInSpaceMap = indexInArray;\ncoverage_0xde509cdf(0xebce857f161a8728ffee9ada0a0ca53b4678890074001b6822f30b44f21f793a); /* line */ \n            spaceToNodes[previousSpace].length--;\n        } else {coverage_0xde509cdf(0xd7c622009c89f8df880c94775fc446af475865d3bd47d9d782d896b226f61a66); /* branch */ \n\ncoverage_0xde509cdf(0x9df5cdf410be9b01c5c5308a7389904231726ebe7f6b4688e510d530188539d0); /* line */ \n            spaceToNodes[previousSpace].length--;\n        }\ncoverage_0xde509cdf(0xd50639b1f4cfaad6445ddaab984eb4d8e201cc19337abfa8490e28e635aad1aa); /* line */ \n        coverage_0xde509cdf(0xe5899c0fc205fc9f7ede689722c61f1e4249dcfb847a4191d25795dce12bcd19); /* statement */ \nspaceToNodes[newSpace].push(nodeIndex);\ncoverage_0xde509cdf(0x69b65336491aaa8284f990dc95e1487d7e33971ef723f04d936461ae78298a76); /* line */ \n        coverage_0xde509cdf(0x1e84672cc4d0f8a564dce73de82252152ec06caebb8edcf9ca8d7663248a847e); /* statement */ \nspaceOfNodes[nodeIndex].freeSpace = newSpace;\ncoverage_0xde509cdf(0x38634835b56f12a579317e86fcb23cb70fca707421492a63917e25f81fbb7445); /* line */ \n        coverage_0xde509cdf(0xed8b2d932480ba8a1175557f9052ad1cc7facdea1fe5316e30afaa583bab3584); /* statement */ \nspaceOfNodes[nodeIndex].indexInSpaceMap = spaceToNodes[newSpace].length - 1;\n    }\n}\n"
    },
    ".coverage_contracts/NodesFunctionality.sol": {
      "content": "/*\n    NodesFunctionality.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IConstants.sol\";\nimport \"./interfaces/INodesData.sol\";\nimport \"./interfaces/ISchainsData.sol\";\nimport \"./interfaces/INodesFunctionality.sol\";\nimport \"./NodesData.sol\";\n\n\n/**\n * @title NodesFunctionality - contract contains all functionality logic to manage Nodes\n */\ncontract NodesFunctionality is Permissions, INodesFunctionality {\nfunction coverage_0x5ed5e296(bytes32 c__0x5ed5e296) public pure {}\n\n\n    // informs that Node is created\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // informs that node is fully finished quitting from the system\n    event ExitCompleted(\n        uint nodeIndex,\n        address owner,\n        uint32 time,\n        uint gasSpend\n    );\n\n    // informs that owner starts the procedure of quitting the Node from the system\n    event ExitInited(\n        uint nodeIndex,\n        address owner,\n        uint32 startLeavingPeriod,\n        uint32 time,\n        uint gasSpend\n    );\n\n    /**\n     * @dev constructor in Permissions approach\n     * @param newContractsAddress needed in Permissions constructor\n    */\n    constructor(address newContractsAddress) Permissions(newContractsAddress) public {coverage_0x5ed5e296(0x3fbc0b7c852357b38f557f270543b93407b4a1455213814f5b03573b43998746); /* function */ \n\n\n    }\n\n    /**\n     * @dev createNode - creates new Node and add it to the NodesData contract\n     * function could be only run by SkaleManager\n     * @param from - owner of Node\n     * @param value - received amount of SKL\n     * @param data - Node's data\n     * @return nodeIndex - index of Node\n     */\n    function createNode(address from, uint value, bytes calldata data) external allow(\"SkaleManager\") returns (uint nodeIndex) {coverage_0x5ed5e296(0xec2890bbbb7916cde102a734eec7e4ed5a7ccc1c9514dfcaaa518a359ab99820); /* function */ \n\ncoverage_0x5ed5e296(0x6a58d96d314b1ae5113a73adb2d36ccf9140776d000e7d5c106c8af0cbd72637); /* line */ \n        coverage_0x5ed5e296(0xfd1a84ee1af4ed74b783e394a23bd6897fcd0003ff287f9ef728bc1b8248dcd0); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x5ed5e296(0x0ad704f913ccc22b5a41e06a33e828087126d8daa01851f48ee1372f8701a41d); /* line */ \n        coverage_0x5ed5e296(0xacc32023db3c981fc3a2be4b18f42cd7e0068f493ff225ccda2b91760595bbf7); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0x5ed5e296(0x2c35000cb99faae5d1c898c8a5e3caea2cbab8ea9d6dd6b5a6b7de4f314cd2d6); /* line */ \n        coverage_0x5ed5e296(0xc99a3a05dbc28d387c31b6d88d4732f0cd0c2b28f062f2b8c2f6ef1416d49d1b); /* assertPre */ \ncoverage_0x5ed5e296(0x115f927c7d2a09571ba283116c3fd47003987fb85af5acbfce111bc1e8a14054); /* statement */ \nrequire(value >= IConstants(constantsAddress).NODE_DEPOSIT(), \"Not enough money to create Node\");coverage_0x5ed5e296(0x2351dd55e881cad33425a7ae56562873eec7d8c874382a3dcdde0d59c90468a0); /* assertPost */ \n\ncoverage_0x5ed5e296(0xda2cfe64b79ada0aa14dd424360a5c660b9ccddae576a9927fd4fec44ac0cc52); /* line */ \n        coverage_0x5ed5e296(0x22c238823898e3396287c136d79581d5d49484f33a3cde10802417fe7e38c73c); /* statement */ \nuint16 nonce;\ncoverage_0x5ed5e296(0x0037475017097a98ad839fb06eed87a9e1da52819751ce5d1e77daaa758269ca); /* line */ \n        coverage_0x5ed5e296(0x80abd2f40583c88463c2528a3fc8e45af42b84e3380a8e12a2ca0e0d7cea5c55); /* statement */ \nbytes4 ip;\ncoverage_0x5ed5e296(0x7189ef5d582266f60f0f62833309cb476a287f34197eb82acd1586091ba37f4d); /* line */ \n        coverage_0x5ed5e296(0x1dea057caac35d71e56c467cbef82068a9decc11b5be99a7a0b4dc47210b9375); /* statement */ \nbytes4 publicIP;\ncoverage_0x5ed5e296(0x473aa3c4c09ae0f4bbf1b457dc4b800df3344e4a3adfc6cb03723e59182fe48c); /* line */ \n        coverage_0x5ed5e296(0x8cc46e3435ae1f40e8eb5cef8842c9b0d600e3327bbab37ddec3c2242f38a6fd); /* statement */ \nuint16 port;\ncoverage_0x5ed5e296(0xafeae4b8ec1114dc131f5efc107197d9bf85d01acf88469e28138bcbfbb4ee8b); /* line */ \n        coverage_0x5ed5e296(0x5c9482ed80e52836683dcd4c43015732b547c2c7008fdbc6dffa12e8c9716c7e); /* statement */ \nstring memory name;\ncoverage_0x5ed5e296(0x0d9a331ca2b3556193bd591b5723fa2cf8ee81300b9248d85e1c3881bdaa30e1); /* line */ \n        coverage_0x5ed5e296(0x5b8e331b66e206cbb70a3abd57b8748c7807683d4263bea41d140eb734c61f79); /* statement */ \nbytes memory publicKey;\n\n        // decode data from the bytes\ncoverage_0x5ed5e296(0x2b83f865bf83f1d171159c49e4201c947bace0cfb07a798224a5e2ace78a7a78); /* line */ \n        coverage_0x5ed5e296(0xf3e9d994008d2be3188fd5aa393f96f4d57f028d1d6d622e7a92c892795c30e9); /* statement */ \n(port, nonce, ip, publicIP) = fallbackDataConverter(data);\ncoverage_0x5ed5e296(0x9b2cad8da1b10f59b9885b9ac85add342db188a4d5752d23d608151a14093dec); /* line */ \n        coverage_0x5ed5e296(0x5a91c5e0221fc5c07884cc5d89633f696a586e13b50130a056bd5c498f8f5cf8); /* statement */ \n(publicKey, name) = fallbackDataConverterPublicKeyAndName(data);\n\n        // checks that Node has correct data\ncoverage_0x5ed5e296(0xb5296400e22ace353b1e350536c59b86446502ca162e221f467d6cf68ef9bc98); /* line */ \n        coverage_0x5ed5e296(0x60805de0c4b5d3403834566bc19e6a70f1a3aead7c8befe38aeb589d535a1539); /* assertPre */ \ncoverage_0x5ed5e296(0x8c3ffe911f8f7e828d840fc09c617c736ba96a4e22a052598f815546c6930d93); /* statement */ \nrequire(ip != 0x0 && !INodesData(nodesDataAddress).nodesIPCheck(ip), \"IP address is zero or is not available\");coverage_0x5ed5e296(0x655f65031acf5c1dab741de3d08a0e5a4a7964945e65076f7b15b198429e8f45); /* assertPost */ \n\ncoverage_0x5ed5e296(0xe4b0e4c54b4b893f9884084fddd07cc65939c7996110f7ec6f029573d5bb1e7f); /* line */ \n        coverage_0x5ed5e296(0x210074e3ed09bbfb3f084fe7273d89ea21ee39555d8e253d1ccd999610b8c222); /* assertPre */ \ncoverage_0x5ed5e296(0xc4e43852c1e458c11e1b5068888599d3545837c6c632e7eb7f769a4dc9cd1d0d); /* statement */ \nrequire(!INodesData(nodesDataAddress).nodesNameCheck(keccak256(abi.encodePacked(name))), \"Name has already registered\");coverage_0x5ed5e296(0xab8f16c0562d6809391b8bc2f556027a80ad9d4c4908a1f53b170cf0a2738aed); /* assertPost */ \n\ncoverage_0x5ed5e296(0x9160b96e2c26445ad45dd2377b9bde60b5fd77c2bc9cbc33acb8225e4543e19d); /* line */ \n        coverage_0x5ed5e296(0xf78ebe5562f647b66fc4b0ed08926d7d08045d01c93e9891777312fd6e7b1d0a); /* assertPre */ \ncoverage_0x5ed5e296(0x63bed56e7f486aeefc126d74b86f8386873568a8b7f364b66ee88b52ccb6f931); /* statement */ \nrequire(port > 0, \"Port is zero\");coverage_0x5ed5e296(0xdc01ab6d94a7bdfcf9a17c3817587bc9431e3baf90b299e898e69dac8d0291b6); /* assertPost */ \n\n\n        // adds Node to NodesData contract\ncoverage_0x5ed5e296(0xc8ea474dba114ea0085c667ed3713d213934f6c8a00e6ee3737f3db73fc6218f); /* line */ \n        coverage_0x5ed5e296(0xf3d5035c20817c56f033ac689718c743e4d522ebcdb9671df03ec1aba134f418); /* statement */ \nnodeIndex = INodesData(nodesDataAddress).addNode(\n            from,\n            name,\n            ip,\n            publicIP,\n            port,\n            publicKey);\n        // adds Node to Fractional Nodes or to Full Nodes\n        // setNodeType(nodesDataAddress, constantsAddress, nodeIndex);\n\ncoverage_0x5ed5e296(0x1b709eecb0ba8623f8ac0ff234400ee68d428946ff1e83bae62a28493475ef93); /* line */ \n        coverage_0x5ed5e296(0xe9e5fd469c42b041a0f5850788366ba574c3926431cb1b1f92aa7dd8983fc4a3); /* statement */ \nemit NodeCreated(\n            nodeIndex,\n            from,\n            name,\n            ip,\n            publicIP,\n            port,\n            nonce,\n            uint32(block.timestamp),\n            gasleft());\n    }\n\n    /**\n     * @dev removeNode - delete Node\n     * function could be only run by SkaleManager\n     * @param from - owner of Node\n     * @param nodeIndex - index of Node\n     */\n    function removeNode(address from, uint nodeIndex) external allow(\"SkaleManager\") {coverage_0x5ed5e296(0xd4ae075af5fcc9595881cec129a7e5422048b012ba00179214b760f15e4b3691); /* function */ \n\ncoverage_0x5ed5e296(0x6871fedab693dfea54b25c59293981dc6e9f1dcc79464faf94b97a2224cfc6ee); /* line */ \n        coverage_0x5ed5e296(0x514213128f103c616eef6fe0bcae8d39695b838f207b88b38ddd860de4e752c4); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\n\ncoverage_0x5ed5e296(0x6db96bf2bc39934d76669b07ac20e49f61768a6212dfb3ea239ce53b424d788d); /* line */ \n        coverage_0x5ed5e296(0xcffd48ef95facaa7a1a5901cb8d49bb9f4ea3bdfeabad7bac9527d5a01f791e6); /* assertPre */ \ncoverage_0x5ed5e296(0x219e331814e378a2a00b8737626c556ad8cf3dcc55eafc853624fe12257efc3a); /* statement */ \nrequire(INodesData(nodesDataAddress).isNodeExist(from, nodeIndex), \"Node does not exist for message sender\");coverage_0x5ed5e296(0x44aa8cf8a823418ad28a881e2394a79e0c17c96f58702350e2db33722d7fcb6f); /* assertPost */ \n\ncoverage_0x5ed5e296(0x56d0e0a7afeb61003791a625bcbf0050c264b47e8ecdcc6d5f2155ecd9c7d3a5); /* line */ \n        coverage_0x5ed5e296(0xbe1d2301a99a43bb764f7c53b5bf0b58468b34bb4f9e5150cc9a93c015641448); /* assertPre */ \ncoverage_0x5ed5e296(0xdb306be60db3f256e2c8f3040fd5b34cca4f9e90cb1b2013cc5c874e08e321dd); /* statement */ \nrequire(INodesData(nodesDataAddress).isNodeActive(nodeIndex), \"Node is not Active\");coverage_0x5ed5e296(0x3e162bfaace2a0d17b26e71e46487b3c9cec03c9c26ab53ee894e2f50f14375b); /* assertPost */ \n\n\ncoverage_0x5ed5e296(0x92ff9ecfa38aa4618371214d017170816cf87ba8e6f918bff2d4b3d070dd35d9); /* line */ \n        coverage_0x5ed5e296(0x1fbaa55593d0c0fdecc3f8c5058e76663a120e5d5620a6b12daf469c45f3b7b3); /* statement */ \nINodesData(nodesDataAddress).setNodeLeft(nodeIndex);\n\ncoverage_0x5ed5e296(0xfddc7300ba1aa3f3a77d50818ccc4262967668d358c49a131f720d3b04c8a694); /* line */ \n        coverage_0x5ed5e296(0xc810cb4f6c1687366bd5755647b8ea94bc0ab591548b43af9a90e6d74cad4aa3); /* statement */ \nINodesData(nodesDataAddress).removeNode(nodeIndex);\n    }\n\n    function removeNodeByRoot(uint nodeIndex) external allow(\"SkaleManager\") {coverage_0x5ed5e296(0xc4207327ce4f3ed16eead426b5e160cdbc2dd45d73382e4b10fb54aba83d04ea); /* function */ \n\ncoverage_0x5ed5e296(0x6a32660c9373372e6ce95b982c58be76231f625e80ddf11f123574f18566c2ab); /* line */ \n        coverage_0x5ed5e296(0x5a8b7330108201a7c42820a67cc570ccfb598e5e83b2007a0a1c6a5a638958c9); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x5ed5e296(0x556e56b846453b2787238946f4025cd61bff498f41ea28a88fe0922e3ea8631a); /* line */ \n        coverage_0x5ed5e296(0x407de46585cbcc777970b064192f3e77e197c342c5f3c06c1063e21a8adf6777); /* statement */ \nINodesData(nodesDataAddress).setNodeLeft(nodeIndex);\n\ncoverage_0x5ed5e296(0xb6eae102590f46c4ed367cfef1b06146324341b4d2737a7011b2c3c39e594899); /* line */ \n        coverage_0x5ed5e296(0x5e98c1efab784305239368ec023d7c903852e201534aaf5b65482c53b8e65671); /* statement */ \nINodesData(nodesDataAddress).removeNode(nodeIndex);\n    }\n\n    /**\n     * @dev initExit - initiate a procedure of quitting the system\n     * function could be only run by SkaleManager\n     * @param from - owner of Node\n     * @param nodeIndex - index of Node\n     * @return true - if everything OK\n     */\n    function initExit(address from, uint nodeIndex) external allow(\"SkaleManager\") returns (bool) {coverage_0x5ed5e296(0xb4457a0c159cb6560402f961e52bb603a1357b50df1b89dbe183ee8df0581341); /* function */ \n\ncoverage_0x5ed5e296(0x667f5ed2fe04bbadab43033e6224cc9533054c019c71c840b246aba934a50710); /* line */ \n        coverage_0x5ed5e296(0x89a0bd684badf9137b11d8b6080dbb53e36d7ab1b0666598698b8f9dbd3c5fc6); /* statement */ \nNodesData nodesData = NodesData(contractManager.getContract(\"NodesData\"));\n\n        // require(validatorService.validatorAddressExists(from), \"Validator with such address doesn't exist\");\ncoverage_0x5ed5e296(0x1ce32859826782e2962204927e951805dcc11ed668569506b8297969338afb67); /* line */ \n        coverage_0x5ed5e296(0xbe3e7e8b77fde9e61a3e98ce13157e34cfe86fb7d9fe607732ad4ed786da8314); /* assertPre */ \ncoverage_0x5ed5e296(0x9d444e060a269efa82276ae8f2e4ed69b7ccd3ad5c715909b141d56f41191b9e); /* statement */ \nrequire(nodesData.isNodeExist(from, nodeIndex), \"Node does not exist for message sender\");coverage_0x5ed5e296(0xcb94c118e89f4af9b7155af2694c245e1ccbd75af7aee9060b70ce959817f485); /* assertPost */ \n\n\ncoverage_0x5ed5e296(0x6aea1377fa5a491090d48554f1d6e04b882f1434c9b6eeb04c79d1ce0f8311c6); /* line */ \n        coverage_0x5ed5e296(0x3e1f8a837517638fc7e658da082ded297d83b8360d1275fa895ab2af2aa230e4); /* statement */ \nnodesData.setNodeLeaving(nodeIndex);\n\ncoverage_0x5ed5e296(0xe23ed8dbb0143aea7a16cedd1b49b2d68b041e264f3acf45c8670ab55c7ebfc9); /* line */ \n        coverage_0x5ed5e296(0x6fa1b6b576a5f3fd6887fe6d3186e6da69a591e596b1d5b1a74fd839ed293407); /* statement */ \nemit ExitInited(\n            nodeIndex,\n            from,\n            uint32(block.timestamp),\n            uint32(block.timestamp),\n            gasleft());\ncoverage_0x5ed5e296(0xb3b0a30e1f2fa65766500b26e2216bb550333b99fe6538bd71b1fed261544105); /* line */ \n        coverage_0x5ed5e296(0xc7ff29489cb0131305e34bff6688760eb1b3254b6fc7fcd3d512b9d4a1337329); /* statement */ \nreturn true;\n    }\n\n    /**\n     * @dev completeExit - finish a procedure of quitting the system\n     * function could be run only by SkaleMManager\n     * @param from - owner of Node\n     * @param nodeIndex - index of Node\n     * @return amount of SKL which be returned\n     */\n    function completeExit(address from, uint nodeIndex) external allow(\"SkaleManager\") returns (bool) {coverage_0x5ed5e296(0x9960b1478efcee5f9117c21c5a96d19c7f956147d1ba21295ea1684e3ad8bfb0); /* function */ \n\ncoverage_0x5ed5e296(0xb60a4510764ce78636b183f90130050cd28e6f26740b4f8b7f99a37c19d901a4); /* line */ \n        coverage_0x5ed5e296(0x1a33b2343b8b5e45cfc59a6d22f4c1872a523391bb8669d9b8ec27de2b891e43); /* statement */ \nNodesData nodesData = NodesData(contractManager.getContract(\"NodesData\"));\n\n        // require(validatorService.validatorAddressExists(from), \"Validator with such address doesn't exist\");\ncoverage_0x5ed5e296(0xb7c5d63f66f9ef8dd51e55c155739c4e6b40cb4b6e625a9dd2536de074929fd3); /* line */ \n        coverage_0x5ed5e296(0xfebb7651f9655de79969e50757c8c3e2a7ca38e16a91ae252720219eb375919a); /* assertPre */ \ncoverage_0x5ed5e296(0x6ee387c1bb94e78cec7f2d004d5488ae654424decb20792f657f69c5a29b1162); /* statement */ \nrequire(nodesData.isNodeExist(from, nodeIndex), \"Node does not exist for message sender\");coverage_0x5ed5e296(0xfc2319f866753913a4c95a2d60d436587f35c7a5763a6a93bec4b0958a020803); /* assertPost */ \n\ncoverage_0x5ed5e296(0x46748d25689fdcba4f4a9c4ea71137eec6e08ea887989c47f964b4f10a95d627); /* line */ \n        coverage_0x5ed5e296(0x458548b5de06f89035b5ad18b8bf45858b55ce2043e262345f164ced0e80c0a0); /* assertPre */ \ncoverage_0x5ed5e296(0x81a64dc0ee3dc4dcd934134a3b48af37194e75b13ac5a7b1235d7361d2b22464); /* statement */ \nrequire(nodesData.isNodeLeaving(nodeIndex), \"Node is not Leaving\");coverage_0x5ed5e296(0x101a3564f595981ffefbb5ea6df5874cb4092c64a2e5098357c23138b095a735); /* assertPost */ \n\n\ncoverage_0x5ed5e296(0x2e5d35877ace687a92b8947291db3d87fb67b11e1b80c9cf1d4921b4e657be17); /* line */ \n        coverage_0x5ed5e296(0x6e7378f7140b83090c318fd2ac948f87a6dfb6e45cc83119bdfbbe217fafd4af); /* statement */ \nnodesData.setNodeLeft(nodeIndex);\n\ncoverage_0x5ed5e296(0x13e2f9a69d7a234873ecc52357e187458580ec141a16676cecbf6b8c7c8c1e32); /* line */ \n        coverage_0x5ed5e296(0xc28cb1686f5d1305f9466a0f48df6007de2031d6419a4d04b52f47f440b1ecde); /* statement */ \nnodesData.removeNode(nodeIndex);\n\ncoverage_0x5ed5e296(0xd27798696bfe394e0a771ddff60293b448b7f70eb02b02603a564669fc9d1e2c); /* line */ \n        coverage_0x5ed5e296(0x0a227b31db5144f6d3860cbbd54a44700cbda423397e03b1e5cbd61349aa9f1a); /* statement */ \nemit ExitCompleted(\n            nodeIndex,\n            from,\n            uint32(block.timestamp),\n            gasleft());\ncoverage_0x5ed5e296(0x1b68cef4b88df92c2375daf10d0cfeaaa7113b03fb295ed70b1422f125512bd5); /* line */ \n        coverage_0x5ed5e296(0xae05e8718aaf4bd085d2a1f9cfb5ef4a1228afebbbdeb42620dfe21a4032d606); /* statement */ \nreturn true;\n    }\n\n    // /**\n    //  * @dev setNodeType - sets Node to Fractional Nodes or to Full Nodes\n    //  * @param nodesDataAddress - address of NodesData contract\n    //  * @param constantsAddress - address of Constants contract\n    //  * @param nodeIndex - index of Node\n    //  */\n    // function setNodeType(address nodesDataAddress, address constantsAddress, uint nodeIndex) internal {\n    //     bool isNodeFull = (\n    //         INodesData(nodesDataAddress).getNumberOfFractionalNodes() *\n    //         IConstants(constantsAddress).FRACTIONAL_FACTOR() >\n    //         INodesData(nodesDataAddress).getNumberOfFullNodes() *\n    //         IConstants(constantsAddress).FULL_FACTOR()\n    //     );\n\n    //     if (INodesData(nodesDataAddress).getNumberOfFullNodes() == 0 || isNodeFull) {\n    //         INodesData(nodesDataAddress).addFullNode(nodeIndex);\n    //     } else {\n    //         INodesData(nodesDataAddress).addFractionalNode(nodeIndex);\n    //     }\n    // }\n\n    /**\n     * @dev setSystemStatus - sets current system status overload, normal or underload\n     * @param constantsAddress - address of Constants contract\n     */\n    /*function setSystemStatus(address constantsAddress) internal {\n        address dataAddress = ContractManager(contractsAddress).contracts(keccak256(abi.encodePacked(\"NodesData\")));\n        address schainsDataAddress = ContractManager(contractsAddress).contracts(keccak256(abi.encodePacked(\"SchainsData\")));\n        uint numberOfNodes = 128 * (INodesData(dataAddress).numberOfActiveNodes() + INodesData(dataAddress).numberOfLeavingNodes());\n        uint numberOfSchains = ISchainsData(schainsDataAddress).sumOfSchainsResources();\n        if (4 * numberOfSchains / 3 < numberOfNodes && !(4 * numberOfSchains / 3 < (numberOfNodes - 1))) {\n            IConstants(constantsAddress).setLastTimeUnderloaded();\n        }\n    }*/\n\n    /**\n     * @dev coefficientForPrice - calculates current coefficient for Price\n     * coefficient calculates based on system status duration\n     * @param constantsAddress - address of Constants contract\n     * @return up - dividend\n     * @return down - divider\n     */\n    /*function coefficientForPrice(address constantsAddress) internal view returns (uint up, uint down) {\n        address dataAddress = ContractManager(contractsAddress).contracts(keccak256(abi.encodePacked(\"NodesData\")));\n        address schainsDataAddress = ContractManager(contractsAddress).contracts(keccak256(abi.encodePacked(\"SchainsData\")));\n        uint numberOfDays;\n        uint numberOfNodes = 128 * (INodesData(dataAddress).numberOfActiveNodes() + INodesData(dataAddress).numberOfLeavingNodes());\n        uint numberOfSchains = ISchainsData(schainsDataAddress).sumOfSchainsResources();\n        if (20 * numberOfSchains / 17 > numberOfNodes) {\n            numberOfDays = (now - IConstants(constantsAddress).lastTimeOverloaded()) / IConstants(constantsAddress).SECONDS_TO_DAY();\n            up = binstep(99, numberOfDays, 100);\n            down = 100;\n        } else if (4 * numberOfSchains / 3 < numberOfNodes) {\n            numberOfDays = (now - IConstants(constantsAddress).lastTimeUnderloaded()) / IConstants(constantsAddress).SECONDS_TO_DAY();\n            up = binstep(101, numberOfDays, 100);\n            down = 100;\n        } else {\n            up = 1;\n            down = 1;\n        }\n    }*/\n\n    /**\n     * @dev binstep - exponentiation by squaring by modulo (a^step)\n     * @param a - number which should be exponentiated\n     * @param step - exponent\n     * @param div - divider of a\n     * @return x - result (a^step)\n     */\n    /*function binstep(uint a, uint step, uint div) internal pure returns (uint x) {\n        x = div;\n        while (step > 0) {\n            if (step % 2 == 1) {\n                x = mult(x, a, div);\n            }\n            a = mult(a, a, div);\n            step /= 2;\n        }\n    }*/\n\n    /*function mult(uint a, uint b, uint div) internal pure returns (uint) {\n        return (a * b) / div;\n    }*/\n\n    /**\n     * @dev fallbackDataConverter - converts data from bytes to normal parameters\n     * @param data - concatenated parameters\n     * @return port\n     * @return nonce\n     * @return ip address\n     * @return public ip address\n     */\n    function fallbackDataConverter(bytes memory data)\n        private\n        pure\n        returns (uint16, uint16, bytes4, bytes4 /*address secondAddress,*/)\n    {coverage_0x5ed5e296(0xfe5bae39987bd513127f24d3c8fe1e96b6e723131ecba44c7f6b752259a2dbd9); /* function */ \n\ncoverage_0x5ed5e296(0xc6582b9397cc58665c607321886b83be2f91c4ead4e2f79827984dd6600ff432); /* line */ \n        coverage_0x5ed5e296(0x4edc718c8fc5356b7541e673dab0c8d9597bddcba5d20483262ee3cd7baea433); /* assertPre */ \ncoverage_0x5ed5e296(0xfc37a80d3bfec2778f1ecdc7470d449372b31659d61f3826573b1d3f95ad2651); /* statement */ \nrequire(data.length > 77, \"Incorrect bytes data config\");coverage_0x5ed5e296(0x457b2e96d2b7fac9fc65dcc04e2f5f6ea6b47d421ee0697324de51c1e2fc745f); /* assertPost */ \n\n\ncoverage_0x5ed5e296(0xe4efbcb518e9f87bb664d8d2cdc8b2e782d6c4792f681860f5e543f7682647df); /* line */ \n        coverage_0x5ed5e296(0x25a072cd8d40a9dc89ed5021882a10782b650c49ac3756d2c6745c10a756449b); /* statement */ \nbytes4 ip;\ncoverage_0x5ed5e296(0x430ee764a45e5631648d52069675dc6205e3510495796408448728f381f0d03a); /* line */ \n        coverage_0x5ed5e296(0x5b0d12eb3f8e6dd76a60c2f14c12b42483e0b7d988319effe03de7c701d86a91); /* statement */ \nbytes4 publicIP;\ncoverage_0x5ed5e296(0xb70b24fbc152903c97de6003a5e7ff1d5862a833f93a002d8e38a5706d13864c); /* line */ \n        coverage_0x5ed5e296(0xdf0bc115776cfc4f722b494b27c8a9947a180698fded7a569aaa4ca08f0acf41); /* statement */ \nbytes2 portInBytes;\ncoverage_0x5ed5e296(0x96b052e8a36a9ed877a08dda15a8b7230ab62d4901deeba37a4c645d95b15c21); /* line */ \n        coverage_0x5ed5e296(0x8f4538cacdfec1ac69c562865d8ef71f8b604afa52e0385919c54539583bfd3a); /* statement */ \nbytes2 nonceInBytes;\ncoverage_0x5ed5e296(0xa74d165b4059e9b77ce624be93328001d2f1527bd7a30afcd9256fa2254d22c8); /* line */ \n        assembly {\n            portInBytes := mload(add(data, 33)) // 0x21\n            nonceInBytes := mload(add(data, 35)) // 0x25\n            ip := mload(add(data, 37)) // 0x29\n            publicIP := mload(add(data, 41))\n        }\n\ncoverage_0x5ed5e296(0xcdc351296fcc628bf511d09b3a56527642e3f347512a8b311145f62ebc718696); /* line */ \n        coverage_0x5ed5e296(0x18694ecd514e58ec87abde641fd632085590a95fa46bdc44c36505f070b86750); /* statement */ \nreturn (uint16(portInBytes), uint16(nonceInBytes), ip, publicIP);\n    }\n\n    /**\n     * @dev fallbackDataConverterPublicKeyAndName - converts data from bytes to public key and name\n     * @param data - concatenated public key and name\n     * @return public key\n     * @return name of Node\n     */\n    function fallbackDataConverterPublicKeyAndName(bytes memory data) private pure returns (bytes memory, string memory) {coverage_0x5ed5e296(0x11ba3fd189092c91b95b0b3be0466047ab1b6efa5c1799e04f978bec6bff6c64); /* function */ \n\ncoverage_0x5ed5e296(0x9844fb8b14af0605f34715797eb1b641321d5100143af9cf58a74c25131ec1d6); /* line */ \n        coverage_0x5ed5e296(0xf178f2838cab04df373b61dfe422366142721e342d01b100ec7b0cdc7ffcb1af); /* assertPre */ \ncoverage_0x5ed5e296(0xf218f0d1651bf72c40ad442c90959e13d21f1f3f0b5d92a7c6b7a646c93053a6); /* statement */ \nrequire(data.length > 77, \"Incorrect bytes data config\");coverage_0x5ed5e296(0xdf353aea05ca972ff5fc8fabdd52d0661f19f577a21802261557f754d69451ba); /* assertPost */ \n\ncoverage_0x5ed5e296(0x5ec839758a93c5f79fd16112aa4a68c8177f28c5206727f293ed0dc967ced293); /* line */ \n        coverage_0x5ed5e296(0xb28863213da813b2b6224fb2a92471ef35cc37da010b2c0024630e84c87b25fe); /* statement */ \nbytes32 firstPartPublicKey;\ncoverage_0x5ed5e296(0x74a95533dd443eeff4f3fc11ad785b154d06f78705cba7d06adaf9bb8fd81000); /* line */ \n        coverage_0x5ed5e296(0x3b6c6ef1c43d94cbcbfbe85c544c5743d475ad5d85e76d48ab0d521930810996); /* statement */ \nbytes32 secondPartPublicKey;\ncoverage_0x5ed5e296(0x1ee0aeedbc72a5db1a09511fde12a0699dea6cdfd032108c14957ec28cedd2d2); /* line */ \n        coverage_0x5ed5e296(0xb76fa14b76a385097f2c386545b9194a30ae4cdb5338112e5044aabda14a593d); /* statement */ \nbytes memory publicKey = new bytes(64);\n\n        // convert public key\ncoverage_0x5ed5e296(0x1d4089beeecde12fa24d85d74e7ee2c667c99cc26542b7b4af23ab74ec774659); /* line */ \n        assembly {\n            firstPartPublicKey := mload(add(data, 45))\n            secondPartPublicKey := mload(add(data, 77))\n        }\ncoverage_0x5ed5e296(0x5a47ad29653fd3b1433033cbda70bda249e2d3e653e6150b08b40103a92db491); /* line */ \n        coverage_0x5ed5e296(0x6a58579248ce032285f992d3061f21c0389576757d8ad7e2050486f477b12900); /* statement */ \nfor (uint8 i = 0; i < 32; i++) {\ncoverage_0x5ed5e296(0x633021525db0706750925dbf64549352ccddf89fae4be9b12884e17397bbce16); /* line */ \n            coverage_0x5ed5e296(0xbef489008220435dc2c0f8c2d17ecb11a1e15d74b58f72040c109dffd432c5ff); /* statement */ \npublicKey[i] = firstPartPublicKey[i];\n        }\ncoverage_0x5ed5e296(0x44ca5d911d730fe2e469735fa5e5319cfaef3e7742f09e62b439e08a5a19c0ee); /* line */ \n        coverage_0x5ed5e296(0x6497ccb5d78ae21abcbd3f586f13c4e397b2c17a83fe8235b8f558e210175747); /* statement */ \nfor (uint8 i = 0; i < 32; i++) {\ncoverage_0x5ed5e296(0x81f2a74f50c78afbf92a7bbcc55bc6a93c81219e1cf391ed5b53020d6e04903c); /* line */ \n            coverage_0x5ed5e296(0x27e88ea0fff465a6d0bd0f0e2077823964dff3a5a2efbd2ff2bc57c837802a36); /* statement */ \npublicKey[i + 32] = secondPartPublicKey[i];\n        }\n\n        // convert name\ncoverage_0x5ed5e296(0xd87bc4571373cf75eba6042d1ba3b2ca0982d143d88e99f1083fa13560271ac8); /* line */ \n        coverage_0x5ed5e296(0x6cc61d379e5dc62d83c54caa12bcfdde90eeb45f6eab99ac35837632302cf4d5); /* statement */ \nstring memory name = new string(data.length - 77);\ncoverage_0x5ed5e296(0x97ecfd5c7ecfc65682be7491e7d94c3576f63819e12850da26a6c6035b87f7a7); /* line */ \n        coverage_0x5ed5e296(0x7d60c61c2a07d7ddf4ef4d13ebd7206836aacd8e0eeb1476cdde4b5a518e4f7f); /* statement */ \nfor (uint i = 0; i < bytes(name).length; ++i) {\ncoverage_0x5ed5e296(0x1613eef60aed71fe7cdf54afde071068ba372c266bdb8dd947b99e407d7f668b); /* line */ \n            coverage_0x5ed5e296(0x6b64a5ca69639b11d3fa78977f96cd74a125eb8fe47b483388fb92001a85a76c); /* statement */ \nbytes(name)[i] = data[77 + i];\n        }\ncoverage_0x5ed5e296(0x3d437b762817a31c3697546ebe8907f0b83668e84956ed9838a588479547202d); /* line */ \n        coverage_0x5ed5e296(0x696702ed42bb8bd958ca533dfca946cc2256fa66b468327cbb2c6c75367769aa); /* statement */ \nreturn (publicKey, name);\n    }\n\n}\n"
    },
    ".coverage_contracts/Pricing.sol": {
      "content": "/*\n    Pricing.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/ISchainsData.sol\";\nimport \"./interfaces/IGroupsData.sol\";\nimport \"./interfaces/INodesData.sol\";\n\n\ncontract Pricing is Permissions {\nfunction coverage_0x5e187ee9(bytes32 c__0x5e187ee9) public pure {}\n\n    uint public constant OPTIMAL_LOAD_PERCENTAGE = 80;\n    uint public constant ADJUSTMENT_SPEED = 1000;\n    uint public constant COOLDOWN_TIME = 60;\n    uint public constant MIN_PRICE = 10**6;\n    uint public price = 5*10**6;\n    uint public totalNodes;\n    uint lastUpdated;\n\n\n\n    constructor(address newContractsAddress) Permissions(newContractsAddress) public {coverage_0x5e187ee9(0x1534456a8973f1c7b0d66388276fc0414ff6f4e1ee6ca349e9770994bd2a4020); /* function */ \n\ncoverage_0x5e187ee9(0x34de4df08e1abf15673e41914688ff7f752f0525e069b6344076bcecbb5acd52); /* line */ \n        coverage_0x5e187ee9(0xb489047486210547c90061809b5f2ac6240628d274c59c50f0a7c8d0f7cd6dfd); /* statement */ \nlastUpdated = now;\n    }\n\n    function initNodes() external {coverage_0x5e187ee9(0x36526cca796d722dbd189d5ade03ec7094026c8918ff260690133935be034d0e); /* function */ \n\ncoverage_0x5e187ee9(0xf08a844b19426f839352779c5b4733dbfcd2cefe024c50ce2f5cc8ddb7942d94); /* line */ \n        coverage_0x5e187ee9(0x47134875adbc8b9f2264e3f7d44182fc9f816a20d918fdc6843c33e2f4d10504); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x5e187ee9(0x09a92a00f1418574f8ac9b159b5669378bd8e5a39243dc1fa9211023fc5f9ed7); /* line */ \n        coverage_0x5e187ee9(0xf55c18e051bdc0af6880c21f7eb7ecf5fa03bbd19e2846f8c0cabd6e4794cb0d); /* statement */ \ntotalNodes = INodesData(nodesDataAddress).getNumberOnlineNodes();\n    }\n\n    function adjustPrice() external {coverage_0x5e187ee9(0xb9624062f844adac55fa0ede06cf7fb22d9f202099bb846d5d67e3f456913422); /* function */ \n\ncoverage_0x5e187ee9(0x75c67b29c6e4518c7d1f3c227d3c1db12a5926a2210fbdb5759cd64c119d0fba); /* line */ \n        coverage_0x5e187ee9(0xe5a63216a7a32e8c168343790192eed38bcc08d52002e22bb7dc0f6c65d8f3af); /* assertPre */ \ncoverage_0x5e187ee9(0x13c090027d99c7a7c9591bafd0ecd5855350cb35c574c51dc3e9b628ad340020); /* statement */ \nrequire(now > lastUpdated + COOLDOWN_TIME, \"It's not a time to update a price\");coverage_0x5e187ee9(0xef4f3ca7fca0e92161da6bcdbc801a65af0230920d53b98de55b7451a8ac0a8d); /* assertPost */ \n\ncoverage_0x5e187ee9(0xb96e3d4fae146cba25e0ce7cbd91f776e4a54d72ff9708d88ececd7820ad9c3b); /* line */ \n        coverage_0x5e187ee9(0x867a9f1a00f59b6beb0c3161991d1549e6940462d5590d834da2527cd4594cdf); /* statement */ \ncheckAllNodes();\ncoverage_0x5e187ee9(0xc677f5be0edf311b350f88a9f36d5af21978c4392c3f594ee1be9c6f9019e37a); /* line */ \n        coverage_0x5e187ee9(0x9c51dbc8fb7c2526efb674a29fcce946427e30b8e853ae831b173c0f57198873); /* statement */ \nuint loadPercentage = getTotalLoadPercentage();\ncoverage_0x5e187ee9(0x3ada6fc89a81e0b5e4eb48b470699f1d58ee272abfb01f31fb684004ae8b852c); /* line */ \n        coverage_0x5e187ee9(0xdc59002b48c638fb617da044beed10d4a8b51219f1e150ee8ccd1268124b1db1); /* statement */ \nuint priceChange;\ncoverage_0x5e187ee9(0x9b712d2bf46aa378c7ab1ffe16d957d48c3c972b237bb1726ae159e76d96b65f); /* line */ \n        coverage_0x5e187ee9(0xd11c8b25a368a718ad3018eea7c358740681a75b1fa1671a670c65b43d21dece); /* statement */ \nuint timeSkipped;\n\ncoverage_0x5e187ee9(0xdfe1b5dd489ce5df79725415c83726d0cfafebc38a6c24322735df6beddcfd76); /* line */ \n        coverage_0x5e187ee9(0xaeabb3ec850e47cd81a113d201cb2bf297658d2eba2fcfce778a874bcd942539); /* statement */ \nif (loadPercentage < OPTIMAL_LOAD_PERCENTAGE) {coverage_0x5e187ee9(0xfc6834136696df8a26598da3fbdd06eda9cb644a1dd3ec39b54f467ff56ac324); /* branch */ \n\ncoverage_0x5e187ee9(0x96b87ee13cf5531f7a5af0b3c4c88a2af91b7049f2ced9df4ad95ef036eb0b1a); /* line */ \n            coverage_0x5e187ee9(0x3c5b4ce25a40db4e0f01edaf20414ac64f9156a23bbb606394bb50bf66d7434f); /* statement */ \npriceChange = (ADJUSTMENT_SPEED * price) * (OPTIMAL_LOAD_PERCENTAGE - loadPercentage) / 10**6;\ncoverage_0x5e187ee9(0x83f1537e5b8f9b7b51e868e684acbfa3df605ba260a379f52fd98a7db7997ce3); /* line */ \n            coverage_0x5e187ee9(0x9408574c7e729fd6b32b2da496441b6f0c96501e48ae79948e0941378ed5d1fe); /* statement */ \ntimeSkipped = (now - lastUpdated) / COOLDOWN_TIME;\ncoverage_0x5e187ee9(0x9251be5abfe974af99e381e76f3c9027a31acf88a5b45ea7a57abad89c8c1ab8); /* line */ \n            coverage_0x5e187ee9(0xbc79817b329130ab4b657baaa1e27912d142a47b54b70da0a93f9170ce7551c8); /* assertPre */ \ncoverage_0x5e187ee9(0xc35369eef5800502bc5f50ad434490fca5517d694b588696d2bf2bf56dd7efb7); /* statement */ \nrequire(price - priceChange * timeSkipped < price, \"New price should be less than old price\");coverage_0x5e187ee9(0x4c32cd0aa370ab7a6df9639396f2f939fa7b9a5cac1febebec269f0ae7b5f3df); /* assertPost */ \n\ncoverage_0x5e187ee9(0x16031ca8c07474b0c3f35eebaaa703493826328527fd7c8bfd94ec51e98cee66); /* line */ \n            coverage_0x5e187ee9(0xd1adb4f60dba2dcd032987b805e8428e762fea04bd4661456aa7bdb18a5f0b66); /* statement */ \nprice -= priceChange * timeSkipped;\ncoverage_0x5e187ee9(0xf59014295bf2d46a2a2935256cc46639792fc967da8c3537bd4fed8c11953327); /* line */ \n            coverage_0x5e187ee9(0xaf22c810b249ee6656f8d93eda8d6df889f0da9de791cd7e9ef014e371fc7556); /* statement */ \nif (price < MIN_PRICE) {coverage_0x5e187ee9(0xa7972afb85470ff2ce0124f312180be370ead8b66218cd1f33c5bcd29adb7c37); /* branch */ \n\ncoverage_0x5e187ee9(0xc22a8411f9cd1031aaafc2cb8e69139bb01258f714e55ee54c6f3f7eeb449608); /* line */ \n                coverage_0x5e187ee9(0xcbf6e123739dcd15e20509bd8b34998bb6cf7dd46ce9404a8657ad7c75288af6); /* statement */ \nprice = MIN_PRICE;\n            }else { coverage_0x5e187ee9(0xc409ce4df44611f393ec8e37f44ca6398ca68709063018d407bbfe26d6d8e2a0); /* branch */ \n}\n        } else {coverage_0x5e187ee9(0xf0162e302c4bf1b60978b9063ce8e0cde06e44d38a2d751ec7c73f709525a312); /* branch */ \n\ncoverage_0x5e187ee9(0x2e580eadfe6315cc8be0f863c52b2f8f1c40f2faadab5cbdbbf311892e125362); /* line */ \n            coverage_0x5e187ee9(0xd8b5083e7d09193ae9591f803b4fad8ce54693fd8a3f8589a79d301d548e291a); /* statement */ \npriceChange = (ADJUSTMENT_SPEED * price) * (loadPercentage - OPTIMAL_LOAD_PERCENTAGE) / 10**6;\ncoverage_0x5e187ee9(0x20a32d785f5a4e691249e98690de9c3f7d909f937e70047965e7538fc923a300); /* line */ \n            coverage_0x5e187ee9(0x510d07b55d28a79ad46dbc6a7ab56607c6de9cd93c0eba56612b67a1f8b4ce49); /* statement */ \ntimeSkipped = (now - lastUpdated) / COOLDOWN_TIME;\ncoverage_0x5e187ee9(0xd5f431b5e69ca3f558a3dc9e1e463595b5b0c287ae4a3ba25238cef2558c102a); /* line */ \n            coverage_0x5e187ee9(0x743d4b8999c2e0d96c8b3e2a63fe96cc7f1414837b9fe4bded96a473fdb5f9f3); /* assertPre */ \ncoverage_0x5e187ee9(0x0e5fd951638473236a2319cc6bab94a57b18900a1e90204235f0ba8da8638231); /* statement */ \nrequire(price + priceChange * timeSkipped > price, \"New price should be greater than old price\");coverage_0x5e187ee9(0x91e1b23a0e0845a5e8fe95526654eb71f06a3f75c5f8d06079510345eed3a71b); /* assertPost */ \n\ncoverage_0x5e187ee9(0x0940054530f87edeb2bd64c89735fa4446cab00f22d93581b5f978779ca4445f); /* line */ \n            coverage_0x5e187ee9(0x23f5226c2d158ef6031637827c906cbb54b7a3e213b41dc8a6230e5327a93452); /* statement */ \nprice += priceChange * timeSkipped;\n        }\ncoverage_0x5e187ee9(0x4f48b7e2e6c8ef66524e55c399ff01272bd7b02c8cf77817ff1372395ff8628e); /* line */ \n        coverage_0x5e187ee9(0x2074d776bd146524a2de26ee0dfae82652553ea3ce1546088d80a8ff9d05cedc); /* statement */ \nlastUpdated = now;\n    }\n\n    function checkAllNodes() public {coverage_0x5e187ee9(0x753b580ed3201f0c5f0c87974e807da333a1f3de7b7bae05819b52a92eb19a30); /* function */ \n\ncoverage_0x5e187ee9(0x656dad56da4e5e18b59e1383abe27f52711e5df22da8ec1411dacc3dc32a9c86); /* line */ \n        coverage_0x5e187ee9(0xe630ed00e2d71e1f0004d8475e2864183c2fb7de4f8874ad4a95d77a99fecc46); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x5e187ee9(0x7d5ab58556cc94462758546712612dc74b1e2bdf8f6bc0a46a810194f9901d73); /* line */ \n        coverage_0x5e187ee9(0x74bb89d61d03bafe21500cd1b78e43fd15e36e49a18cae08d7b8b152cdc1e329); /* statement */ \nuint numberOfActiveNodes = INodesData(nodesDataAddress).getNumberOnlineNodes();\n\ncoverage_0x5e187ee9(0x43c736322314ca147e4cc7d41efd283682c1ac0e155f7949fafac739c16060a7); /* line */ \n        coverage_0x5e187ee9(0xd1012dfa48d81f53eb0c7027390e59cc5455798dc4a63d9c4e5bb3d043b481cb); /* assertPre */ \ncoverage_0x5e187ee9(0x05e3e91b8baf643187f63cdd78736e1e8cd1696604b3458a073825357be7774b); /* statement */ \nrequire(totalNodes != numberOfActiveNodes, \"No any changes on nodes\");coverage_0x5e187ee9(0xfab1af42c323b78a41f7a7c61b93891a00ee26154987cc1c0776fc47e598ea1a); /* assertPost */ \n\ncoverage_0x5e187ee9(0x0f70817e7c8874fe1af9b8d8da5d33677202c6ab679986fe5888f96123fa2012); /* line */ \n        coverage_0x5e187ee9(0x59089c9725664d1281c79e6debc19ab5871f1c2e729d36e4d6e7ef0d109c977f); /* statement */ \ntotalNodes = numberOfActiveNodes;\n\n    }\n\n    function getTotalLoadPercentage() public view returns (uint) {coverage_0x5e187ee9(0x4fce792fd355d9af78e733ebdd6a26b0613b217400442b2f7671925133d2d992); /* function */ \n\ncoverage_0x5e187ee9(0x252353530264839e8d977a6031a28ba58eba955bbeb484037be593c11d1c0bf2); /* line */ \n        coverage_0x5e187ee9(0x63e0eb442018eb4e4f0f718edfc4053fc048f20caeba38a7bd961504fb22888f); /* statement */ \naddress schainsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsData\")));\ncoverage_0x5e187ee9(0x9a8fe88c4209fd0991bb894c2ccca7eb613905893eef9bc99f8f0a0220889f96); /* line */ \n        coverage_0x5e187ee9(0x862e8762149b31f8497da346da6f708ffea16d77a475bdd263bfb24b2df73bcc); /* statement */ \nuint64 numberOfSchains = ISchainsData(schainsDataAddress).numberOfSchains();\ncoverage_0x5e187ee9(0x8e6040cb0eddbdaae925a237d2503712228b912b1b9e1676c29dbfe95b07839d); /* line */ \n        coverage_0x5e187ee9(0x8c8f5c31d6400dea5aa4f0af51bf8317ad8af1bd751da020ececa79e2d4ca6b7); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x5e187ee9(0x51694807c62f488b54a35934637d38a4283ef903d4e07084bf0c2e5d30aedcf1); /* line */ \n        coverage_0x5e187ee9(0x84dcb9f89cfe07db871fb12185e2c021af457be5275e5b83ef7f97bc7f8554cc); /* statement */ \nuint numberOfNodes = INodesData(nodesDataAddress).getNumberOnlineNodes();\ncoverage_0x5e187ee9(0x5596049f1aa01727d0fa42eb458d7ca1a4f4bce90fbb3fdab434b716ff3161f2); /* line */ \n        coverage_0x5e187ee9(0xd914874fcd66645ed95464e7faab20ae080aeeb52c525bd3d25b265d2790df2a); /* statement */ \nuint sumLoadSchain = 0;\ncoverage_0x5e187ee9(0x53fefd1121a1bab974a873f2ac3ae04874c86b34c98b3a3c5b10d84e31d52dde); /* line */ \n        coverage_0x5e187ee9(0x1694af831c336ac6d4871dcafed3116dd918f73370e2d25f1922af92d9c53346); /* statement */ \nfor (uint i = 0; i < numberOfSchains; i++) {\ncoverage_0x5e187ee9(0xcc031a462c7dbd112afc64654a0f9f8ade969f413131b545168f2d6758e0c6e9); /* line */ \n            coverage_0x5e187ee9(0x987e4ea21641bbfbdefc30daaf0fe76b8d25adfd756c7a516daa7316d0b8ed51); /* statement */ \nbytes32 schain = ISchainsData(schainsDataAddress).schainsAtSystem(i);\ncoverage_0x5e187ee9(0x2642cccfa79c9f4e06e11aee0b1a2d748c2453d46560f56a6840d24190d461db); /* line */ \n            coverage_0x5e187ee9(0xcdf7c6dc829b3e6a983175bf0d2270884f6a165c0d5bee6b393c7ae68f5fcf02); /* statement */ \nuint numberOfNodesInGroup = IGroupsData(schainsDataAddress).getNumberOfNodesInGroup(schain);\ncoverage_0x5e187ee9(0x4bdf30dc7aee912b5ce7dd80545590954ecafd38bf65335ef4a835163dd3a2ad); /* line */ \n            coverage_0x5e187ee9(0x008ba108206db1ce846a150e7ce54d2eff8975db67109be8ba8f069bbb04bc61); /* statement */ \nuint part = ISchainsData(schainsDataAddress).getSchainsPartOfNode(schain);\ncoverage_0x5e187ee9(0x2c53f66b0d081380a540136c241b8e377d288cfae76b6ba7871cddf8efb31165); /* line */ \n            coverage_0x5e187ee9(0x6665c9a45e91e111f2fe66b80680aefa225987aab5814742857f4f3cea991c88); /* statement */ \nsumLoadSchain += (numberOfNodesInGroup*10**7)/part;\n        }\ncoverage_0x5e187ee9(0x84b1436744176a0c9753eeab62970220116b1b303e9b4dcba0f06d4b784ae561); /* line */ \n        coverage_0x5e187ee9(0x474a6e3acd55985b8cd17cf80e79bd8d2246173f1509baa0bc82ac2d0cce2004); /* statement */ \nreturn uint(sumLoadSchain/(10**5*numberOfNodes));\n    }\n}\n"
    },
    ".coverage_contracts/SchainsData.sol": {
      "content": "/*\n    SchainsData.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.3;\npragma experimental ABIEncoderV2;\n\nimport \"./GroupsData.sol\";\nimport \"./interfaces/ISchainsData.sol\";\n\n\n/**\n * @title SchainsData - Data contract for SchainsFunctionality.\n * Contain all information about SKALE-Chains.\n */\ncontract SchainsData is ISchainsData, GroupsData {\nfunction coverage_0x4067563c(bytes32 c__0x4067563c) public pure {}\n\n\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint32 startDate;\n        uint deposit;\n        uint64 index;\n    }\n\n    /**\n    nodeIndex - index of Node which is in process of rotation\n    startedRotation - timestamp of starting node rotation\n    inRotation - if true, only nodeIndex able to rotate\n    */\n    struct Rotation {\n        uint nodeIndex;\n        uint newNodeIndex;\n        uint freezeUntil;\n    }\n\n    struct LeavingHistory {\n        bytes32 schainIndex;\n        uint finishedRotation;\n    }\n\n    // mapping which contain all schains\n    mapping (bytes32 => Schain) public schains;\n    // mapping shows schains by owner's address\n    mapping (address => bytes32[]) public schainIndexes;\n    // mapping shows schains which Node composed in\n    mapping (uint => bytes32[]) public schainsForNodes;\n\n    mapping (uint => uint[]) public holesForNodes;\n\n    mapping (bytes32 => Rotation) public rotations;\n\n    mapping (uint => LeavingHistory[]) public leavingHistory;\n\n    // array which contain all schains\n    bytes32[] public schainsAtSystem;\n\n    uint64 public numberOfSchains = 0;\n    // total resources that schains occupied\n    uint public sumOfSchainsResources = 0;\n\n    constructor(string memory newExecutorName, address newContractsAddress) GroupsData(newExecutorName, newContractsAddress) public {coverage_0x4067563c(0x2608ac309e8f79e1c2c8b81ba4495ec99d1b3db4a30c4dfec7b7b4ab81a24737); /* function */ \n\n\n    }\n\n    /**\n     * @dev initializeSchain - initializes Schain\n     * function could be run only by executor\n     * @param name - SChain name\n     * @param from - Schain owner\n     * @param lifetime - initial lifetime of Schain\n     * @param deposit - given amount of SKL\n     */\n    function initializeSchain(\n        string calldata name,\n        address from,\n        uint lifetime,\n        uint deposit) external allow(\"SchainsFunctionality\")\n    {coverage_0x4067563c(0x8337c4569afe61f5182f9d155ecc93429434460966405bf036fe3e4e3ea077a0); /* function */ \n\ncoverage_0x4067563c(0x721808b222ca858ebc1c3ed23f5ff075ef6ad58ca4f8041af7eab7b48a2b7a0e); /* line */ \n        coverage_0x4067563c(0x6fbbe44bee17ae849dc9982788f5dd0a7057445b7a94746856963ff504ffe6b3); /* statement */ \nbytes32 schainId = keccak256(abi.encodePacked(name));\ncoverage_0x4067563c(0x1280f61cab7b3fbf7133f47da1429fece72824254713af973d272921e09a0b79); /* line */ \n        coverage_0x4067563c(0xfecc5ea274e49b83c77dfd7cbea709f2580249caa755b6add6678a519ca031b0); /* statement */ \nschains[schainId].name = name;\ncoverage_0x4067563c(0x70ef507fee9626848685df2fe8ed804d08717e1b51c2eefb6ce96ce3653eb2a4); /* line */ \n        coverage_0x4067563c(0x836c3909d4b5f74e9bf3772653b2781894eb18b5a5676bd3dfe2b612fc0a0062); /* statement */ \nschains[schainId].owner = from;\ncoverage_0x4067563c(0xf06737c1bfa0cb1f7e1ba735fb6150d45555c1f755099c3cc5a2708375228e1d); /* line */ \n        coverage_0x4067563c(0x38a4cfc63028291648d51573a7e1d59095099138673391f36c0bd076e895b229); /* statement */ \nschains[schainId].startDate = uint32(block.timestamp);\ncoverage_0x4067563c(0x2808afeeee6379f89ab3abce3398265fa027f4aaa8410e255a7c5cd07919f005); /* line */ \n        coverage_0x4067563c(0x1bea250886a41de3f35e4057b577747407aebdeb7e93b1163aab59a1cdb5f023); /* statement */ \nschains[schainId].lifetime = lifetime;\ncoverage_0x4067563c(0x2b0444876f7ad225973ef993ab832f26f7cf8840321cb9b14728b98823164a5e); /* line */ \n        coverage_0x4067563c(0xc04854e63281aa935e166163f29e897f56bdfee157f44f741b6079dc524f65e0); /* statement */ \nschains[schainId].deposit = deposit;\ncoverage_0x4067563c(0xbe586213fa9690efbeaa2d80f05a09503cacdd66ed5c55a17d7df024a98cd851); /* line */ \n        coverage_0x4067563c(0xdaa480539022153982a4198126f34a7179d76a7b244cf80cacfad654aa9c8384); /* statement */ \nschains[schainId].index = numberOfSchains;\ncoverage_0x4067563c(0xa54b3ea4f38220382a7583614ae0896c0d429512f1d377b3433e19e5db6363fb); /* line */ \n        numberOfSchains++;\ncoverage_0x4067563c(0x60aff0196a0b458dc7c27009f4eb354b7c70b5b9fc4cdf25c0f128077f3da81e); /* line */ \n        coverage_0x4067563c(0x5cc9c911213544db3ad8845b9f29baf475493e3a0ae6d29639fb71e476284ad2); /* statement */ \nschainsAtSystem.push(schainId);\n    }\n\n    /**\n     * @dev setSchainIndex - adds Schain's hash to owner\n     * function could be run only by executor\n     * @param schainId - hash by Schain name\n     * @param from - Schain owner\n     */\n    function setSchainIndex(bytes32 schainId, address from) external allow(\"SchainsFunctionality\") {coverage_0x4067563c(0x7091810439d19cfd02aeab886a0138cd34e38347326b2b200cc22dfae2ff8241); /* function */ \n\ncoverage_0x4067563c(0x1c0a465416e308db8338af1aef2d8c143bb48d103972b0c2645d61786b05a58d); /* line */ \n        coverage_0x4067563c(0xe044e52308335c943a72fc0fdefa92016ed73b51f999adc7e7c8de4228931648); /* statement */ \nschains[schainId].indexInOwnerList = schainIndexes[from].length;\ncoverage_0x4067563c(0xd46a64ccd265cadb45898e2b01e9388ddda9368d5d16154fcf9a962bb2e30f9c); /* line */ \n        coverage_0x4067563c(0x5cf0f03ddf40ab4976f2543a7fe3bb0f18cd212d6190452bb9458d01cdfdddf4); /* statement */ \nschainIndexes[from].push(schainId);\n    }\n\n    /**\n     * @dev addSchainForNode - adds Schain hash to Node\n     * function could be run only by executor\n     * @param nodeIndex - index of Node\n     * @param schainId - hash by Schain name\n     */\n    function addSchainForNode(uint nodeIndex, bytes32 schainId) external allow(executorName) {coverage_0x4067563c(0x8f7f8b04792733afdd734744cc28eae4c5e34d87166689223653c23c6456d796); /* function */ \n\ncoverage_0x4067563c(0x70fc7a66543d37df505bbfcce9243f075345e267b0f1c75585f6e0a8ed0f1cfb); /* line */ \n        coverage_0x4067563c(0x5ebeda5502e458948c7c599aa60e60c2066398b20925a2a055251ede262176c9); /* statement */ \nif (holesForNodes[nodeIndex].length == 0) {coverage_0x4067563c(0x1c149d0459a40f0afee8de5636e6a7cf24a644af98995b1ca5ad29926a316120); /* branch */ \n\ncoverage_0x4067563c(0xa03e5ecd320db73ec8b636b0f534f7e5de74a6c87b5888f76251fb467472c029); /* line */ \n            coverage_0x4067563c(0x48c4451f95d7b8cba567d82121ec580e3b8c75bd58bbe338f636a4b3528799df); /* statement */ \nschainsForNodes[nodeIndex].push(schainId);\n        } else {coverage_0x4067563c(0x34df9a8b70a392ce6516cea01b730cc946b6f6619a06da7c35ab5acdff63e32b); /* branch */ \n\ncoverage_0x4067563c(0x6f92071b56f85ee455ff6d44a8ff7d2a7ba38fab7fce14762d8ee0a8ed8d2450); /* line */ \n            coverage_0x4067563c(0xccf5211d41c34c7b86cbace49cbfd28de5476f8d7be16bff9cafb264f97d5bac); /* statement */ \nschainsForNodes[nodeIndex][holesForNodes[nodeIndex][0]] = schainId;\ncoverage_0x4067563c(0x5cf85d91d71f7baaac59c511d72d599b61645d9af4ed45e31c4193334cecdeb8); /* line */ \n            coverage_0x4067563c(0xcbb48d144f34da41a0e60683b7a0c8d441c9fa2bdd4306a448566cd0c9ce371a); /* statement */ \nuint min = uint(-1);\ncoverage_0x4067563c(0xe1e1a8152e7d63f245302e0fb64b547716d670db4f04b6aa012c9e9eac6eac90); /* line */ \n            coverage_0x4067563c(0x04a3847b7db49991c496ec9debb2096f7d543b5e679af591daa3882b3cde8cef); /* statement */ \nuint index = 0;\ncoverage_0x4067563c(0x84e8a96758b40ddc794cad1af036c384ee0900116424d62c3ed6605e10c9a348); /* line */ \n            coverage_0x4067563c(0x276a02a3e29331ec7acd606b8f5f3e901efdd414d7988086835d9323fbcf50b5); /* statement */ \nfor (uint i = 1; i < holesForNodes[nodeIndex].length; i++) {\ncoverage_0x4067563c(0xd41d4bb4481b019a06f50dd6fb0aa60436955758c26d66e6eb1f3616a19dfe3c); /* line */ \n                coverage_0x4067563c(0x908afdaffc9e53f9fa8ae90a2c8ad9ced9098ae3ea4c624a56925d34e16b34b6); /* statement */ \nif (min > holesForNodes[nodeIndex][i]) {coverage_0x4067563c(0x08f110579b0fa408d421349fa926ffcc0b8e0da2514584a760c7ed9f9f7f07d3); /* branch */ \n\ncoverage_0x4067563c(0x45e348086bbb36fb3bb2cf97bee0b61ae537d05492a2b207417956df9742df4a); /* line */ \n                    coverage_0x4067563c(0x2ac71d080827d81c96a0227c9676c09da5cfa70d5cc1dc6715bc97955d5e002d); /* statement */ \nmin = holesForNodes[nodeIndex][i];\ncoverage_0x4067563c(0x80599a8972c38044cd2bbe70b20ad52d7f3677ee443855dbd639373a2984be5e); /* line */ \n                    coverage_0x4067563c(0x3830f6cac80da91e3393087a59eab8cba49a403a12c9f11cf26e73e7d8a4ddb9); /* statement */ \nindex = i;\n                }else { coverage_0x4067563c(0x1b177efd8516e41e369f0ef62e7a6704aa151d5b4e93fe56a7d1b44790110fbe); /* branch */ \n}\n            }\ncoverage_0x4067563c(0x34e3232835bee8c46c7a7522ae0b3095e77bae25ede0eb962bcb7efdb98eff82); /* line */ \n            coverage_0x4067563c(0x890ef7ff18be07ea3ec24261cd4879191000aa4d93e9897c188d838652fa57cc); /* statement */ \nif (min == uint(-1)) {coverage_0x4067563c(0x1818f1459df6ba56ef9f690d416c48fe5ba3505adf3fbd42abc1150c8852551b); /* branch */ \n\ncoverage_0x4067563c(0xf627505b56faa6888523f5159c5fe4430ee995b5ee1af1d7852d0db629ee8c4e); /* line */ \n                delete holesForNodes[nodeIndex];\n            } else {coverage_0x4067563c(0x91dd28c7c22fe3bb8309982dd4e7e6304ddd8ea77282ccbcf4df3f8719d2b792); /* branch */ \n\ncoverage_0x4067563c(0xb814ce9da6eef0e0d1066ee6938f7ed8335ac75e9523a0da16c8994d19defb99); /* line */ \n                coverage_0x4067563c(0x41e752edc904c802f11e3b97ad138a97e7578a7f89ab4aedb32c35e4a2ed8bce); /* statement */ \nholesForNodes[nodeIndex][0] = min;\ncoverage_0x4067563c(0x7c476057a27c591fb9a80cf736048616f0cd251168fb94c3d19fb23f778abfb0); /* line */ \n                coverage_0x4067563c(0x6d2a02c5db67b3e0d521b8f32e83497b03ee422425f8bd13b1e6970cfed291c0); /* statement */ \nholesForNodes[nodeIndex][index] = holesForNodes[nodeIndex][holesForNodes[nodeIndex].length - 1];\ncoverage_0x4067563c(0xc72902462f3809d2b3e824d4850b263c7465564fa59f497a89bc688210410af7); /* line */ \n                delete holesForNodes[nodeIndex][holesForNodes[nodeIndex].length - 1];\ncoverage_0x4067563c(0x97f1fb5089ff7a8e549ffebd5fce2c3bafd4a0037acfdbe2e264878bcadfa21c); /* line */ \n                holesForNodes[nodeIndex].length--;\n            }\n        }\n    }\n\n    /**\n     * @dev setSchainPartOfNode - sets how much Schain would be occupy of Node\n     * function could be run onlye by executor\n     * @param schainId - hash by Schain name\n     * @param partOfNode - occupied space\n     */\n    function setSchainPartOfNode(bytes32 schainId, uint8 partOfNode) external allow(executorName) {coverage_0x4067563c(0x9ae03ce03916563a58c7331c41dadd1bda483e9fced099feded7e8dff8bdf5c2); /* function */ \n\ncoverage_0x4067563c(0xdb552c48875e5493ee4f8d4157cbb902589d42543336d2a5337a50bf93cb308c); /* line */ \n        coverage_0x4067563c(0x5fee7108db87ddf4758cd13f6a9a4ccd4e17a7c35bd1a2e5425bc55d58ea8132); /* statement */ \nschains[schainId].partOfNode = partOfNode;\ncoverage_0x4067563c(0xe0fc08196892a91db8d73f46eb79f088e846b6924397a4ec401dbf2722afa142); /* line */ \n        coverage_0x4067563c(0xc344408228963cbabc38d1447eea2d2d06c21429c06e751b8e91726241f67e6b); /* statement */ \nif (partOfNode > 0) {coverage_0x4067563c(0x05b790148ab9a6c26ea72ae21536644ae824b75126a621ee2b12938c2e828858); /* branch */ \n\ncoverage_0x4067563c(0xcb29331d1241d25119c4313255a9673503abd08bc7b9d5ffa6ecbef9c8991809); /* line */ \n            coverage_0x4067563c(0xdedc67f4a95b45c86919258fb1cab97398cdd3d6475f4e01bdb66a461a1a658a); /* statement */ \nsumOfSchainsResources += (128 / partOfNode) * groups[schainId].nodesInGroup.length;\n        }else { coverage_0x4067563c(0xe75761cb1cc86716b4cd160045a41c9b076d34201531548e0c92fb3dfb25ec1d); /* branch */ \n}\n    }\n\n    /**\n     * @dev changeLifetime - changes Lifetime for Schain\n     * function could be run only by executor\n     * @param schainId - hash by Schain name\n     * @param lifetime - time which would be added to lifetime of Schain\n     * @param deposit - amount of SKL which payed for this time\n     */\n    function changeLifetime(bytes32 schainId, uint lifetime, uint deposit) external allow(\"SchainsFunctionality\") {coverage_0x4067563c(0xd687c12163b0ca9024c54ba45b220817137dd055f044c35eb350a00e385d4539); /* function */ \n\ncoverage_0x4067563c(0x58863dddaaceac57e398802bc41c2a24524c5322da9feb9185e23977a3fbcbd7); /* line */ \n        coverage_0x4067563c(0xcb11990edc2e1cecf9cc7cd04cfc98bae88b779ea00076e841b1304be2f8cadf); /* statement */ \nschains[schainId].deposit += deposit;\ncoverage_0x4067563c(0x5f747a06612ab61a55b85da54ad6211179005344c1b765fc5ef37ceae7020ed4); /* line */ \n        coverage_0x4067563c(0x6b2f3f794b7e779bd657f45503f923b0f317e2f574b4c14d5780fa65b97d8315); /* statement */ \nschains[schainId].lifetime += lifetime;\n    }\n\n    /**\n     * @dev removeSchain - removes Schain from the system\n     * function could be run only by executor\n     * @param schainId - hash by Schain name\n     * @param from - owner of Schain\n     */\n    function removeSchain(bytes32 schainId, address from) external allow(\"SchainsFunctionality\") {coverage_0x4067563c(0xb52858ba9325ee587d42392bdd958e8fbb09f3cc22e14d03c4c6ada481ab0544); /* function */ \n\ncoverage_0x4067563c(0xf2cb203ea9e50a7df04519c39638195db13d8f4290b4aa926bb883851c83ca42); /* line */ \n        coverage_0x4067563c(0xb3750cdbcacd41c7b36baf5dacb7bdd936dd8818df25ceee9205fbad82ffb05a); /* statement */ \nuint length = schainIndexes[from].length;\ncoverage_0x4067563c(0x32b483374af01f44448a15748cf8df5660d2bfd077a18bf0e428bdc51a318ea7); /* line */ \n        coverage_0x4067563c(0xabd0ee3e6d8e1a819050a7e81aaca1f3f0616b5edaebe012baa23097fa7d710b); /* statement */ \nuint index = schains[schainId].indexInOwnerList;\ncoverage_0x4067563c(0x222bf1b32299e15c4e32def320299d69f6f5ef2e488da4cafc4011dff8e4e610); /* line */ \n        coverage_0x4067563c(0x4309888bbed61f17ddf0f8cd7a3c197e39cb9fe067176c6aa4bc3e22f2e19f5c); /* statement */ \nif (index != length - 1) {coverage_0x4067563c(0xcced9ae46440f9d24053de286e335fa6fa57006ca51641e3e9a02e40edb46257); /* branch */ \n\ncoverage_0x4067563c(0x35899861d32afc18210e16c19e0b3a1496384dc39e4cf657fa59eebebcc7b66d); /* line */ \n            coverage_0x4067563c(0xf50add13a158c73f638d74eb4f92d85eef65cd95575f69277a85cc089e420bf0); /* statement */ \nbytes32 lastSchainId = schainIndexes[from][length - 1];\ncoverage_0x4067563c(0xd1e67d61805c3f4a28e12676be34c4436e31d2c391e03da850b383c584e85bc4); /* line */ \n            coverage_0x4067563c(0xb59384e4297e96ba557b1c4f81a6b076fbc431d64e7760638a055ff1e5217210); /* statement */ \nschains[lastSchainId].indexInOwnerList = index;\ncoverage_0x4067563c(0x4159f291495bbe009983f822153a373d164d970710e4bee6b50a188d2350fe9c); /* line */ \n            coverage_0x4067563c(0xf9a3a1183baf999736a12288c37c599c220f6d2e30afd999aa12fb4ddb4c01e4); /* statement */ \nschainIndexes[from][index] = lastSchainId;\n        }else { coverage_0x4067563c(0xe0e966f6ace23cbd8fb012122c81850b4e2a9fde52fc839856a6ff3264c2fde8); /* branch */ \n}\ncoverage_0x4067563c(0x8612e6f70467455793fc420f18c33c20bb443ec0ccf193bf2692c89c1fd5759a); /* line */ \n        delete schainIndexes[from][length - 1];\ncoverage_0x4067563c(0x94c1cc9da2cd28e22f0b594f25155b7d7bca79abc4edc6a26e778c40dec4fa74); /* line */ \n        schainIndexes[from].length--;\n\n        // TODO:\n        // optimize\ncoverage_0x4067563c(0x98d2f5137fd61545ac78f8aa1dca1ced8d377874ad8606628cff0741daeb8f63); /* line */ \n        coverage_0x4067563c(0xd18c8cdaf011fa0d2b7ad9633898087eb34d0bdb583535f6672a00f800363508); /* statement */ \nfor (uint i = 0; i + 1 < schainsAtSystem.length; i++) {\ncoverage_0x4067563c(0xe35c550423e1922e5b22137c963ab961e6ed4c631b9d2bec1b5a14c5e147e177); /* line */ \n            coverage_0x4067563c(0xf06bff0b7749589e2ad0d850d1ab1ab1ebf41a84565eaa36c4391edc81d11c78); /* statement */ \nif (schainsAtSystem[i] == schainId) {coverage_0x4067563c(0xa064332234d8249b600521f32e1b3369c3fbb7bd7605ae24ca9a921684b285ee); /* branch */ \n\ncoverage_0x4067563c(0x949885c641e6a3090dfc11ebdff9416999749f252dae8a1dc7e24db05ae028f9); /* line */ \n                coverage_0x4067563c(0xc021e5427e49b11639a701a227372e6d1261336f549304044eeb140fe2fec4bd); /* statement */ \nschainsAtSystem[i] = schainsAtSystem[schainsAtSystem.length - 1];\ncoverage_0x4067563c(0x4c9479b45f52ab0f73ab1bf37106769d913cbc0097d677b7384124ec9ca44ae3); /* line */ \n                break;\n            }else { coverage_0x4067563c(0xd8b290725043017a7c4a9895d2928db20a28ba32560114618c035d1126f4283a); /* branch */ \n}\n        }\ncoverage_0x4067563c(0xa832049f131c976a022ab8f643ff8664c46c206c5c029f4a8dcebb70a2a5a41b); /* line */ \n        delete schainsAtSystem[schainsAtSystem.length - 1];\ncoverage_0x4067563c(0x4dc3cfd953aa175ccf53f236eb5f5f7ebe02713b463611675929200e494be25a); /* line */ \n        schainsAtSystem.length--;\n\ncoverage_0x4067563c(0x32cfe2f3285e03e7cf449f0150a477c01b7ec3715eba5bf2543be470bbc6f981); /* line */ \n        delete schains[schainId];\ncoverage_0x4067563c(0x63ed94d588a3d499baf9bf079d6e2446f35440ca03c93d87411dcc7acddf3dbe); /* line */ \n        numberOfSchains--;\n    }\n\n    /**\n     * @dev removesSchainForNode - clean given Node of Schain\n     * function could be run only by executor\n     * @param nodeIndex - index of Node\n     * @param schainIndex - index of Schain in schainsForNodes array by this Node\n     */\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external allow(\"SchainsFunctionalityInternal\") {coverage_0x4067563c(0xe918887bf3432bd5952aba21ce56720ea1b98743d59157c4437eed465227ef21); /* function */ \n\ncoverage_0x4067563c(0x1129a9792b3348bb6167f3248f52b6ae103e3cdc0169ee294f48023d26a3013e); /* line */ \n        coverage_0x4067563c(0x16eb5663b3ac3e2d08d0ccf37f385caa9ef57e154aa2dde36902e5bd0359a213); /* statement */ \nuint length = schainsForNodes[nodeIndex].length;\ncoverage_0x4067563c(0x6ac5e60f6bba8102b8f817cec4d81b4f116a66fe24830532ace048c8d5e194c7); /* line */ \n        coverage_0x4067563c(0xb6bfdb6c3f15a11cf5d76086ff12b16a14e78b201271c9cfcd6378bfa957317e); /* statement */ \nif (schainIndex == length - 1) {coverage_0x4067563c(0x3fae2b76b60e8a884a5a41440e5b93cfa0449b9c091f9b86b8488fc0334458fb); /* branch */ \n\ncoverage_0x4067563c(0xd692325166ddaf3a1f25d23017820eb65b6f92b08f67cb6983c241f040c4fc5b); /* line */ \n            delete schainsForNodes[nodeIndex][length - 1];\ncoverage_0x4067563c(0x6b9e383161830fa3f1a28cfa81863adabdcf035dd272347c9c4fa8300a43b5c9); /* line */ \n            schainsForNodes[nodeIndex].length--;\n        } else {coverage_0x4067563c(0xafaca3a239d0849f4d9c4c9b0f3f082f262b47adbeb386e04fcc1d7e710e0bf9); /* branch */ \n\ncoverage_0x4067563c(0x56d3ced14e10575518829b8b5cced5d9307ef5c570bf003eda230da5e58a12f9); /* line */ \n            coverage_0x4067563c(0x26b5af0aa115003db7d495f7b6d5ac54d15ab00bb5cf8d98f1af132a8ecc45c7); /* statement */ \nschainsForNodes[nodeIndex][schainIndex] = bytes32(0);\ncoverage_0x4067563c(0xcba6cf0c923ae590bda3c3553406224ffab3f396fb99b45a372b5e0eb759060c); /* line */ \n            coverage_0x4067563c(0xe17a3401b53d23c3a4be21f14a49fad353675b28225a3ea2fe3872e2fde26e91); /* statement */ \nif (holesForNodes[nodeIndex].length > 0 && holesForNodes[nodeIndex][0] > schainIndex) {coverage_0x4067563c(0x062968c2eb9d188035cda4e58963aa5d968308c7b01a91af9006423a30a3d8a0); /* branch */ \n\ncoverage_0x4067563c(0x7aa37bf45f8ea21fcfd236defc1f958cbdbe95c4be8b1473e26c1fda67755ed3); /* line */ \n                coverage_0x4067563c(0x5b601e6bae2b5535b0daa26ca1f93859295b37a8ec225e2115d7e8790e7c28de); /* statement */ \nuint hole = holesForNodes[nodeIndex][0];\ncoverage_0x4067563c(0xe26926eccaba3f3810ed686a8772732ee454bca16d1caba922deef267a680ad2); /* line */ \n                coverage_0x4067563c(0xc418a2d46fd0f338ae35a414655ec0cd923741b93658153daefd92477c613dc1); /* statement */ \nholesForNodes[nodeIndex][0] = schainIndex;\ncoverage_0x4067563c(0x10a7be8c22f054b2c190fbfe9d94ffa0e9a2c747c8ca63b79f351d6769e3f55a); /* line */ \n                coverage_0x4067563c(0xcf8d0e22786ceb416c1fe2af3630b41646e303b65be5da54fb58afe6da8efb6e); /* statement */ \nholesForNodes[nodeIndex].push(hole);\n            } else {coverage_0x4067563c(0x9922e507050b4d93bf8b7b7419b7de2cc91046d16ce1b8a82d1254ec2799709f); /* branch */ \n\ncoverage_0x4067563c(0x18b8640c76f94e9ad3de91b97760b83c242c1d52740cfdb93beb5d45ded83e65); /* line */ \n                coverage_0x4067563c(0xadbe96d21635a4984b22037b2aa485da1ead3af524ac2d0588b88f61b13563db); /* statement */ \nholesForNodes[nodeIndex].push(schainIndex);\n            }\n        }\n    }\n\n    function startRotation(bytes32 schainIndex, uint nodeIndex) external {coverage_0x4067563c(0xf8ecd2f7e29061640880592f855a3c9016e483c9b90b0a6ed5d8596ec069ace1); /* function */ \n\ncoverage_0x4067563c(0xc91f6ba613cbb7a6c00cd3b8fbb9885b615c2d776a81489b46cf94eb50db822e); /* line */ \n        coverage_0x4067563c(0xa6615bbaad56d2dfa1317f0afb1790321bd78c40582342b6c73a76c9d4362d6c); /* statement */ \nrotations[schainIndex].nodeIndex = nodeIndex;\ncoverage_0x4067563c(0xda6ef9df259d783326bc7ba4a64150d440d74eb16c3ec219665e734148810c67); /* line */ \n        coverage_0x4067563c(0x5d0cb79237da09e43d59891f519886c104663c5f5bdd9fd6c045cc4500b115e7); /* statement */ \nrotations[schainIndex].freezeUntil = now + 12 hours;\n    }\n\n    function finishRotation(bytes32 schainIndex, uint nodeIndex, uint newNodeIndex) external {coverage_0x4067563c(0x7d604002c268c19b241c7c0c28cdb1894495ed25f05d69fb64bb2e11f8892672); /* function */ \n\ncoverage_0x4067563c(0x206fe733752794d7e30aafca409022336b0c8839bb5273c6fcd0515c5e3775b3); /* line */ \n        coverage_0x4067563c(0x6fa4bf8df758801a53722009d83d98fbce0fa753c5204944c0662beb5e2487be); /* statement */ \nleavingHistory[nodeIndex].push(LeavingHistory(schainIndex, now + 12 hours));\ncoverage_0x4067563c(0x45da5da6152a445d760eafa40274da856c992bc6d2d3023dbf96ad3f69b24add); /* line */ \n        coverage_0x4067563c(0x3f61655c76dfa98c4cc402cbee90a95a7022833b942049ba51669917ee20db61); /* statement */ \nrotations[schainIndex].newNodeIndex = newNodeIndex;\n    }\n\n    function getRotation(bytes32 schainIndex) external view returns (Rotation memory) {coverage_0x4067563c(0xe05f12570e11100f5b199f5707d8c1dfe01525fb2a55267c6a96700175674148); /* function */ \n\ncoverage_0x4067563c(0x6cabe600dd69740f38352f1e466c973b558ba2acc9c35b5e9c2637a40ef622ac); /* line */ \n        coverage_0x4067563c(0x6a9fbe6a24f482a8a41e392b83e2b5f774edbe4e417853265c574c0218cb6ff8); /* statement */ \nreturn rotations[schainIndex];\n    }\n\n    function getLeavingHistory(uint nodeIndex) external view returns (LeavingHistory[] memory) {coverage_0x4067563c(0x44c4ab3387ed59d1f62cec1afa8210d897e378637bf4c1168ad615b17f59c2da); /* function */ \n\ncoverage_0x4067563c(0xa96a0ec073389dedbf081a3702edfbd2fd54655e912eb95699efae3f85ecf492); /* line */ \n        coverage_0x4067563c(0x33dfb3bb314fd7f16aeec5932d4f2e7652d9913e7d53af2878233cb27bfe1e9e); /* statement */ \nreturn leavingHistory[nodeIndex];\n    }\n\n    /**\n     * @dev getSchains - gets all Schains at the system\n     * @return array of hashes by Schain names\n     */\n    function getSchains() external view returns (bytes32[] memory) {coverage_0x4067563c(0x6c9203b367b257bd53bd8efc11010bce059ea2eb085ba7e80a645256fd4d9d83); /* function */ \n\ncoverage_0x4067563c(0xb2a27e09bfe036af86cb94cf1c0cd8b5f2fea67bcc44cd5be4edb2252e657fd9); /* line */ \n        coverage_0x4067563c(0x6166bcb1aeb22236f947d703c72eb21d57d020f71148ce85b21e8c923f385432); /* statement */ \nreturn schainsAtSystem;\n    }\n\n    /**\n     * @dev getSchainsPartOfNode - gets occupied space for given Schain\n     * @param schainId - hash by Schain name\n     * @return occupied space\n     */\n    function getSchainsPartOfNode(bytes32 schainId) external view returns (uint8) {coverage_0x4067563c(0xb529adb1146cb7dda91edb1fb42bc4f71a954c4518b68442298f66a536486bf7); /* function */ \n\ncoverage_0x4067563c(0x9758d4943427f95d918cdc27c8145761f47c963e01281749012110aa272dfa1a); /* line */ \n        coverage_0x4067563c(0x351803da8802118e3226f2fe0d69fd9b0da96d400304cb67f2be51c4f466aff8); /* statement */ \nreturn schains[schainId].partOfNode;\n    }\n\n    /**\n     * @dev getSchainListSize - gets number of created Schains at the system by owner\n     * @param from - owner of Schain\n     * return number of Schains\n     */\n    function getSchainListSize(address from) external view returns (uint) {coverage_0x4067563c(0x81e586358779280857e45519cc1c38670be025468e772c7bf4051ce015cbb821); /* function */ \n\ncoverage_0x4067563c(0x12f306188001e805e1b195030222dd5514559a8af21381b3c3ba2e0534bbfaaf); /* line */ \n        coverage_0x4067563c(0x43af52c28c43413e97a0dd5f1110c4adce98edbcf95fb888d0ae8565eb4b90e3); /* statement */ \nreturn schainIndexes[from].length;\n    }\n\n    /**\n     * @dev getSchainIdsByAddress - gets array of hashes by Schain names which owned by `from`\n     * @param from - owner of some Schains\n     * @return array of hashes by Schain names\n     */\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory) {coverage_0x4067563c(0xe9f4661c7e3f310f41ad2ce0bdff3d3d7c6435c74e5fdf4381e7d2f7ea029ea9); /* function */ \n\ncoverage_0x4067563c(0x9dd8b323c6e8972f17378b61fc6ab3759d1817445a5f1b8c6cdc9db6b118deff); /* line */ \n        coverage_0x4067563c(0xf43e392afd505bf65361e32a8cf35af74902d0766cb46f0ae462aa79ce42ea48); /* statement */ \nreturn schainIndexes[from];\n    }\n\n    /**\n     * @dev getSchainIdsForNode - returns array of hashes by Schain names,\n     * which given Node composed\n     * @param nodeIndex - index of Node\n     * @return array of hashes by Schain names\n     */\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory) {coverage_0x4067563c(0x1a081ecd6a6e148070bf7ec7c9cb2d3792121d4bbb190c84a06550ddb4f3ed35); /* function */ \n\ncoverage_0x4067563c(0x17cc7b849491723b11efc55f8db3baa7c62ffbe0565eafb5d7ddafcbc3270823); /* line */ \n        coverage_0x4067563c(0x55eeaf06d414ab89a688a9b4894478232608433f79cc0e5539e27bf4a60c19a4); /* statement */ \nreturn schainsForNodes[nodeIndex];\n    }\n\n    /**\n     * @dev getLengthOfSchainsForNode - returns number of Schains which contain given Node\n     * @param nodeIndex - index of Node\n     * @return number of Schains\n     */\n    function getLengthOfSchainsForNode(uint nodeIndex) external view returns (uint) {coverage_0x4067563c(0x3466bbd42b47ec714c936c86a5a754aa073c7817e11760e643c12773cec788f9); /* function */ \n\ncoverage_0x4067563c(0x3cfaf873128420a90279ba28fe3a9838980deaf862ad91426d18a69b380ab1b3); /* line */ \n        coverage_0x4067563c(0xd872f66b5d94990bce0fe122247bb4a50cfa8eb463b3d408875db2910c20a78c); /* statement */ \nreturn schainsForNodes[nodeIndex].length;\n    }\n\n    /**\n     * @dev getSchainIdFromSchainName - returns hash of given name\n     * @param schainName - name of Schain\n     * @return hash\n     */\n    function getSchainIdFromSchainName(string calldata schainName) external pure returns (bytes32) {coverage_0x4067563c(0xcbb87d2d30c5da3c0a210562fab8bcce9407c8cb204853b6eace0004ee5a7692); /* function */ \n\ncoverage_0x4067563c(0xe53bb195a4c64630d51cc8d55e8c0ee1994b4ebde4b5d13d361160a8b2175c15); /* line */ \n        coverage_0x4067563c(0x8387e7c474f47e944c6bb2b0540901fbe4ad444e1e0b2136209af2466d86cfc9); /* statement */ \nreturn keccak256(abi.encodePacked(schainName));\n    }\n\n    function getSchainOwner(bytes32 schainId) external view returns (address) {coverage_0x4067563c(0xe6d4fe93c59174f044a0d3012412ad2968ea07f605a2231f4b0a22f3a597abd7); /* function */ \n\ncoverage_0x4067563c(0x8c2bc95f886bda170ff41ce48f2962f08d718c1e3333aa1baaf02a3769b85776); /* line */ \n        coverage_0x4067563c(0x30cad89f4d0384311d48264e9f510488084da67d70bc286d47f4f684634657d1); /* statement */ \nreturn schains[schainId].owner;\n    }\n\n    /**\n     * @dev isSchainNameAvailable - checks is given name available\n     * Need to delete - copy of web3.utils.soliditySha3\n     * @param name - possible new name of Schain\n     * @return if available - true, else - false\n     */\n    function isSchainNameAvailable(string calldata name) external view returns (bool) {coverage_0x4067563c(0x4b46fdef3e5e6c312703d7b18a911e51a61b85dd88b8587164d185012a1b4f5d); /* function */ \n\ncoverage_0x4067563c(0x3c703df3c9ddeb7429b9eac8cddc52878b7a9fc29c8fe65c6b034f5514646150); /* line */ \n        coverage_0x4067563c(0xbc1c8619326bab3d93abecc4fc94005a93390cacb7e27044464af6d22fb133c0); /* statement */ \nbytes32 schainId = keccak256(abi.encodePacked(name));\ncoverage_0x4067563c(0x65a731269dec461984098951e6bdb749189576294f24535610d0ac87757c9062); /* line */ \n        coverage_0x4067563c(0x17aa633fadfa2562a4adbc4cc46338d016fbc51654425448a5faed7b822bf8b1); /* statement */ \nreturn schains[schainId].owner == address(0);\n    }\n\n    /**\n     * @dev isTimeExpired - checks is Schain lifetime expired\n     * @param schainId - hash by Schain name\n     * @return if expired - true, else - false\n     */\n    function isTimeExpired(bytes32 schainId) external view returns (bool) {coverage_0x4067563c(0xcd4855477771985acf9e3d957c69942593ba113d0d1a186232b2ca8c01a88363); /* function */ \n\ncoverage_0x4067563c(0x28fd36ef6650896c893b865c0302da6c7e5a1836c79610e85fde660c511a06cc); /* line */ \n        coverage_0x4067563c(0x4218079a006f026eb11295229f697d11bb6f7dd6783277af55dd24bccdaff882); /* statement */ \nreturn schains[schainId].startDate + schains[schainId].lifetime < block.timestamp;\n    }\n\n    /**\n     * @dev isOwnerAddress - checks is `from` - owner of `schainId` Schain\n     * @param from - owner of Schain\n     * @param schainId - hash by Schain name\n     * @return if owner - true, else - false\n     */\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool) {coverage_0x4067563c(0x53ac2f44831b389658b66f91c1c5be726f2c7ff2dfa226ded31fd351a450984c); /* function */ \n\ncoverage_0x4067563c(0x9079ae0b27ad262e8d73f2f9f3979f678b798fd2db13c17b42390a7f737157f8); /* line */ \n        coverage_0x4067563c(0xb7be81709183be6607ad6c2bb2a0e7fa1fb8698589cf945e6d65fe7f67665bc3); /* statement */ \nreturn schains[schainId].owner == from;\n    }\n\n    function isSchainExist(bytes32 schainId) external view returns (bool) {coverage_0x4067563c(0x73f9d5d8b4e5f87f4b223c79c6e927647f5dee7e737fe31831faac7da3ea12d9); /* function */ \n\ncoverage_0x4067563c(0x2c454e7a6acd2a6314224dc2a333b74f538cf3f203fdc2b3238bd710ea282f40); /* line */ \n        coverage_0x4067563c(0x08c87c899e81ed8b930868c71e0a1be23373c3514ff35728a48d9a946876f57d); /* statement */ \nreturn keccak256(abi.encodePacked(schains[schainId].name)) != keccak256(abi.encodePacked(\"\"));\n    }\n\n    function getSchainName(bytes32 schainId) external view returns (string memory) {coverage_0x4067563c(0x150787cd47a72c08573320d40a056a3eee11ddea4228e78733124abbc180cd2c); /* function */ \n\ncoverage_0x4067563c(0xca4d74f2a1fa8135c7072da8bbe6daa18fc46fccb8f84c97853f94681e8b41d8); /* line */ \n        coverage_0x4067563c(0x346f0e369e5bb0d102920d3449d0fa4d13d6812b3d16083971693e5ef1133c45); /* statement */ \nreturn schains[schainId].name;\n    }\n\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32) {coverage_0x4067563c(0x9eb84926ae74199be4e76c3dfe71420b31fe05eb0af7b078e27583cde9e82443); /* function */ \n\ncoverage_0x4067563c(0x841a756ca5d2abb6ae0ff18bfd8cfd42839c5ba92b34b02251a2a80d311aca42); /* line */ \n        coverage_0x4067563c(0x09c25733b011d26548c05ea0355b049746ecac592ef1339bd2d40bdec9af34d2); /* statement */ \nfor (uint i = 0; i < schainsForNodes[nodeIndex].length; i++) {\ncoverage_0x4067563c(0x49b1fec15507923e8c2172522849104de9ac89e03d4a36b0127732d808e43bb1); /* line */ \n            coverage_0x4067563c(0xe89784bef93d0a7ed1e33f6f09d252de2e57ad54fc42bdea3708f9d85029b668); /* statement */ \nif (schainsForNodes[nodeIndex][i] != bytes32(0)) {coverage_0x4067563c(0x1e7617d08fc1d4f49b8d946c8065b38812ffad269634821e0e9af5d3aa14b42f); /* branch */ \n\ncoverage_0x4067563c(0xbcdc725cbed453e545a3474f6e989bc1d9b26aa80b6c6c738cfe81c10da9cd22); /* line */ \n                coverage_0x4067563c(0x2e9556eab4157f7ac7e0891881e83a151c5d320ffd364b4eb0652d3125c8daa7); /* statement */ \nreturn schainsForNodes[nodeIndex][i];\n            }else { coverage_0x4067563c(0xeabcb47e0af38add182615036a5906ff2e8602719b4e7b36a3cd29c6fc933330); /* branch */ \n}\n        }\ncoverage_0x4067563c(0x833c5b7ca184f1823a4d6f5505d5afd7808ba7c729bb9d9f62a4ef8067047a1d); /* line */ \n        coverage_0x4067563c(0x3aa353c70b67f7b048c162112ef0c5f688d6ecca7d184c4a9080f05049675d0f); /* statement */ \nreturn bytes32(0);\n    }\n\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains) {coverage_0x4067563c(0x467c8ebfab45c9b520e635b4c24d235f37289139c6c74d9c3e05703af3d7d468); /* function */ \n\ncoverage_0x4067563c(0xf5f6a26bd8d3ece9701d8b55788cd023ea78c2857081270567487ea5323654a2); /* line */ \n        coverage_0x4067563c(0x58cd8adb7b39d84041f98024022d5613afd9c7747fca114b4cb9985d3baf359b); /* statement */ \nuint activeAmount = 0;\ncoverage_0x4067563c(0x545296ec90083c7699511cd93e181f63297b16f76988b226f15c336a99e69f53); /* line */ \n        coverage_0x4067563c(0x3dca8fc4982c8fc9ebbab5a2baa3ad616bc21ad22365041d260b60effbbf0bfd); /* statement */ \nfor (uint i = 0; i < schainsForNodes[nodeIndex].length; i++) {\ncoverage_0x4067563c(0x42abc5a545f872c3ea7e04c7322c556be00aab50f53805e73dd46bd34cde9d60); /* line */ \n            coverage_0x4067563c(0x611204926ca42240bbd02f67c102863f6971f459304fcdb4d70a9d5b0c8a9000); /* statement */ \nif (schainsForNodes[nodeIndex][i] != bytes32(0)) {coverage_0x4067563c(0x103fe790064b91167a498c7f7ad0674ea9346b826a391a8cf66a30963b9d36ab); /* branch */ \n\ncoverage_0x4067563c(0x528afdd33eb5df80317f7ed860d64bc2774bb9ba9269de44edc04a51e0f75867); /* line */ \n                activeAmount++;\n            }else { coverage_0x4067563c(0xf4f7103bc7d8da31ff928ba8481bbfe5a0439a1af1c01a6801a6934e48837403); /* branch */ \n}\n        }\n\ncoverage_0x4067563c(0x9bb3337998a2037f04ccc3beda8d9bcc37a0da403a8e930232359de41673f0e8); /* line */ \n        coverage_0x4067563c(0xe4679ebe97526a65da47fd5656a96804b75e5d3f8cb95208d75c1ecb748f7bc8); /* statement */ \nuint cursor = 0;\ncoverage_0x4067563c(0x6ed6eaa4302f0df6b151c0627988df6b754f4b8e2cbce789c60be01cbc0b6b22); /* line */ \n        coverage_0x4067563c(0xbe40c3ca75fa9d6629e8edd44ee3ccae1d4f8d2cd3f9691b80264179c3cf2557); /* statement */ \nactiveSchains = new bytes32[](activeAmount);\ncoverage_0x4067563c(0xd1d0600a160fbbb6c600356d301368dc4e84810436294029c73dcae8352562b6); /* line */ \n        coverage_0x4067563c(0xb1412390d8bda9b070d92aee39a749472a44bbdf3b72a75517342c6d971e76ad); /* statement */ \nfor (uint i = 0; i < schainsForNodes[nodeIndex].length; i++) {\ncoverage_0x4067563c(0x34878ca9c2ef903e8b4a6a33c6d366f3a3635b85cf4086646419799b3d2b3176); /* line */ \n            coverage_0x4067563c(0xb81a2f5b0949774e6eec75ee0bf2cab52ff88c4808948fe7ad6847b10dbda5b4); /* statement */ \nif (schainsForNodes[nodeIndex][i] != bytes32(0)) {coverage_0x4067563c(0x96e482f7b1bd5e399b8c54d8ad064a4f3d2ec8d408d4532fe6268930cd6c6c76); /* branch */ \n\ncoverage_0x4067563c(0x92a495f4bba53b11101ea44a4b2981f240672aedacbec17ef7a7b1d439dab888); /* line */ \n                coverage_0x4067563c(0xef9b6f0164e3541bc38da8b3a61f2b9dfc34692fff368cd00d160332e11591dc); /* statement */ \nactiveSchains[cursor++] = schainsForNodes[nodeIndex][i];\n            }else { coverage_0x4067563c(0xfe01e10b44628ed1581f6773df08751fde229049204cf93b37d5244afbab5181); /* branch */ \n}\n        }\n    }\n\n}\n"
    },
    ".coverage_contracts/SchainsFunctionality.sol": {
      "content": "/*\n    SchainsFunctionality.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.3;\npragma experimental ABIEncoderV2;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/ISchainsData.sol\";\nimport \"./interfaces/IConstants.sol\";\nimport \"./interfaces/IGroupsData.sol\";\nimport \"./interfaces/ISchainsFunctionality.sol\";\nimport \"./interfaces/ISchainsFunctionalityInternal.sol\";\nimport \"./interfaces/INodesData.sol\";\nimport \"./SchainsData.sol\";\nimport \"./SchainsFunctionalityInternal.sol\";\nimport \"./thirdparty/StringUtils.sol\";\n\n\n\n/**\n * @title SchainsFunctionality - contract contains all functionality logic to manage Schains\n */\ncontract SchainsFunctionality is Permissions, ISchainsFunctionality {\nfunction coverage_0x80b19128(bytes32 c__0x80b19128) public pure {}\n\n\n    struct SchainParameters {\n        uint lifetime;\n        uint typeOfSchain;\n        uint16 nonce;\n        string name;\n    }\n\n    // informs that Schain is created\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 groupIndex,\n        uint32 time,\n        uint gasSpend\n    );\n\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainId\n    );\n\n    event NodeRotated(\n        bytes32 groupIndex,\n        uint oldNode,\n        uint newNode\n    );\n\n    event NodeAdded(\n        bytes32 groupIndex,\n        uint newNode\n    );\n\n    string executorName;\n    string dataName;\n\n    constructor(string memory newExecutorName, string memory newDataName, address newContractsAddress) Permissions(newContractsAddress) public {coverage_0x80b19128(0x0671878758df295becc8a97a80de1d5fa25286878794cdb3c4918406bc366645); /* function */ \n\ncoverage_0x80b19128(0x3fa1a5ab78404e0f728c7fd999aa5ce5d33200666bb73dba3a448f338dffb2ed); /* line */ \n        coverage_0x80b19128(0x37ed8a100aa3e9de40eb1025361aeef56706b89be87fe6447b1c1e173cbd0df9); /* statement */ \nexecutorName = newExecutorName;\ncoverage_0x80b19128(0x1c8ffdd14311def7155b99424b882411fb2d2c1bfb60d9ed860fbabad8b527e2); /* line */ \n        coverage_0x80b19128(0x9c24f7f28980d2ff5a0951a76c9f0a755effd17b81e3c639c0dedd53c25c1a2a); /* statement */ \ndataName = newDataName;\n    }\n\n    /**\n     * @dev addSchain - create Schain in the system\n     * function could be run only by executor\n     * @param from - owner of Schain\n     * @param deposit - received amoung of SKL\n     * @param data - Schain's data\n     */\n    function addSchain(address from, uint deposit, bytes calldata data) external allow(executorName) {coverage_0x80b19128(0x3cf5f975ad4a6a64cf5646dd29f77bb173d47bbbf727bb996fd33c9ab1f5c8bf); /* function */ \n\ncoverage_0x80b19128(0x3dbf5036695af89ccdfaf90b91667b16b67cf5213fabba74850d9b84d5e08210); /* line */ \n        coverage_0x80b19128(0x1e30ccfe58498d12abb399b0257c56cd3d4a43d587f6e72a9ea73b3ff7c8905f); /* statement */ \nuint numberOfNodes;\ncoverage_0x80b19128(0x971de7e34e6c8e85871b67b8f7c77528d3446495fdd8de8cc79cf5c96da045a5); /* line */ \n        coverage_0x80b19128(0xce1d498a9694b12959b564585888217703e6623b5b6a40744c981cec55c5c4a5); /* statement */ \nuint8 partOfNode;\n\ncoverage_0x80b19128(0xf7a0e21ada45c7b7742cd12d278af6946a42a8c1dd36c25afc37ebbdac723242); /* line */ \n        coverage_0x80b19128(0xb4e8a8274ca7df984c38c1cfeac01a525062105065e100c9f6caa79ffb3f1cb4); /* statement */ \naddress schainsFunctionalityInternalAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionalityInternal\")));\n\ncoverage_0x80b19128(0xe92fa2b923a77b83d2d137bb0083d947049974ebab722af3b1e537b86a27f9ee); /* line */ \n        coverage_0x80b19128(0xa110d72e0e0ad5d3f258662ce9de21b63708321647e8c3a997e4fe3422ac1d19); /* statement */ \nSchainParameters memory schainParameters = fallbackSchainParametersDataConverter(data);\n\ncoverage_0x80b19128(0xcf78085a1dc16bffbdccda0b8a3a7d763638dfc67243ead6556d1dea5e101a9c); /* line */ \n        coverage_0x80b19128(0xe84d1aa72b1c114612c74fcdbf399f07cf7f5ff481637161450207e8d36ce4c9); /* assertPre */ \ncoverage_0x80b19128(0xc3195233e8184465ced4cfd4e18ae52c851f9ea0d3da75050c0f795b50ebfcba); /* statement */ \nrequire(schainParameters.typeOfSchain <= 5, \"Invalid type of Schain\");coverage_0x80b19128(0xf3ed177a7f85e3227430406bd98e64cc839505bef177c296cd1599cca9a778d3); /* assertPost */ \n\ncoverage_0x80b19128(0xf8420081dcd47931c796c626c9b113e35253a5c984940e7f21358d34445f8f44); /* line */ \n        coverage_0x80b19128(0x2545709314328c0790921bd0b9530b3b5e0539f93afa3e41d20aa65a4a5138fe); /* assertPre */ \ncoverage_0x80b19128(0x7666e62063f86b72812369f06a05c6aca93fd9d4ca19560369f6e65140130e93); /* statement */ \nrequire(getSchainPrice(schainParameters.typeOfSchain, schainParameters.lifetime) <= deposit, \"Not enough money to create Schain\");coverage_0x80b19128(0x5f952aa6bdda568879d325c0245fa9d51e87266c7861d3ed25e1df502f390313); /* assertPost */ \n\n\n        //initialize Schain\ncoverage_0x80b19128(0x6e63ef6e47a6d7a1c128bdd073c3ff3256ead16bff72e9f53412c7e9a694aa76); /* line */ \n        coverage_0x80b19128(0x726f92d91e3e6b8a0a8007c2a74e77ba9969efe2c14a4ed7e9c190ae07ab640c); /* statement */ \ninitializeSchainInSchainsData(\n            schainParameters.name,\n            from,\n            deposit,\n            schainParameters.lifetime);\n\n        // create a group for Schain\ncoverage_0x80b19128(0x726f00c05a21ca78bc10408941478c1282f4d5c660c7ae1f62670eb6bb4625c0); /* line */ \n        coverage_0x80b19128(0x9b984f52237f70948e02407fcae5e199c095ef6a4f861c42dc02821e088fd4aa); /* statement */ \n(numberOfNodes, partOfNode) = ISchainsFunctionalityInternal(\n            schainsFunctionalityInternalAddress\n        ).getNodesDataFromTypeOfSchain(schainParameters.typeOfSchain);\n\ncoverage_0x80b19128(0x87f761e5b22066a09fe9afd23552cc9ea80c93d989e673abb0166bd65d789892); /* line */ \n        coverage_0x80b19128(0xb5e006e2306449d611aea339b04b120a01898b476561422b0aded7d19e6dbcd2); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).createGroupForSchain(\n            schainParameters.name, keccak256(abi.encodePacked(schainParameters.name)), numberOfNodes, partOfNode);\n\ncoverage_0x80b19128(0x0e51739f8b7102c9bcfd984a76a107c743228981eb51076eff8e74c6ba11f266); /* line */ \n        coverage_0x80b19128(0xbedda70a874f50e729b7e9a0a1e93f3c80b3b2704e4c2c8f49251f6e3cb1907b); /* statement */ \nemit SchainCreated(\n            schainParameters.name, from, partOfNode, schainParameters.lifetime, numberOfNodes, deposit, schainParameters.nonce,\n            keccak256(abi.encodePacked(schainParameters.name)), uint32(block.timestamp), gasleft());\n    }\n\n    /**\n     * @dev getSchainNodes - returns Nodes which contained in given Schain\n     * @param schainName - name of Schain\n     * @return array of concatenated parameters: nodeIndex, ip, port which contained in Schain\n     */\n    /*function getSchainNodes(string schainName) public view returns (bytes16[] memory schainNodes) {\n        address dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\n        bytes32 schainId = keccak256(abi.encodePacked(schainName));\n        uint[] memory nodesInGroup = IGroupsData(dataAddress).getNodesInGroup(schainId);\n        schainNodes = new bytes16[](nodesInGroup.length);\n        for (uint indexOfNodes = 0; indexOfNodes < nodesInGroup.length; indexOfNodes++) {\n            schainNodes[indexOfNodes] = getBytesParameter(nodesInGroup[indexOfNodes]);\n        }\n    }*/\n\n    /**\n     * @dev deleteSchain - removes Schain from the system\n     * function could be run only by executor\n     * @param from - owner of Schain\n     * @param name - Schain name\n     */\n    function deleteSchain(address from, string calldata name) external allow(executorName) {coverage_0x80b19128(0x60ceb89f2c0f140396387d4b334251b080fa5cd764ffb31a5826c00cef4a3c4a); /* function */ \n\ncoverage_0x80b19128(0xc9b3b2cf3cf000ec8568f27173535bf3210c364a54f98fca1e5dad12aaabe240); /* line */ \n        coverage_0x80b19128(0x491878060f55fab3ce2aa2fcafa6df2d63b34bf90a831ad1da611c8b1e5090f7); /* statement */ \nbytes32 schainId = keccak256(abi.encodePacked(name));\ncoverage_0x80b19128(0x8bccdfff7e89cf538235151a4fc04213137ccfce33ef4ced47897ee5e6b7d97b); /* line */ \n        coverage_0x80b19128(0xca14d139db1a7a0d117f207eb0d768762acd52e62472dca5496cf1f9adc676a9); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\n        //require(ISchainsData(dataAddress).isTimeExpired(schainId), \"Schain lifetime did not end\");\ncoverage_0x80b19128(0x11272f2c518d3551cc6e1c599dcd57286f9c26f62709f48dc866f229aa72c399); /* line */ \n        coverage_0x80b19128(0x578b1a453676c7b7dd2006b2c333c908e79494e70f1b252508aa85ab42ead8d5); /* assertPre */ \ncoverage_0x80b19128(0x527d16c36f4acc87d482e40ff6f382cbce175f4f120b6e3dd97b4dd7a6220149); /* statement */ \nrequire(ISchainsData(dataAddress).isOwnerAddress(from, schainId), \"Message sender is not an owner of Schain\");coverage_0x80b19128(0x4b5dffddec3e1ee2bf408091851a0928944e2f5eed7b4d438f2e7b163fbab061); /* assertPost */ \n\ncoverage_0x80b19128(0x71311c6793b9c13ced160df2a3dec9abf165165cb73076e5038ce0c6dcb1a09d); /* line */ \n        coverage_0x80b19128(0x775ec0dae900da4ed06ec64c75c05ef7ed73a63a633f46e6a5c5a0fb373ef5bf); /* statement */ \naddress schainsFunctionalityInternalAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionalityInternal\")));\n\n        // removes Schain from Nodes\ncoverage_0x80b19128(0x24bbad0d6b291e42ed38ae80a5f2b61e32acc1801a884d13f2bd1ad3c18782d4); /* line */ \n        coverage_0x80b19128(0x705900a3d7d346b3d84ed6efe4f494a2ba0cea411a3607bd69287854cd642ae0); /* statement */ \nuint[] memory nodesInGroup = IGroupsData(dataAddress).getNodesInGroup(schainId);\ncoverage_0x80b19128(0xcbd77b30228ba2aeb4635d06041fe14083816ed51c1bf346255a700742e4555a); /* line */ \n        coverage_0x80b19128(0x4e9b972a795ec973b97bc99b22aabea5e86427e51fd008720bed91f52e6e7ed1); /* statement */ \nuint8 partOfNode = ISchainsData(dataAddress).getSchainsPartOfNode(schainId);\ncoverage_0x80b19128(0x9162c105e3be71bd249d91876c411e75e034cb38a88d67c7eabc7ce782de588f); /* line */ \n        coverage_0x80b19128(0xe0d4b1fceec8c41d90d79a96dd03c4201265e744d275cdcbda7d22a0d00b8363); /* statement */ \nfor (uint i = 0; i < nodesInGroup.length; i++) {\ncoverage_0x80b19128(0x2035667241629ae203995060b44e5d20982de8241e7ed5b3f7755d9a7dd76c49); /* line */ \n            coverage_0x80b19128(0x0f082dfb348dde11fbc12fc7865ae25cc5d3fc2dd5d94d1cb4151e6aa5c0f078); /* statement */ \nuint schainIndex = ISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).findSchainAtSchainsForNode(\n                nodesInGroup[i],\n                schainId\n            );\ncoverage_0x80b19128(0x925fa4650da3d5bbcf212fb7f217914ee5296b72b067e9ef0f16122c8920f5e2); /* line */ \n            coverage_0x80b19128(0xe915a69de9e2e3b8247905ebdd83bcc5616969b0a86fb164f920234c196ee034); /* assertPre */ \ncoverage_0x80b19128(0x2a7813030b681493f2399b8c076b7f2a944c6917038b7e5cd3e4dc0590d5769b); /* statement */ \nrequire(\n                schainIndex < ISchainsData(dataAddress).getLengthOfSchainsForNode(nodesInGroup[i]),\n                \"Some Node does not contain given Schain\");coverage_0x80b19128(0x61b6f5c6ab4c494dd6ca8b4dd2d6aec32d110428a68ce181873bac5f0811e8e2); /* assertPost */ \n\ncoverage_0x80b19128(0x48df4351ede1bd28347bb5d29919236895e488236c9532313f334838a3b2fbe6); /* line */ \n            coverage_0x80b19128(0x03b1e5d46f2fd26154dacb5f1429f18395389d0ccbb308f603fd5d973047d306); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).removeNodeFromSchain(nodesInGroup[i], schainId);\ncoverage_0x80b19128(0x742ec53ccd90ee015d428f701bc2f1292dba6ab1291da3b2040ffef01b18a61d); /* line */ \n            coverage_0x80b19128(0x3bd89bf21907d2422afc0ec5c4a7ee63c1f1e430ad2b569813ca0e58b106e50a); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).removeNodeFromExceptions(schainId, nodesInGroup[i]);\ncoverage_0x80b19128(0xb201d931ffab10cdec605ee90c65915ea156093189070fb1e77a55c47dae9a7f); /* line */ \n            coverage_0x80b19128(0x49e68ca2be4cc25d67cdc77df1e03f5d0e7a6642a77a640f7a8305ab632ebd14); /* statement */ \naddSpace(nodesInGroup[i], partOfNode);\n        }\ncoverage_0x80b19128(0x9fa936d8530603a52f455c35125ff2f451b510c2c3fa8290056652d382d9f6c1); /* line */ \n        coverage_0x80b19128(0xbe42d66153071d850b5a22abd3b9aca0549baddeb256b9e5de44a02c9301c0bc); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).deleteGroup(schainId);\ncoverage_0x80b19128(0xfa21aeb4dd85cd79d37617df9a739fc833a67737be967723c3319b9b1cf05025); /* line */ \n        coverage_0x80b19128(0xa330f584c15c96284d5a9a66cdbfde244df213e31021a45d1fe6a2f519a5b77a); /* statement */ \nISchainsData(dataAddress).removeSchain(schainId, from);\ncoverage_0x80b19128(0x83c71c9705c9b44c6768540d4557ac1bedd3c0eba0b2d455aa3cb2c1826ce3c5); /* line */ \n        coverage_0x80b19128(0x5b1c527f7da5044602b8c5734178359862208b147926f33c9a2a4c7e8ce92b5b); /* statement */ \nemit SchainDeleted(from, name, schainId);\n    }\n\n    function deleteSchainByRoot(string calldata name) external allow(executorName) {coverage_0x80b19128(0x12106eddd20d364c74aea54ca4cf93993e5fc741465a08a182af923e8e6f7e54); /* function */ \n\ncoverage_0x80b19128(0x3c122246126a7f392a730a14984580228b7971937669704e12a12790df641b36); /* line */ \n        coverage_0x80b19128(0x03f956954dd80a4411887ccb2a96e0033ad1126ed13980dfd7085f7c452c685f); /* statement */ \nbytes32 schainId = keccak256(abi.encodePacked(name));\ncoverage_0x80b19128(0x00396e0aaed0ff8fa757aa9ca72623a4090099ef2773496b7ee1853b237d0f04); /* line */ \n        coverage_0x80b19128(0xdd87009483d93836083896e50d2f21eede80b9fc672249d3fc708deaf64ecd5f); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0x80b19128(0x59aaa8994f5db4d1e582d74ad044e33d264a7f32c0a0cc8682e33ff58ce13019); /* line */ \n        coverage_0x80b19128(0xee0ea980df2cabfd674f8f6cc15db2a4ac8ac370431cc0c8f6a41f72bd3d6a52); /* statement */ \naddress schainsFunctionalityInternalAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionalityInternal\")));\ncoverage_0x80b19128(0x572a4595b1841d884822d92815596bdd3d27e03ff9af5ffff595cd1f555b8d03); /* line */ \n        coverage_0x80b19128(0x5b870a46944d7c72ad5a4089c82e58be12efc117e2115a2bc3acc7e33bcf512e); /* assertPre */ \ncoverage_0x80b19128(0xbf23020602801a7a2839f0e99b7bc82e50c204d6aca87fd7fa08ee92cc259c78); /* statement */ \nrequire(ISchainsData(dataAddress).isSchainExist(schainId), \"Schain does not exist\");coverage_0x80b19128(0x7b5a6d6a10a538ef7a0038c49d48ce9ed60be7a023e8e8933ca9158f6a7e4113); /* assertPost */ \n\n\n        // removes Schain from Nodes\ncoverage_0x80b19128(0x9b39b8abd7d432ac5fd3450553abaeff1ed31e5070f6f90a76e6ba8a5f085788); /* line */ \n        coverage_0x80b19128(0x01f40e35e72b550ebd28537a0daf056085ce4718cfb41118f76d0cbd769898f3); /* statement */ \nuint[] memory nodesInGroup = IGroupsData(dataAddress).getNodesInGroup(schainId);\ncoverage_0x80b19128(0xdc1b8b56dca58a9cb4b51103e7aee63e17d9ab0e0db8559b66ad3bcfb5f5e6a5); /* line */ \n        coverage_0x80b19128(0x715cac8209433ed90517602da84d447fb8314cd0888c92793b9fb076e81f2c85); /* statement */ \nuint8 partOfNode = ISchainsData(dataAddress).getSchainsPartOfNode(schainId);\ncoverage_0x80b19128(0x19018c9cb9b60e2ba7f66fe68347a4672c2148ba15bfbfcaa0f6bf6547fbb226); /* line */ \n        coverage_0x80b19128(0xc147f54df3f549b2e61a1b9f119e74eeedd44071756e6454569542dfab609bd7); /* statement */ \nfor (uint i = 0; i < nodesInGroup.length; i++) {\ncoverage_0x80b19128(0x64671c3ac75eba52bad2feb24167e9000ddfe38b8e03fff32680beec7b612c4b); /* line */ \n            coverage_0x80b19128(0x2e0b8a1068d6820b7d7bf5410e9fd25a689b78867861c7b37cce5f9c99cf0c80); /* statement */ \nuint schainIndex = ISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).findSchainAtSchainsForNode(\n                nodesInGroup[i],\n                schainId\n            );\ncoverage_0x80b19128(0xc1af5cc8c872463fa50a9930995bbeb62d5a71286391d2f3e3965d614532b8e0); /* line */ \n            coverage_0x80b19128(0x92ad12acac7c7babafdc4fc6510eed7a40643ecf34040b413cedd1abcf8f83cb); /* assertPre */ \ncoverage_0x80b19128(0x158cd9ce4b2e052df8172041df756fca2a00de8b1242b703e124a3af680cc051); /* statement */ \nrequire(\n                schainIndex < ISchainsData(dataAddress).getLengthOfSchainsForNode(nodesInGroup[i]),\n                \"Some Node does not contain given Schain\");coverage_0x80b19128(0x5f13f963e7906229f244c1e856e95ef8cf25301eefefc454ba6e1cf05eb09a64); /* assertPost */ \n\ncoverage_0x80b19128(0xeceb6a60432b7c18a8aeec60fab7a0905ebb7b7dc73ebf1b42b9160e8d4ac317); /* line */ \n            coverage_0x80b19128(0xc33e279dc1c73f5123f53b1792c2cae80095132a8bf75d5d82967d6160be7565); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).removeNodeFromSchain(nodesInGroup[i], schainId);\ncoverage_0x80b19128(0x564c567cb428f385f0b6e098b1910d9df8217ab7da16ca19fe72d9c3a3fe4527); /* line */ \n            coverage_0x80b19128(0x2b7d8e9124dea0ff62f7694cfa49c47014dc1748cd0caac5ea17c63adbd5c02d); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).removeNodeFromExceptions(schainId, nodesInGroup[i]);\ncoverage_0x80b19128(0xbbd840106d8c2aaee8f3ed687d81fee112c7c4af31e94f1746baf5aec72b7b65); /* line */ \n            coverage_0x80b19128(0x664e77332b4e33b7ed74bd4d238a629e4d5b804d83d57471e1556279fcbc5fde); /* statement */ \naddSpace(nodesInGroup[i], partOfNode);\n        }\ncoverage_0x80b19128(0x8598eef9b4cd4c016a343c5ceb9ae81d939f56bbac3d2c609c9a2494123bee5d); /* line */ \n        coverage_0x80b19128(0x4a47b55d116a634208052f4526b6048416c0742591d53bc32b1dea976c274059); /* statement */ \nISchainsFunctionalityInternal(schainsFunctionalityInternalAddress).deleteGroup(schainId);\ncoverage_0x80b19128(0x83da8a6b3f39e3f6e91158d6f478a9e50cd24725f06ba5e9d3b01b68103bb776); /* line */ \n        coverage_0x80b19128(0x57abc1f56e5aac32bb763287c1d32bbf0c58a7229f9068489f3ca5360e68ac37); /* statement */ \naddress from = ISchainsData(dataAddress).getSchainOwner(schainId);\ncoverage_0x80b19128(0xce2454deef748dd284b8d9745a9cb3f886c1362736e0de22ab61c051e4219acf); /* line */ \n        coverage_0x80b19128(0xd673c19f9db0572c8cf91c9fb7611ec50630f45d526583ee746319ce199e9b96); /* statement */ \nISchainsData(dataAddress).removeSchain(schainId, from);\ncoverage_0x80b19128(0xcf566aab42f303052f46f153533af2c5dbc6f04546650d8036360daad976c51e); /* line */ \n        coverage_0x80b19128(0xceac7765bb55fca46e23191776cd26355ce839c1ef21809c15555a91f72728c8); /* statement */ \nemit SchainDeleted(from, name, schainId);\n    }\n\n    function exitFromSchain(uint nodeIndex) external allow(executorName) returns (bool) {coverage_0x80b19128(0x55d203a977c6c74935a955a7c7afea1a425c884a8fa3b3f72b0f1b8c70bb86d1); /* function */ \n\ncoverage_0x80b19128(0x6c0afc665a95e0a61b92f81f2c6a0f9a5536fc152ff15b8ae6f82814b293f146); /* line */ \n        coverage_0x80b19128(0x930f807e5f1745d4a5e65f08cb6ab644059a86958eb183f32ffc7007a1bc5765); /* statement */ \nSchainsData schainsData = SchainsData(contractManager.getContract(dataName));\ncoverage_0x80b19128(0x3adb6ea431dab8d43d3f14ca8fba81e4007ca5ab1bb5679f25f5dba58e735ec0); /* line */ \n        coverage_0x80b19128(0x247e07122be80977a48ea83edd7e7ea6b4052d0103fb12c947dfd02b6f6b769c); /* statement */ \nbytes32 schainId = schainsData.getActiveSchain(nodeIndex);\ncoverage_0x80b19128(0x7e85cdf6a97a0d38eeee72855c1086388a5e33652fc243b0841364b9ec2997c3); /* line */ \n        coverage_0x80b19128(0x1c8bb078d8918781a74242db0be6773036c9c18227b539242fa0fd054c5117eb); /* assertPre */ \ncoverage_0x80b19128(0x1d4a4aa46d3b9d3191a2ff583a369c82217cad845a254a4e0c154936b00de63b); /* statement */ \nrequire(this.checkRotation(schainId), \"No any free Nodes for rotating\");coverage_0x80b19128(0x8869e6656ebfc8d78d46b965ab33dd9892e20b124a9c89c72e3a6976b3e4e970); /* assertPost */ \n\ncoverage_0x80b19128(0x13dfbb031688d5bdc7d2d91ac0eb7466f2047e513fbfb9d8294d19cf6e1b2bac); /* line */ \n        coverage_0x80b19128(0x94254b538a9eceb4d9ca28dfc68892c20af388194304eedbb0df65255efb6fa5); /* statement */ \nuint newNodeIndex = this.rotateNode(nodeIndex, schainId);\ncoverage_0x80b19128(0x36f19c2ee783476e156b648172c1c4bb24963bcce2a524f59ed56ba10c10d29b); /* line */ \n        coverage_0x80b19128(0xe83a82544811128e4bb8e6b9857a26a23affdd1b9e88d34459dbe936f346e841); /* statement */ \nschainsData.finishRotation(schainId, nodeIndex, newNodeIndex);\ncoverage_0x80b19128(0x7353d0ea257df51e3978ed60fc41ececf3c292c52589204d3a27184cc3456eb1); /* line */ \n        coverage_0x80b19128(0x3d7fbbd65f8df523e429b1666fc950813f971f49584a03100ae88012e0f13f01); /* statement */ \nreturn schainsData.getActiveSchain(nodeIndex) == bytes32(0) ? true : false;\n    }\n\n    function checkRotation(bytes32 schainId ) external view returns (bool) {coverage_0x80b19128(0x63035c86c876f3414374eaf3c8d328b800991aa2b918c1f02851c94845b22cbb); /* function */ \n\ncoverage_0x80b19128(0x2eb74ddc4fd8eecb31e6239e35c877dbfcffdab49eb596708241d598705b59b9); /* line */ \n        coverage_0x80b19128(0xf090d28b24bc2511b161d499186d7b1f67da1ae1694881a603037ba3c05a1d09); /* statement */ \nSchainsData schainsData = SchainsData(contractManager.getContract(dataName));\ncoverage_0x80b19128(0x75a3f80b5793d1ef6386e467c42e0f946afe83c622f44e837a7b4bdd2d0085b8); /* line */ \n        coverage_0x80b19128(0x3c9bfcee46fb6646e47589f9cb529cce25296d78a767e43c48b1e1cc373d8320); /* assertPre */ \ncoverage_0x80b19128(0x7a9116c990c4fce88e6feb332543c64e04958e37f160c063df427c6b20cbc62c); /* statement */ \nrequire(schainsData.isSchainExist(schainId), \"Schain does not exist\");coverage_0x80b19128(0x00c10b0a66ad23753456c139f707dc710c16cadc01e8d989bef324232428b151); /* assertPost */ \n\ncoverage_0x80b19128(0xdd10757d1fb367516f15ecd3ae91565ad32611a3f32d45d7340888e1297952dc); /* line */ \n        coverage_0x80b19128(0x93001c9c36406da8ce36fa5b320a30536d6707789d48044069622e67e5ef5efb); /* statement */ \nSchainsFunctionalityInternal schainsFunctionalityInternal = SchainsFunctionalityInternal(\n            contractManager.getContract(\"SchainsFunctionalityInternal\"));\ncoverage_0x80b19128(0xa1643cc615e128fa20ef81cc6e12a60723dfe1a9043c63298533193ea0f38e01); /* line */ \n        coverage_0x80b19128(0x0c918d263f2f77052d5648e5a7a991c01556397e4e44ba985347de93b831cf08); /* statement */ \nreturn schainsFunctionalityInternal.isAnyFreeNode(schainId);\n    }\n\n    function rotateNode(uint nodeIndex, bytes32 schainId) external allowTwo(\"SkaleDKG\", \"SchainsFunctionality\") returns (uint) {coverage_0x80b19128(0xbbfe7e6b8d4abe94efdab119c755fcc94d9fc09c78251260c14d4377a8f13598); /* function */ \n\ncoverage_0x80b19128(0x4d74f62ee2b1a943fb7cda213c8f31a42ae9eedc72d95e9c5ea68bad72c329bf); /* line */ \n        coverage_0x80b19128(0xa14601092aced460f61f412ee20ab6ded093704d54c9268b884c630c4766b6e9); /* statement */ \nSchainsFunctionalityInternal schainsFunctionalityInternal = SchainsFunctionalityInternal(\n            contractManager.getContract(\"SchainsFunctionalityInternal\"));\ncoverage_0x80b19128(0x8aba75748a2b172f52c0a890985da81fcfebb172927944258d0e3c9db4ec679b); /* line */ \n        coverage_0x80b19128(0x1e9c4175cf4dc9bd804db0dfd94a0043c91ae04b03113d747f8157b622d4de91); /* statement */ \nschainsFunctionalityInternal.removeNodeFromSchain(nodeIndex, schainId);\ncoverage_0x80b19128(0x8bab65dd300fac1d3334fa25986df2dd6db5afcc413b9b45c272918349e1e011); /* line */ \n        coverage_0x80b19128(0x23265cfcd187a2c1ff3609269e75c1a42dde733246fad1dc873f363584c217f4); /* statement */ \nreturn schainsFunctionalityInternal.selectNodeToGroup(schainId);\n    }\n\n    function freezeSchains(uint nodeIndex) external allow(executorName) {coverage_0x80b19128(0xaaf8eb6ca63877aba3fad518bbe23507402a787d776161edbd62056531b1aa6e); /* function */ \n\ncoverage_0x80b19128(0x6d5943e7205d9dce92199d462c99a86b731244639e933de02d64c7bd5e2f7087); /* line */ \n        coverage_0x80b19128(0xe1bb0526669a995cf226485b885634e38f301d9b362d515aba4c588fb63b0565); /* statement */ \nSchainsData schainsData = SchainsData(contractManager.getContract(\"SchainsData\"));\ncoverage_0x80b19128(0xfc00e719d431cc0609298aa0de503214fde66a7eedbe86d48831e83538a0f818); /* line */ \n        coverage_0x80b19128(0xfe1ca4ee02a4acea932df1f00d20c69697bb449da0d0bb00f632d89f484d626c); /* statement */ \nStringUtils stringUtils = StringUtils(contractManager.getContract(\"StringUtils\"));\ncoverage_0x80b19128(0xb1482e3ebd42c154abe2033f1aec17dd96219b403cc37ed93fee6df5e12a840b); /* line */ \n        coverage_0x80b19128(0x7891d4d02ded9bce1e9cdc331255b7a343df92b700af9bec3f2d288ae0c28276); /* statement */ \nbytes32[] memory schains = schainsData.getActiveSchains(nodeIndex);\ncoverage_0x80b19128(0xcb10002ddb20dd6a35cd67f03f094693df5c3b2fea10cfb397e3e711fa527780); /* line */ \n        coverage_0x80b19128(0x1e8d90dee1fe0e66b0acfdbba5cb3f086c4d94e8292d61bc99546e3050104c5f); /* statement */ \nfor (uint i = 0; i < schains.length; i++) {\ncoverage_0x80b19128(0x01ad0a8b2d1f0cb98a84e505a0ed4c90fe32e63f91346b87a8e976d7a6204e18); /* line */ \n            coverage_0x80b19128(0x5c5166df6416c1f5676e36d879f7d03f1ff536789c1610eb0c3dc9640d9d733a); /* statement */ \nSchainsData.Rotation memory rotation = schainsData.getRotation(schains[i]);\ncoverage_0x80b19128(0x9bb9e01b97c2bd0d719dbee892752ca20ea44f6a0a838842de9042df88ccfd01); /* line */ \n            coverage_0x80b19128(0xfa856682af4960b5be1f1409156c806a67e2ec06327274e30e9b63ea87dc74e7); /* statement */ \nif (rotation.nodeIndex == nodeIndex && now < rotation.freezeUntil) {coverage_0x80b19128(0x0ae3ced1f17fdb8e876bc464cd1236e4df05adf10f7c841fad5319e5a15002be); /* branch */ \n\ncoverage_0x80b19128(0xc2abc7465b2f4cac4a8207494fff01c41d4ef91fdf187d15dbbbe436d68a2f2a); /* line */ \n                continue;\n            }else { coverage_0x80b19128(0x0b1582957ff772db4e7907ab26c35c0574edbb5a76c99c580f3cfe3d938077b6); /* branch */ \n}\ncoverage_0x80b19128(0xc23c0e3db801d5d08e04dde7c2325e79808ef53b1a2ce12f65009e7a4940a307); /* line */ \n            coverage_0x80b19128(0xc16ec58ab577872143461f7c0a77f60c53f95200036a3d238e2ef1c76650eefc); /* statement */ \nstring memory schainName = schainsData.getSchainName(schains[i]);\ncoverage_0x80b19128(0xbe8e689efb1ca6b7a24525e976ddef3620aa152d86636e9353e0050bf3bd8589); /* line */ \n            coverage_0x80b19128(0xd5c9f4e967d0d20b5fe739f173d1afd19c81f0a5c2381a6a5d6be26704dd455a); /* statement */ \nstring memory revertMessage = stringUtils.strConcat(\"You cannot rotate on Schain \", schainName);\ncoverage_0x80b19128(0x1990912ad7af733872123cf1f4dd8e4abe1cd09ca812035e9afc1a0816bc6389); /* line */ \n            coverage_0x80b19128(0x8c5ee5007613faaf844622e4909aa17cd879df1cd6a5fe90562a3ecd062b661e); /* statement */ \nrevertMessage = stringUtils.strConcat(revertMessage, \", occupied by Node \");\ncoverage_0x80b19128(0x086fa7f3d11500b542d35b003df619b4eb9915851d3d7fa78dcb93307add480a); /* line */ \n            coverage_0x80b19128(0xdca764df9ebee5539ccc246fe577274c6a5448cd9cdbf3d3ba829caef9921a81); /* statement */ \nrevertMessage = stringUtils.strConcat(revertMessage, stringUtils.uint2str(rotation.nodeIndex));\ncoverage_0x80b19128(0x8db26fff9c2ecd2c93d33c3641c46330fc0367496575436618228c4f6cbd234d); /* line */ \n            coverage_0x80b19128(0x82c4d1413026a1f77dcccd06d8e0fbe59752f3cafe2c6fadd78577b4f33530ff); /* assertPre */ \ncoverage_0x80b19128(0x471eba378a2d68f50b565c33062dc03bf9f512537d0fff41abad3d799e434dee); /* statement */ \nrequire(rotation.freezeUntil < now, revertMessage);coverage_0x80b19128(0x1fe81663708db6a2ef18b3358196d61275d672745186f42eacaa44cf8efacdeb); /* assertPost */ \n\ncoverage_0x80b19128(0xdb377e3f75f8e79c521143689864d1b4490a5c92e15085adfb6ace3549823f29); /* line */ \n            coverage_0x80b19128(0x78c15d71a95040f1e4fc62e206d8d97ed8034efb06014a3128fcadab245d32c1); /* statement */ \nschainsData.startRotation(schains[i], nodeIndex);\n        }\n    }\n\n    function restartSchainCreation(string calldata name) external allow(executorName) {coverage_0x80b19128(0x0ee27d59bd9e9b077397d49e92effc0bad5b85fe5211a6a1b1c46a07f4e30f5b); /* function */ \n\ncoverage_0x80b19128(0xb8a1d48f272374e18f125312e4f7d8a21bf9ab9ca55ea20bf7342f3aca7af751); /* line */ \n        coverage_0x80b19128(0xcbb7899ecd3d32c99a7ed5fa9c213bcbddd425a459889c514db5c3da5e2cf555); /* statement */ \nbytes32 schainId = keccak256(abi.encodePacked(name));\ncoverage_0x80b19128(0x4d7e5ed1e8e14b36fa21fe54c8365777123ebcd26d64f26dfec6f55417dd11f0); /* line */ \n        coverage_0x80b19128(0xf9c94be6c88fd68ba1ffd0b7b8ec2c82bae5bbb655457d5e46ec14f3d47690a4); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0x80b19128(0x09bbaf6cf859218e46f0698fea5d1b87666654c912fc5b26a17028f93a4ce72d); /* line */ \n        coverage_0x80b19128(0x6ff8d0cfc55e7c512479a3df2015aa0c136b7426d8c6b23e187877793368d331); /* assertPre */ \ncoverage_0x80b19128(0xe2d7b543bd7bc7a3279dcf92c5a5ecdfcb37b7065201119c510cc939146d7583); /* statement */ \nrequire(IGroupsData(dataAddress).isGroupFailedDKG(schainId), \"DKG success\");coverage_0x80b19128(0xae2122ddb84bf951b0964343910a13e4e2568f670dc441face600390fb5b6726); /* assertPost */ \n\ncoverage_0x80b19128(0x5ebca64105f390bac4214b6dbc3bda1534ed935c7feff6850c6330d58dcda6bc); /* line */ \n        coverage_0x80b19128(0x616836dc9030bd847a51c691aff6c85260893bbbd60cd2971dc3be6827960550); /* statement */ \nSchainsFunctionalityInternal schainsFunctionalityInternal = SchainsFunctionalityInternal(\n            contractManager.getContract(\"SchainsFunctionalityInternal\"));\ncoverage_0x80b19128(0xb840bef63a6f3daf0555e46c8656532b8d797b9a94e25b11ad4c7e1610576176); /* line */ \n        coverage_0x80b19128(0x88437e027ea445f596799a621606eb37805ad857bba99751788ae6c648db3909); /* assertPre */ \ncoverage_0x80b19128(0x7c03ad01e4acf45c80fe1e955e276b26bb21737beef247d1f4e0e2bc4d8126c4); /* statement */ \nrequire(schainsFunctionalityInternal.isAnyFreeNode(schainId), \"No any free Nodes for rotation\");coverage_0x80b19128(0x23a9b7a1537960d5127142432beed89995f23d3c22365565929eb562fe9653b7); /* assertPost */ \n\ncoverage_0x80b19128(0xdd3fda040cff4bfd847c37cc3406d7d1c22553c00c00ba72998ff95dfed74788); /* line */ \n        coverage_0x80b19128(0xb8b8a40b1b91e0995520ac27ca7198c81d3e43efc77364d3ddbff35a4502bc67); /* statement */ \nuint newNodeIndex = schainsFunctionalityInternal.selectNodeToGroup(schainId);\ncoverage_0x80b19128(0x0b9c6876e5f8b1b76d61d0918ea2e814d8c71297a43f09b416a8fab225656faf); /* line */ \n        coverage_0x80b19128(0xc4192ec92e2fbec7ec985bc25b0f85945f3c1cfd14706fbf6b2ec4d62f16a1f7); /* statement */ \nemit NodeAdded(schainId, newNodeIndex);\n\n    }\n\n    /**\n     * @dev getSchainPrice - returns current price for given Schain\n     * @param typeOfSchain - type of Schain\n     * @param lifetime - lifetime of Schain\n     * @return current price for given Schain\n     */\n    function getSchainPrice(uint typeOfSchain, uint lifetime) public view returns (uint) {coverage_0x80b19128(0x6f2753dfdce9e9f42b4e636afea2e5bcb51063259cfef2504e8f6efb917b7100); /* function */ \n\ncoverage_0x80b19128(0xa0a46c7ccf079056a3763a0cfdb6aebbe21a304492ba11dbdd3c0dd243110d66); /* line */ \n        coverage_0x80b19128(0xdc0344785c8d4b302bfc9a361eb61ea8ec89b675e9cafacbd27b70144e9968d3); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0x80b19128(0x16bb9b14bcb88d9f86a4050b274991cf09ffd389d89e6d4d01ed8b834dbb4917); /* line */ \n        coverage_0x80b19128(0xcd8af9959615291d53ae42171ffab30646c1edc87aabf8eabe87350b07525d13); /* statement */ \naddress schainsFunctionalityInternalAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionalityInternal\")));\ncoverage_0x80b19128(0x53821d6c27881040cb902b137018a7504361b3231fa1edbc959b40e2c95ca4cb); /* line */ \n        coverage_0x80b19128(0x70b4ebb0bc8ed0d3a9633c001df3ee5dd4cf3dfeb18e747f729c329d1733853e); /* statement */ \nuint nodeDeposit = IConstants(constantsAddress).NODE_DEPOSIT();\ncoverage_0x80b19128(0xbb3a553216f1e771380a87f44bcba5c47e5d83604d06f5604331b276408cce2e); /* line */ \n        coverage_0x80b19128(0xf500d0d13a53b314287be0e6b30097673c79f0641c6d40152f72b7ad194ec0a5); /* statement */ \nuint numberOfNodes;\ncoverage_0x80b19128(0x608e13e0553a49c6c5c047badf818c0d8a6813149dbd746bf8c07555f2594fd0); /* line */ \n        coverage_0x80b19128(0x88241ff913edfd192377fc3741868f1c3fdb3ebfd974a2f3e31077e3b6482f92); /* statement */ \nuint8 divisor;\ncoverage_0x80b19128(0xca85caa5bb11f8bdaa5f477dd36e12aab8fa0970a4ded84caf3e0f7905a82119); /* line */ \n        coverage_0x80b19128(0xa2f29d2623e38fed2c6ef142bd910c950c98da5b1f195363dc71154277d80a47); /* statement */ \n(numberOfNodes, divisor) = ISchainsFunctionalityInternal(\n            schainsFunctionalityInternalAddress\n        ).getNodesDataFromTypeOfSchain(typeOfSchain);\n        // /*uint up;\n        // uint down;\n        // (up, down) = coefficientForPrice(constantsAddress);*/\ncoverage_0x80b19128(0x1f9e5877d901eefbecea5735dc2006cf25c20b0da042b3bbc09c6ee192d5c98c); /* line */ \n        coverage_0x80b19128(0x035813faa6264669fda8e7cb52d3538d2d7cd453c19ba9354949c32d116993f3); /* statement */ \nif (divisor == 0) {coverage_0x80b19128(0xf41383923b3a28e27431648ee3e3d8f726e035f5e2b675f5bef3b909b8359c41); /* branch */ \n\ncoverage_0x80b19128(0x0e72109c8cfd5fa87415c0b5a1968876afa8d7ff68b81a88e2c638a3dc6f24a1); /* line */ \n            coverage_0x80b19128(0x9b3dc040a1e2f8f7cfd5b7d959eb856dc2519d8f86171b9c8d953676b2a8252a); /* statement */ \nreturn 1e18;\n        } else {coverage_0x80b19128(0x0ff78b68b8cfe46a458772f4582922d2ff16b1b33b7ab9c70183d3339ca6cea1); /* branch */ \n\ncoverage_0x80b19128(0x02b5323b5a654304afc7917bde4c41fe6a56dac77ee6e6d49746aa9c3def0f0a); /* line */ \n            coverage_0x80b19128(0xf6423a30406bb29386be0c67e11c29984158bca0de87745d710372748aebb96f); /* statement */ \nuint up = nodeDeposit * numberOfNodes * 2 * lifetime;\ncoverage_0x80b19128(0x321da168afee7173784b41d87f694af8afdef35bcdafc8f6d84a9e2576387238); /* line */ \n            coverage_0x80b19128(0x92d830c50556e76746091a287846e3937c1700566b590ff2d319b73a6efede3d); /* statement */ \nuint down = uint(uint(IConstants(constantsAddress).TINY_DIVISOR() / divisor) * uint(IConstants(constantsAddress).SECONDS_TO_YEAR()));\ncoverage_0x80b19128(0xf4d36f0e66e2da2ea14a0108aec3354e8237ea210a218723b8eff8dcd0aae4c4); /* line */ \n            coverage_0x80b19128(0xdf914ef4c10dfb9da7373dded90771b6e5f70247bf61e8a05596f286e109b5c0); /* statement */ \nreturn up / down;\n        }\n    }\n\n    function initializeSchainInSchainsData(\n        string memory name,\n        address from,\n        uint deposit,\n        uint lifetime) internal\n    {coverage_0x80b19128(0x3a2d420086ad80b6664398071aa3a6e9b048b4f4a59b44e5cb74a994fc739c35); /* function */ \n\ncoverage_0x80b19128(0xe0bcbcf85b88f3e4a571acaf04c5a5d38a7020a93bde4070641a2b79f51e3132); /* line */ \n        coverage_0x80b19128(0x1faeef7110af41a2e6d7a641f7e88ec3bfca51f598890fad2ba67cf327348014); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0x80b19128(0x25ccade1ea7309c53c1ff6b09182bf59d1a50d6f932a267a5f2adf6b68c64e5f); /* line */ \n        coverage_0x80b19128(0xd550301cc1b602acda052e0938e32fb8d276d89c2ab83b04cf6b4e3e1a5826a0); /* assertPre */ \ncoverage_0x80b19128(0x2c6ad473b8b1e6467d9a10d55d516a6ea74960f49683edc6e1afd715776f525e); /* statement */ \nrequire(ISchainsData(dataAddress).isSchainNameAvailable(name), \"Schain name is not available\");coverage_0x80b19128(0x04366740e7703b21ab27219370253cb744baf809222d7f835cf141d5bf6d67c8); /* assertPost */ \n\n\n        // initialize Schain\ncoverage_0x80b19128(0x1ca2343d66fa4301ef19a3a3a4445125ee232ca6dc7926db1aaa8a292aa9fe8e); /* line */ \n        coverage_0x80b19128(0x1507910e1b8e499c8fc45bd90e8092ece45a1462f78fd9b7b8abf736942cd5ba); /* statement */ \nISchainsData(dataAddress).initializeSchain(\n            name,\n            from,\n            lifetime,\n            deposit);\ncoverage_0x80b19128(0xb663954e3be4a0ec45b3b14d0881fce71d3e310004ed95d7d49d8a4984c0ccc7); /* line */ \n        coverage_0x80b19128(0x2a87d6c55d002620303439f9f12b92b41e5f28e549fd4c7bbe77c022a2bf1402); /* statement */ \nISchainsData(dataAddress).setSchainIndex(keccak256(abi.encodePacked(name)), from);\n    }\n\n    /**\n     * @dev fallbackSchainParameterDataConverter - converts data from bytes to normal parameters\n     * @param data - concatenated parameters\n     * @return lifetime\n     * @return typeOfSchain\n     * @return nonce\n     * @return name\n     */\n    function fallbackSchainParametersDataConverter(bytes memory data)\n        internal\n        pure\n        returns (SchainParameters memory schainParameters)\n    {coverage_0x80b19128(0x9d84a1d38cadd6e8d24fea9a0fd91bb75be134cfaa88c204c79adf0b63d100c5); /* function */ \n\ncoverage_0x80b19128(0x5f250f17ba42d0a67c5264c979c879d797aed3610780cd8f4b4e63de3a9d8fc5); /* line */ \n        coverage_0x80b19128(0x1e69c92a45796be011f434dcdd60dba74a5e51d8a74f49ea4e5856fbc1f58fbc); /* assertPre */ \ncoverage_0x80b19128(0xae58afab6c2d84fb05b42e852063b7885e012bc987781a4747b021bcb5f18aaa); /* statement */ \nrequire(data.length > 36, \"Incorrect bytes data config\");coverage_0x80b19128(0xd6303075a6652300d960fb812830e4f33afb1cee3ac3201008fe3004160923aa); /* assertPost */ \n\ncoverage_0x80b19128(0x464625ae66eb2eb517ae37cc6e85f4ad00644634be15c698adeda2468cd81eb7); /* line */ \n        coverage_0x80b19128(0xd24e18d7b030d5f0507bded77819c061e7bb5857105b6dcb97f7d3178a60b233); /* statement */ \nbytes32 lifetimeInBytes;\ncoverage_0x80b19128(0x7598e9948d9c7ade36faf441e5258e9f3227632f88ea6769c9f914b485ccffcf); /* line */ \n        coverage_0x80b19128(0xdbbf9e496de27248bc0656ee251b0495f70ef54f4bd136e4961ef602991cdef0); /* statement */ \nbytes1 typeOfSchainInBytes;\ncoverage_0x80b19128(0xc28b9cf4cccf90ef86260e3341cb8088de66a69d11b2b73b64e40424e7a12917); /* line */ \n        coverage_0x80b19128(0x7eec3eca8416d1cd0c3591c35496bc975daf4d40ac20b7910ef8ec9ddff361c4); /* statement */ \nbytes2 nonceInBytes;\ncoverage_0x80b19128(0x530d02795cd727385ddca56d896cf455c3c1c76335c7a4ceb3278ed9539c87d9); /* line */ \n        assembly {\n            lifetimeInBytes := mload(add(data, 33))\n            typeOfSchainInBytes := mload(add(data, 65))\n            nonceInBytes := mload(add(data, 66))\n        }\ncoverage_0x80b19128(0x5a48bcdfe8518508ce6ff84a9f9350f91ae70ef6208a6c0117e10a159e0efde9); /* line */ \n        coverage_0x80b19128(0xd566863cac165027bcd8f9ffbfbebc55d1616304012f65d9004634f5df54015a); /* statement */ \nschainParameters.typeOfSchain = uint(uint8(typeOfSchainInBytes));\ncoverage_0x80b19128(0xae0ed0bdcf4ae66f56b53aaf7d2828f292c69f160d30ca3a97fa83992e59c6bb); /* line */ \n        coverage_0x80b19128(0xa7b2d31f0a8b3411ff3215e8aba74f1b10be09e14085f9f2960965c2b03e1cd0); /* statement */ \nschainParameters.lifetime = uint(lifetimeInBytes);\ncoverage_0x80b19128(0xb3ad836e551f816cb341737196856b9c2ef5b69a18f8d1f47c8fe8b537ee2732); /* line */ \n        coverage_0x80b19128(0x39c9323bee54e8ebdeb772f47b8194330bc78581cf560d922bc7a98d25ed2c55); /* statement */ \nschainParameters.nonce = uint16(nonceInBytes);\ncoverage_0x80b19128(0x87650f89db43865886f02d7e9cdfd7b28aa6e1e128bb8ab69c0d088d4a3e1c70); /* line */ \n        coverage_0x80b19128(0x54c145da902ef1e9bad3bbb2382fd48ea7a4019ecf8d72f6ac2a47ed1d2af113); /* statement */ \nschainParameters.name = new string(data.length - 36);\ncoverage_0x80b19128(0x257e70c7f4939c2fad73d576e2d3dfa4ffda5b72368cf2b2937392ec8b9becff); /* line */ \n        coverage_0x80b19128(0xa97087016765b666ff4a1e20122ba65abc75b267487fc45d70bbcb4533caad72); /* statement */ \nfor (uint i = 0; i < bytes(schainParameters.name).length; ++i) {\ncoverage_0x80b19128(0x629507e4157f25daeb7f7e7d8ccf107f6c3c1d19c42c83a035d2835d77d3e60f); /* line */ \n            coverage_0x80b19128(0x94c54bc43c0417cf181838508768964ab7b857f686ff95cdb5d7d18599e2b3a1); /* statement */ \nbytes(schainParameters.name)[i] = data[36 + i];\n        }\n    }\n\n    /**\n     * @dev addSpace - return occupied space to Node\n     * @param nodeIndex - index of Node at common array of Nodes\n     * @param partOfNode - divisor of given type of Schain\n     */\n    function addSpace(uint nodeIndex, uint8 partOfNode) internal {coverage_0x80b19128(0x2d14ca2ceb1ba335782dca8eb5f4c20309f0e9cd6095aff1b2f79a3ce8ca6fdd); /* function */ \n\ncoverage_0x80b19128(0x7be3375e3549009aecc9c40b5bc4d516d8d6e00414c7e1c5cdfc447c2e235e74); /* line */ \n        coverage_0x80b19128(0x63ccccfa16e53a218bc5e373d578e4bad09110e8e6a40349a6fb6fb14940dd92); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\n        // address constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\n        // uint subarrayLink;\n        // bool isNodeFull;\n        // (subarrayLink, isNodeFull) = INodesData(nodesDataAddress).nodesLink(nodeIndex);\n        // adds space\n        // if (isNodeFull) {\n        //     if (partOfNode == IConstants(constantsAddress).MEDIUM_TEST_DIVISOR()) {\n        //         INodesData(nodesDataAddress).addSpaceToFullNode(subarrayLink, partOfNode);\n        //     } else if (partOfNode != 0) {\n        //         INodesData(nodesDataAddress).addSpaceToFullNode(subarrayLink, partOfNode);\n        //     } else {\n        //         INodesData(nodesDataAddress).addSpaceToFullNode(subarrayLink, partOfNode);\n        //     }\n        // } else {\n        //     if (partOfNode != 0) {\n        //         INodesData(nodesDataAddress).addSpaceToFractionalNode(subarrayLink, partOfNode);\n        //     } else {\n        //         INodesData(nodesDataAddress).addSpaceToFractionalNode(subarrayLink, partOfNode);\n        //     }\n        // }\ncoverage_0x80b19128(0xf69a7b087b8d54e71df70d6c895f54afe593a2d75e7cd88b74e3aff0a2415143); /* line */ \n        coverage_0x80b19128(0x17a46a1f70c671b321ae4d7b8033de7111c81299796b14f42a46f06de7a73a1e); /* statement */ \nINodesData(nodesDataAddress).addSpaceToNode(nodeIndex, partOfNode);\n    }\n}\n"
    },
    ".coverage_contracts/SchainsFunctionalityInternal.sol": {
      "content": "/*\n    SchainsFunctionalityInternal.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.3;\npragma experimental ABIEncoderV2;\n\nimport \"./GroupsFunctionality.sol\";\nimport \"./interfaces/INodesData.sol\";\nimport \"./interfaces/IConstants.sol\";\nimport \"./SchainsData.sol\";\nimport \"./thirdparty/StringUtils.sol\";\n\n\n/**\n * @title SchainsFunctionality - contract contains all functionality logic to manage Schains\n */\ncontract SchainsFunctionalityInternal is GroupsFunctionality {\nfunction coverage_0x70343aa7(bytes32 c__0x70343aa7) public pure {}\n\n    // informs that Schain based on some Nodes\n    event SchainNodes(\n        string name,\n        bytes32 groupIndex,\n        uint[] nodesInGroup,\n        uint32 time,\n        uint gasSpend\n    );\n\n\n\n    constructor(\n        string memory newExecutorName,\n        string memory newDataName,\n        address newContractsAddress\n    )\n        public\n        GroupsFunctionality(newExecutorName, newDataName, newContractsAddress)\n    {coverage_0x70343aa7(0x6611310891a8b6615b7c97afd5a16b9f744700e2f58cacbdb6e301c8680f50bd); /* function */ \n\n\n    }\n\n    /**\n     * @dev createGroupForSchain - creates Group for Schain\n     * @param schainName - name of Schain\n     * @param schainId - hash by name of Schain\n     * @param numberOfNodes - number of Nodes needed for this Schain\n     * @param partOfNode - divisor of given type of Schain\n     */\n    function createGroupForSchain(\n        string calldata schainName,\n        bytes32 schainId,\n        uint numberOfNodes,\n        uint8 partOfNode) external allow(executorName)\n    {coverage_0x70343aa7(0xc3a8080ddbece221ef4ec256ed1bb9f573db7068ec0847d54794bc9ead8aab44); /* function */ \n\ncoverage_0x70343aa7(0x917dd8a9ef6aaa796e6e003223b4fb3789d5a66b72a90eecc8664c17cc1a3039); /* line */ \n        coverage_0x70343aa7(0x7cea9506f1c8197a4e724b5598b800bd5d3e97628d7396e87bc43e2ecf45b5b2); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0x70343aa7(0x3d81920de1af656a28071e305ecd223ee116309c498a005a2d1831d53174d94f); /* line */ \n        coverage_0x70343aa7(0xea4840cf766610573cc90ddef5faa5e9ba9afc1b303a4c29d510c2bb9669728a); /* statement */ \naddGroup(schainId, numberOfNodes, bytes32(uint(partOfNode)));\ncoverage_0x70343aa7(0x561c031bc907ad9a384cb824adce9cb926cd97b14573a127af1135d5ad840f50); /* line */ \n        coverage_0x70343aa7(0xe9f40a9bb384a4eff036ae9652aa20e3fe8d695d08440a299fc00dbe1ea6a3e1); /* statement */ \nuint[] memory numberOfNodesInGroup = generateGroup(schainId);\ncoverage_0x70343aa7(0x352770891da7c29b2844fe3dc06136b749858d90f29e79fcc88271384a358636); /* line */ \n        coverage_0x70343aa7(0x196d382707e5564112d9cc2cbea4c434594a1cf1a8a1583299dafafb8556f97d); /* statement */ \nISchainsData(dataAddress).setSchainPartOfNode(schainId, partOfNode);\ncoverage_0x70343aa7(0x1a0c956b282c4e8f8c52da9fe82201414357ada7b02c229d3e027397ba0ee16a); /* line */ \n        coverage_0x70343aa7(0x714f8f1ec1f5950cee41a3a683c21ab77951071238a460a073b166a747c5ef21); /* statement */ \nemit SchainNodes(\n            schainName,\n            schainId,\n            numberOfNodesInGroup,\n            uint32(block.timestamp),\n            gasleft());\n    }\n\n    /**\n     * @dev getNodesDataFromTypeOfSchain - returns number if Nodes\n     * and part of Node which needed to this Schain\n     * @param typeOfSchain - type of Schain\n     * @return numberOfNodes - number of Nodes needed to this Schain\n     * @return partOfNode - divisor of given type of Schain\n     */\n    function getNodesDataFromTypeOfSchain(uint typeOfSchain) external view returns (uint numberOfNodes, uint8 partOfNode) {coverage_0x70343aa7(0x19f6985870b8287a72d955ef02ee211e1d85abda45f83d3b8f5d828ad6048e4d); /* function */ \n\ncoverage_0x70343aa7(0xb58133fd1176c44635d4de85ad93fa823ee2c52d897547dac4f342aeda0282a7); /* line */ \n        coverage_0x70343aa7(0x506f54c8183f6785995444508627ee27c0d1e63a8884c9c195292022fc76828b); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0x70343aa7(0x8615bf361bb82b86e75ca72015a5958808627e7cf9d598a8621b6ec0a5184c53); /* line */ \n        coverage_0x70343aa7(0x277d6292784602b8e4270ba44d09c4a541eaba5a007ff64eb0eff41cc20794aa); /* statement */ \nnumberOfNodes = IConstants(constantsAddress).NUMBER_OF_NODES_FOR_SCHAIN();\ncoverage_0x70343aa7(0xca894cfca21f42d78975c4ac6da6336ce6164843fb7137b5ad98c1ed16cd4989); /* line */ \n        coverage_0x70343aa7(0xab8b4af11389d870106200d17428df31cf162fdf0ce667eec5247c0bdd4dcfd4); /* statement */ \nif (typeOfSchain == 1) {coverage_0x70343aa7(0x7d815470a54cff7fe3899be01fff456de61ef6c488e546ca253c4b5eb2458dc1); /* branch */ \n\ncoverage_0x70343aa7(0x798b861751209c204692f69a679e72644384a0d09b5cd81bbd3b845bb291d104); /* line */ \n            coverage_0x70343aa7(0x8aa650effe8c76c1aba77b0ec1c849c35c447a85fbe1c15bc9bf711827ba58b0); /* statement */ \npartOfNode = IConstants(constantsAddress).TINY_DIVISOR() / IConstants(constantsAddress).TINY_DIVISOR();\n        } else {coverage_0x70343aa7(0xad44e74b4352888f0bbc387945682fb528278c174bce192e129c250f1b316bad); /* statement */ \ncoverage_0x70343aa7(0x803d31fc2d9cb181a70f97e697a1ec51dce947cc37b5aceae14713b1a806b841); /* branch */ \nif (typeOfSchain == 2) {coverage_0x70343aa7(0x256563191cbe0c254f1b706af5b3914137677fde2f44919692b78b2935ace874); /* branch */ \n\ncoverage_0x70343aa7(0x379248fb0ae67be719206943fb3c1288374fa581d225af161ee7a2c66897f9a9); /* line */ \n            coverage_0x70343aa7(0x1c3bd9eada87893ff137831dc3b3cd8491688e87b188bd79510b8ac6235bcf4c); /* statement */ \npartOfNode = IConstants(constantsAddress).TINY_DIVISOR() / IConstants(constantsAddress).SMALL_DIVISOR();\n        } else {coverage_0x70343aa7(0xacf168057d71ee18ec5e54e3cb4c0ebde4aeab54cc256b5056c8cce82b8837d9); /* statement */ \ncoverage_0x70343aa7(0xccba05267c553479741a94c0938156378e6d648ef025f454960b304981b916e1); /* branch */ \nif (typeOfSchain == 3) {coverage_0x70343aa7(0x9edb53d63769707cd9772b55b8cdbc242c0b49c23b6073048c8ac6595e01cbe5); /* branch */ \n\ncoverage_0x70343aa7(0x55bfeb6f85fe389ba9e6284a9fdb648bb2cd04bd0a083f74311d593f065a4046); /* line */ \n            coverage_0x70343aa7(0x369195d048437b74a7ddc216854d5564aaff76ef63f563718ac18d06f8cdd19e); /* statement */ \npartOfNode = IConstants(constantsAddress).TINY_DIVISOR() / IConstants(constantsAddress).MEDIUM_DIVISOR();\n        } else {coverage_0x70343aa7(0xec56bdd5766c10a79149643c33ca69a1be4e8a06f4d6488a0b0ade44ffcf6a76); /* statement */ \ncoverage_0x70343aa7(0x117891e891b164731830a7ec124ecaa9371387e1765f9ca08f035f1d15e34b90); /* branch */ \nif (typeOfSchain == 4) {coverage_0x70343aa7(0xe1879e28f3c2be25b86b15342f3e5c1890a12deb363c8bb700be58aa76ec7fc8); /* branch */ \n\ncoverage_0x70343aa7(0x6263a5c9c3f0387959c7fe896ae06615695942e50f5c054f464bfdbcb83bd253); /* line */ \n            coverage_0x70343aa7(0xa6b2263508a5aa5c9ad5597061b556eb799a71d6db32179b6bb85b3939261128); /* statement */ \npartOfNode = 0;\ncoverage_0x70343aa7(0xd214fc2b61198c2e7a14a7512f93bbfa7a304a65f59ea910ff936ce47ac55c4d); /* line */ \n            coverage_0x70343aa7(0xc74afdbbee3a6819e55277c6f3a07ada6ad27229b6d01e875329c49b13018d9c); /* statement */ \nnumberOfNodes = IConstants(constantsAddress).NUMBER_OF_NODES_FOR_TEST_SCHAIN();\n        } else {coverage_0x70343aa7(0xad0946c03bfdd9007ea1a972e4358cbf7be6e70b6ead99299242d90d4af30631); /* statement */ \ncoverage_0x70343aa7(0x6f62e0db4535e2ab916b0e8f5f63843814283604e0d43a07e75dec39065f5ecc); /* branch */ \nif (typeOfSchain == 5) {coverage_0x70343aa7(0x0fb9e6c07e99bd1f3bd1e2de6d88b015ee9c0e7822f163c351b9054174fc507e); /* branch */ \n\ncoverage_0x70343aa7(0x3d545c024c6abb84ed727ca38b016e601634ff5ef57d233443682b72824f8939); /* line */ \n            coverage_0x70343aa7(0x9b60c86cc90c91809ddeb2691b423336a4a71bb195e531df2929920453b618b6); /* statement */ \npartOfNode = IConstants(constantsAddress).TINY_DIVISOR() / IConstants(constantsAddress).MEDIUM_TEST_DIVISOR();\ncoverage_0x70343aa7(0x145689695cb07b90c3ad99bf326304d56dcfa2b2f84cddbc51a7d8f24c12a858); /* line */ \n            coverage_0x70343aa7(0x2a104a223d662df1e0bdcd628d6a28b707121ff03f4a47eee0843723de1bad86); /* statement */ \nnumberOfNodes = IConstants(constantsAddress).NUMBER_OF_NODES_FOR_MEDIUM_TEST_SCHAIN();\n        } else {coverage_0x70343aa7(0x595678fc34b5cf5f64041bceaf2c973dfeeaa5eefaec20f99b94e1ef5ab01517); /* branch */ \n\ncoverage_0x70343aa7(0x9ca6be37982cb503111598b580486be9f70e6616d885cac0a725b38f16a27e57); /* line */ \n            coverage_0x70343aa7(0x75d934b453f310218ebcdf1ec705ffba6b0a7356a2e38c22b71db220d6ca2bbb); /* statement */ \nrevert(\"Bad schain type\");\n        }}}}}\n    }\n\n    function removeNodeFromSchain(uint nodeIndex, bytes32 groupHash) external allowTwo(executorName, \"SkaleDKG\") {coverage_0x70343aa7(0xb39795110a34d3f19a948a852b574612fbb609640437eafc4848feedcf846ed4); /* function */ \n\ncoverage_0x70343aa7(0x58119789c8b0668332f777913589c8e26c4feca6d8437f9d492e790980e40a31); /* line */ \n        coverage_0x70343aa7(0x26638053a282bf2e2086e64185ff562525fcfba190d4dd633666bda96c666e16); /* statement */ \naddress schainsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsData\")));\ncoverage_0x70343aa7(0xaf778f9257aaca28b9aa518bb3cd72a13fb25abd6c31105e58cbce98e32e2fa8); /* line */ \n        coverage_0x70343aa7(0x690c1903d84782a43e9c67c27b1160ae1ce0142fc2f07a72685f6afe105778e5); /* statement */ \nuint groupIndex = findSchainAtSchainsForNode(nodeIndex, groupHash);\ncoverage_0x70343aa7(0x9db5537914cd2e98ebd900e114fba715c2d32d7321ce4fecaefb9ad32b37e931); /* line */ \n        coverage_0x70343aa7(0xc8e0dac3207852e4c87584ec796fedf0301b9265b15d81b1e3aaa27c75e1c9e0); /* statement */ \nuint indexOfNode = findNode(groupHash, nodeIndex);\ncoverage_0x70343aa7(0x868ecc19777289689d951b54e27e3dcc03e19bd70c6286ee529ede7426d70811); /* line */ \n        coverage_0x70343aa7(0x8081e3dd83e7aa62d6a90cca2ee809abb5393ae2e62fd88e564a1b07ec1e7eaf); /* statement */ \nIGroupsData(schainsDataAddress).removeNodeFromGroup(indexOfNode, groupHash);\n        // IGroupsData(schainsDataAddress).removeExceptionNode(groupHash, nodeIndex);\ncoverage_0x70343aa7(0x22bc74770dd47c1f49a9abf01ec0290234d094d8e13d00c46f1a3f30deea9641); /* line */ \n        coverage_0x70343aa7(0x985af832d075dd0cd1f0d7f8356c04268d3ac19bad99bfa6ac3f815cf2e90c72); /* statement */ \nISchainsData(schainsDataAddress).removeSchainForNode(nodeIndex, groupIndex);\n    }\n\n    function removeNodeFromExceptions(bytes32 groupHash, uint nodeIndex) external allow(executorName) {coverage_0x70343aa7(0x694c112efda62f5cf78d9c98a4e9179babae278b9f571ee729c2637dd2125381); /* function */ \n\ncoverage_0x70343aa7(0xf1f601e0285d1321ae4319ba21dae524e8921c6d7dbefa71ad483cf7f3288c21); /* line */ \n        coverage_0x70343aa7(0xd68482e71dfbed6600753f4bebeeea09f2ea3a944254288a6ccf291274a939f2); /* statement */ \naddress schainsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsData\")));\ncoverage_0x70343aa7(0x5399159fc55fdea778dfe4cf00ba31f6a3a30405b2f5876c10e31e255eb7d301); /* line */ \n        coverage_0x70343aa7(0x3ff60f17c05fb34b234d8cc56bdef8cd25c62fb7958f169ec01997c214e56561); /* statement */ \nIGroupsData(schainsDataAddress).removeExceptionNode(groupHash, nodeIndex);\n    }\n\n    function isEnoughNodes(bytes32 groupIndex) external view returns (uint[] memory result) {coverage_0x70343aa7(0xbfa6929b1099f07253b2b0affd8192d1342c00c8b2e810c4df1c609a8033c21f); /* function */ \n\ncoverage_0x70343aa7(0x27753a3e802acdf5ef7697046ea057360e2eb6ca9466c42487b846cc305adcd8); /* line */ \n        coverage_0x70343aa7(0x3e0cff73196e4c751d2da929c8f8a6f51fe352d9d7511aa7f28bf3e03e54de0d); /* statement */ \nIGroupsData groupsData = IGroupsData(contractManager.contracts(keccak256(abi.encodePacked(dataName))));\ncoverage_0x70343aa7(0xad222e8a2369332cabe1be2b92eaac8ea9a304c58e6bec41c39cf77d26a4547f); /* line */ \n        coverage_0x70343aa7(0x290741476c56c66614279dd71635bf45acacc59bb55b9da1cf190255544324f4); /* statement */ \nINodesData nodesData = INodesData(contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\"))));\ncoverage_0x70343aa7(0xe56541b998852c5dca411d9a669f53ebe652f7f2a70d94b256ce9fb40cf0d7ea); /* line */ \n        coverage_0x70343aa7(0x2a96cc8cf19816249cfc0094d40fc924390bc16b7b3756319ad7f83be19237da); /* statement */ \nuint8 space = uint8(uint(groupsData.getGroupData(groupIndex)));\ncoverage_0x70343aa7(0x5da55f20398c02787315e7a04b6df649ebf98cf7d496cc9a551f67d5ae9e8d26); /* line */ \n        coverage_0x70343aa7(0xc0ab36026263d6c4a8ce8ce4b301502ca40fd0bf01d50418e498a76ec012aeb2); /* statement */ \nuint[] memory nodesWithFreeSpace = nodesData.getNodesWithFreeSpace(space);\ncoverage_0x70343aa7(0xb68ce63a6bc28fdb0836f3864d50bbf565813e373312c60feb6ead173c74d7f6); /* line */ \n        coverage_0x70343aa7(0x7d2d5e0ee55e75d7a4c000fc6433f1b13b7c93c3d86d86cb517ef39cfd88fa94); /* statement */ \nuint counter = 0;\ncoverage_0x70343aa7(0x35d6eb382faa377cea615fa4eea6f9d2d0ec89620a10a43f00188c7c78416578); /* line */ \n        coverage_0x70343aa7(0xf90ce93e1f490627a7ac1631d186a9938ad77f5bc38abd7560e148d0ed8022f7); /* statement */ \nfor (uint i = 0; i < nodesWithFreeSpace.length; i++) {\ncoverage_0x70343aa7(0x92c3944e67a399cf38bb5ce3d6a8eca04f141f231edd18fcd941d3cffb8fd416); /* line */ \n            coverage_0x70343aa7(0x870078e863fbde15deafb32419c8e846fbd40e100adce6f2486745135b8d1a64); /* statement */ \nif (!isCorrespond(groupIndex, nodesWithFreeSpace[i])) {coverage_0x70343aa7(0xbf24da0caaf66a376ce64adb30a550d54c03110b40d60f38098e5eb82cf59ce5); /* branch */ \n\ncoverage_0x70343aa7(0x820ccedc6d2bceac947f67e8c50511ed539d8e411c8453f163e1c943ecdb4d30); /* line */ \n                counter++;\n            }else { coverage_0x70343aa7(0x982e57042077bc24b3a363f945b8e0aec57323b58a1f0a0ad17c922d70df8ff7); /* branch */ \n}\n        }\ncoverage_0x70343aa7(0xefbf782f87a36c2aa084b8b1c75167a671f93160ac76086a4da886f1a067e317); /* line */ \n        coverage_0x70343aa7(0xf216dbe3a59b6cdeee47cbe802da10b07dbd7b9209dc7af3d6310abf6772f0e0); /* statement */ \nif (counter < nodesWithFreeSpace.length) {coverage_0x70343aa7(0x2e3d4ac2d8752571a51215a569410109f4f6d81423bf006658fe0b9c4de0230d); /* branch */ \n\ncoverage_0x70343aa7(0xe0c7d27f6089a09666cb84245b830d08fbb820429c8ae8f3238bb3fbe278a718); /* line */ \n            coverage_0x70343aa7(0xde93e967a40ff603adf2bfa5a4723ff2f7f93b75cd823bac694eedd9a043f6f9); /* statement */ \nresult = new uint[](nodesWithFreeSpace.length - counter);\ncoverage_0x70343aa7(0x8a0c61fc06b25542b139ecffa6d3b397f66daa179e3a37b4e8e1a5d0122bade5); /* line */ \n            coverage_0x70343aa7(0xd24901494774c2facd3abf203ab5e35d57abffdd5970041ae2552785313d8354); /* statement */ \ncounter = 0;\ncoverage_0x70343aa7(0xa2b4610b9a199bfd04efa60f8879e040b966d65bcd5d9be9b2c09503eda7ddeb); /* line */ \n            coverage_0x70343aa7(0x2c294e4d07aa96e109ab6fffd4133627b3011b6de63dad58cdcfbf520a7c1e7c); /* statement */ \nfor (uint i = 0; i < nodesWithFreeSpace.length; i++) {\ncoverage_0x70343aa7(0x65ceb4a6808b9b31f73f3e8404fc24b8fb825f274312e6860530706a21311bec); /* line */ \n                coverage_0x70343aa7(0x6d7ba9b069e00d4a5fdfb6de44e2ad2698b758cee6a0953661ba7f58f27febdf); /* statement */ \nif (isCorrespond(groupIndex, nodesWithFreeSpace[i])) {coverage_0x70343aa7(0xef3417c146a038e9cf60e062b39b453f6f941f9e7fa749b4206d12cbdde7b806); /* branch */ \n\ncoverage_0x70343aa7(0xdd0d542a8d75cd0a0cd8ed237a982be9053c23ebd9aa3303e881ce60f22d2280); /* line */ \n                    coverage_0x70343aa7(0x830ee7c9636cd36ac4a4fdf897626d3bfcd97e67a3b9492eb8fba5c6b77205a8); /* statement */ \nresult[counter] = nodesWithFreeSpace[i];\ncoverage_0x70343aa7(0x608860dfc09ad509120d7485654e9d24d8da129c1e508589da12517bda75f786); /* line */ \n                    counter++;\n                }else { coverage_0x70343aa7(0x5a27b4c338f03f5f89c8a0f31caaa1f6de1df096fadc0ac842b5587d3d1331a2); /* branch */ \n}\n            }\n        }else { coverage_0x70343aa7(0xf19083055c93452bab1566852f36be34fb04e37203798b653946e9f6b66d85d8); /* branch */ \n}\n    }\n\n    function isAnyFreeNode(bytes32 groupIndex) external view returns (bool) {coverage_0x70343aa7(0x16d09b458c906e5b30bd701eb5fbbef04051ab61f7c73bbe22e612d6ec2a1917); /* function */ \n\ncoverage_0x70343aa7(0x430056f73ab2727989227f4e7fa5ee0ed75701320fb48ea646abd6c794870b14); /* line */ \n        coverage_0x70343aa7(0x9c3ae9ff32dd85426b4516b442626abafe2cb455ec9f8f1755c370e5c4488145); /* statement */ \nIGroupsData groupsData = IGroupsData(contractManager.getContract(dataName));\ncoverage_0x70343aa7(0x95496b3f5904ac7bd91d1ef7b68a05be0bfe79db7b0fdecc3224ca9c14d353d3); /* line */ \n        coverage_0x70343aa7(0x28e8556ec93dfd480998e5777a045fcafdfbfc7b6382e16f445562a470b42f0e); /* statement */ \nINodesData nodesData = INodesData(contractManager.getContract(\"NodesData\"));\ncoverage_0x70343aa7(0x9c7f573e92c1762891e556f06b4006b45ad2c642687a2debc986367dc7260081); /* line */ \n        coverage_0x70343aa7(0x95e8a4c8e4a2548e8d0aad9ac5b19c5389c073d2f021472af6094ca22438d5ca); /* statement */ \nuint8 space = uint8(uint(groupsData.getGroupData(groupIndex)));\ncoverage_0x70343aa7(0xa9f5295ae0604b2d6b77429d451ab14f2f45005e124acee01c5a66da50679dc1); /* line */ \n        coverage_0x70343aa7(0x70ed5943b5c5c32717a9c8b717503cd2c9b466a70d994b8796e30bfbfbdbaa4a); /* statement */ \nuint[] memory nodesWithFreeSpace = nodesData.getNodesWithFreeSpace(space);\ncoverage_0x70343aa7(0x81b7c6e8e080b4f338ff3a9a4ab1e5bc815ead62f5bc6bdaf111b2f49c76423a); /* line */ \n        coverage_0x70343aa7(0x998edb1ad40b4778043788f15e25325a08da04220b252fee88d95c8e548946a4); /* statement */ \nfor (uint i = 0; i < nodesWithFreeSpace.length; i++) {\ncoverage_0x70343aa7(0xfd78a9d91187dc5f3b59dcece3e1ba6877c8966f0ab3e2d8f7abdfe684923653); /* line */ \n            coverage_0x70343aa7(0x12b6b5a7f744db50e89ece476f0ea4cce5e5210fb5ac242fb17d581ac25c64e2); /* statement */ \nif (isCorrespond(groupIndex, nodesWithFreeSpace[i])) {coverage_0x70343aa7(0x3288e1e807d45a0c3d0b82e3191f137ddf50dccbe7364d3165e46b4d29d0c0f0); /* branch */ \n\ncoverage_0x70343aa7(0x7c4a0783db1de2cabaacdaef5e4d13bbc52096218d4b870f9d86af4bf0dd9017); /* line */ \n                coverage_0x70343aa7(0x021d481e014c531c5fd43d92bac92d85d706972822b3463023c8ede3c5c13e6c); /* statement */ \nreturn true;\n            }else { coverage_0x70343aa7(0x73241094a2aa5f98a0de998887d9dce2cd047d92647882ccdd4b133d1b50d943); /* branch */ \n}\n        }\ncoverage_0x70343aa7(0x29abf494aae91f0941b6723b464b41323e689f928a53436178b8c3446f6d04ec); /* line */ \n        coverage_0x70343aa7(0xa6d1da2fb5aa219f2e935085759b665d0d71bf2913123c648cf421df6384a93d); /* statement */ \nreturn false;\n    }\n\n    /**\n     * @dev selectNodeToGroup - pseudo-randomly select new Node for Schain\n     * @param groupIndex - hash of name of Schain\n     * @return nodeIndex - global index of Node\n     */\n    function selectNodeToGroup(bytes32 groupIndex) external allow(executorName) returns (uint) {coverage_0x70343aa7(0xc23ba8446dba1a68887e1027bc034117862dd4188b4dd93370fd19ed186ad4c7); /* function */ \n\ncoverage_0x70343aa7(0xeffda2d41324e738e7ab25052674e37cd90b251249029c71d8788ae0f6cd293f); /* line */ \n        coverage_0x70343aa7(0x6f8d956a63e0326f46678fdd8b8b4f5f2a9df67382266c39f33df3c45496d4c9); /* statement */ \nIGroupsData groupsData = IGroupsData(contractManager.getContract(dataName));\ncoverage_0x70343aa7(0xf56dc6f2ed4c834a3685ac24a2d218975fe274712d4302b45a6df81f3bfdf87c); /* line */ \n        coverage_0x70343aa7(0x1433788ccb0b1ad1b8450e9da64dc3e405153175c460bde086d1f41530ca00ff); /* statement */ \nISchainsData schainsData = ISchainsData(contractManager.getContract(dataName));\n        // INodesData nodesData = INodesData(contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\"))));\ncoverage_0x70343aa7(0x0057a34c118fa918dd988bb33c285de93db22529740d2db4ce73f8758b193a89); /* line */ \n        coverage_0x70343aa7(0xb03130d7a1433333b9774e57129a7484372cc8bbd41d0a5604b4190177a8e011); /* assertPre */ \ncoverage_0x70343aa7(0xbb69103f7fc15a89002c152227d6f4da90e331a551891920bef334546ead2da7); /* statement */ \nrequire(groupsData.isGroupActive(groupIndex), \"Group is not active\");coverage_0x70343aa7(0xa081fac89a6efd1afd19c48f6d1464eb9fdeed74d205ae75bdaab53d7fea48bc); /* assertPost */ \n\ncoverage_0x70343aa7(0x0e2e37c9b5bf70a4dbc76827cdbedbf4f64e8427f5170dd89fef9cf9105099cb); /* line */ \n        coverage_0x70343aa7(0xae4e05e2a6efe705d24d0b18d4063affb64c04950fd1051922eafd06fc9087ef); /* statement */ \nuint8 space = uint8(uint(groupsData.getGroupData(groupIndex)));\n        // (, space) = setNumberOfNodesInGroup(groupIndex, uint(groupsData.getGroupData(groupIndex)), address(groupsData));\ncoverage_0x70343aa7(0x5bf624aca67b2ead1c75fb15e6d72915107b80b43f501fe5f633eeef174b35c9); /* line */ \n        coverage_0x70343aa7(0xdf7e1e33651299d23a35a7611f05c0432737b05be9d18f82cca63af2cd43485b); /* statement */ \nuint[] memory possibleNodes = this.isEnoughNodes(groupIndex);\ncoverage_0x70343aa7(0x5b088d1b76650b23c2445ab70b1391976b4501a2e3ae576f8d1a0cba739d9cea); /* line */ \n        coverage_0x70343aa7(0x73d26e3b2f6f906446d1d1f57bdfd433fd6e90c9c85a38019aa55b712e7c0122); /* assertPre */ \ncoverage_0x70343aa7(0xe930b3a26d1f95350d79b01dca34d82c71c98d07ea8e2423ff0a85bc7341d93c); /* statement */ \nrequire(possibleNodes.length > 0, \"No any free Nodes for rotation\");coverage_0x70343aa7(0x41433ce0f089aacfa4bdb06340d341c657ab17fa492f5086f76ed21e68692bf9); /* assertPost */ \n\ncoverage_0x70343aa7(0x7517bdcc4b1c0fe5dc45328c46e4be0e61094a101baf7172d1baa96856c622ff); /* line */ \n        coverage_0x70343aa7(0x5d9f9c906f4cf3848ccc543163e31de48e5ff3938158b62d21b373d24cdfb6ed); /* statement */ \nuint nodeIndex;\ncoverage_0x70343aa7(0x027014e06d01aed8812a7788bdb2daaaf83cea6edd6ad71f03004a9d2fe75a44); /* line */ \n        coverage_0x70343aa7(0x2e24518d908158f73e45a9363c3114fe62a6d78574acb8958b242da3bd56e7b1); /* statement */ \nuint random = uint(keccak256(abi.encodePacked(uint(blockhash(block.number - 1)), groupIndex)));\ncoverage_0x70343aa7(0xe2a055bea1bbd40f57b8b66e281b1a8565599bbf8370cbccc5070ae6f7787d31); /* line */ \n        do {\n            uint index = random % possibleNodes.length;\n            nodeIndex = possibleNodes[index];\n            random = uint(keccak256(abi.encodePacked(random, nodeIndex)));\n        } while (groupsData.isExceptionNode(groupIndex, nodeIndex));\ncoverage_0x70343aa7(0xb9cdf1d77ee10d9a129b0271de29cc7db2a969d04665440a256809fdad42a9b8); /* line */ \n        coverage_0x70343aa7(0x51c1bc7693e08da91690896da88450c029108215b97066080c4ed292c9daef94); /* assertPre */ \ncoverage_0x70343aa7(0xb9e5088e8ee85c3516796775405045246e707e12c21c1aaee9938e30d22757aa); /* statement */ \nrequire(removeSpace(nodeIndex, space), \"Could not remove space from nodeIndex\");coverage_0x70343aa7(0x667f12079e219aee0f89105d62f215e0317c15691a568c53997cc674913e596f); /* assertPost */ \n\ncoverage_0x70343aa7(0x267d71faea75a92f85fa5709753990f43372d2b40d2f006aebb1a15aa7c7aca0); /* line */ \n        coverage_0x70343aa7(0x6a4af5f2869f525f407161934a028640e50819e2c17d3471e8b1a965b226fafb); /* statement */ \nschainsData.addSchainForNode(nodeIndex, groupIndex);\ncoverage_0x70343aa7(0x7cfbd35b689be8bd84b548e6e6616e48730eb8c0aac544e22f67a94ca77e54ef); /* line */ \n        coverage_0x70343aa7(0x7848b0cf048f922cb3817c8817823f68e27bdcd15982cbfd19c7ef9a37508811); /* statement */ \ngroupsData.setException(groupIndex, nodeIndex);\ncoverage_0x70343aa7(0xa663d82c7595f8e69e06526bbc965c66a77e9699cdd02197bc20d26cf5877910); /* line */ \n        coverage_0x70343aa7(0xea9f6bebf84bbe5662bc9a93144b97200e85be42b2c67765eeac9e2874632363); /* statement */ \ngroupsData.setNodeInGroup(groupIndex, nodeIndex);\ncoverage_0x70343aa7(0x790fd84265e70cad24b78c926b574bb783c44a7ad8eb714e650a6a096ca41f5b); /* line */ \n        coverage_0x70343aa7(0x2afceb6c77283f8498fb77362043b395379afbab2d1825869c4536cce03340b5); /* statement */ \nreturn nodeIndex;\n    }\n\n    /**\n     * @dev findSchainAtSchainsForNode - finds index of Schain at schainsForNode array\n     * @param nodeIndex - index of Node at common array of Nodes\n     * @param schainId - hash of name of Schain\n     * @return index of Schain at schainsForNode array\n     */\n    function findSchainAtSchainsForNode(uint nodeIndex, bytes32 schainId) public view returns (uint) {coverage_0x70343aa7(0xf2a79c499bcf997930cb19d1d2a19fd39f35e808a050223826e3e4bcc4ee011d); /* function */ \n\ncoverage_0x70343aa7(0xcad1b0e44d610cbb5dca7344b0490da6bba900650bc10bf3a5badfc41f218be6); /* line */ \n        coverage_0x70343aa7(0xe353e04ace20ad26ad5cda12b0bd991955fd657665f92c93c753ec837c0594cf); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0x70343aa7(0xb65e7c1a5af95a01577ecf02e96b9723d744667f32d35fc4476afc80a305f383); /* line */ \n        coverage_0x70343aa7(0x2fc55dba109dd85d3e0cae65608e02ea965359ae84ca26141945d4681ddb3904); /* statement */ \nuint length = ISchainsData(dataAddress).getLengthOfSchainsForNode(nodeIndex);\ncoverage_0x70343aa7(0x159c24c19e489082be1347c2e099f6b5988092f32478c3a65538c797fcd7737f); /* line */ \n        coverage_0x70343aa7(0x5c09aaf60a46e47e15fea0012df48ea2e40026abedb4b4e058964bb82faad814); /* statement */ \nfor (uint i = 0; i < length; i++) {\ncoverage_0x70343aa7(0x0588e8d515f9f4ea47eb6dd4a4a9583cec845e840b3281acd5818b850ca8b5d7); /* line */ \n            coverage_0x70343aa7(0x1d13516a17d50529055fdfc58b68b22fba8ba86f0cca2a2174b7e0c0ebddf32b); /* statement */ \nif (ISchainsData(dataAddress).schainsForNodes(nodeIndex, i) == schainId) {coverage_0x70343aa7(0x3ccc24eb3897a0c002fb99ec4558f244d0212ae7ab6089092b5a2cfc97b7e878); /* branch */ \n\ncoverage_0x70343aa7(0xec4a9d2bc41af7fd515dc3d938a076a74b0bb7dd59a2b289218d1cba5f52102f); /* line */ \n                coverage_0x70343aa7(0xcf34d6388cc40e71136766e9f0fe511cb81e1c290fbc65f3f318b97403a5c7da); /* statement */ \nreturn i;\n            }else { coverage_0x70343aa7(0xcf409e9cd03895180f673f4e3635243aafd1b33a57a6c27e311daff28f0d8da7); /* branch */ \n}\n        }\ncoverage_0x70343aa7(0x98022db4d355b9884fd02bea3fcb587472bbe2416a2462f4776c782670ebb3f2); /* line */ \n        coverage_0x70343aa7(0xc5b7e83344ad25b6ff66b0f132326a960160987e00e533bbb6f4cd35932e76b7); /* statement */ \nreturn length;\n    }\n\n    /**\n     * @dev generateGroup - generates Group for Schain\n     * @param groupIndex - index of Group\n     */\n    function generateGroup(bytes32 groupIndex) internal returns (uint[] memory nodesInGroup) {coverage_0x70343aa7(0xda8e71a60627c1ae07a071a63875c0af40d2ef2fcfdd8b2666cd4b2c1bb0d409); /* function */ \n\ncoverage_0x70343aa7(0x897b27f5d185cb8c786d5f8328cd9588f38413833a9f211116f448d58e542299); /* line */ \n        coverage_0x70343aa7(0xd9dbe8175f7cd24be0ff74f871582955b1a93ac43f4b5a5c7d7a2efa64540312); /* statement */ \nIGroupsData groupsData = IGroupsData(contractManager.contracts(keccak256(abi.encodePacked(dataName))));\ncoverage_0x70343aa7(0x45ec30eb643a05fb3238b9aa5a4ad3a63861714a23911fc66d5e3d526e6fd945); /* line */ \n        coverage_0x70343aa7(0x0ec39be06ade4a006ab08467e497ce8faf6207960603b24aa5f1b8fef90f61aa); /* statement */ \nISchainsData schainsData = ISchainsData(contractManager.contracts(keccak256(abi.encodePacked(dataName))));\n        // INodesData nodesData = INodesData(contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\"))));\ncoverage_0x70343aa7(0x55c8a60b17bd0e9d3dface5805ac20109f6ca395cc49815ca7ca89fe69ef5cb5); /* line */ \n        coverage_0x70343aa7(0xff32656d36f4aee86af387f18a47d639c411192459f938a48b6940c9f8a0f81b); /* assertPre */ \ncoverage_0x70343aa7(0x9bac919d0585c670bb5cf8e2ea94c8d1029de2db942a33f7f55d1414d3e5d3ad); /* statement */ \nrequire(groupsData.isGroupActive(groupIndex), \"Group is not active\");coverage_0x70343aa7(0x92fac9f6ab3e34c613ab10ede8056e2ddd705645893804fe918cb2b128245b8f); /* assertPost */ \n\n\n        // uint numberOfNodes = setNumberOfNodesInGroup(groupIndex, uint(groupsData.getGroupData(groupIndex)), address(groupsData));\ncoverage_0x70343aa7(0x4cc61e0e70752a5f263ab3e2944d58d9aeb492af05f199c5adf4476e212338d2); /* line */ \n        coverage_0x70343aa7(0xefd7d5d89fc62961ba8821bc76a09a49210587284aacfefa6137c1864a39f763); /* statement */ \nuint8 space = uint8(uint(groupsData.getGroupData(groupIndex)));\n        // (numberOfNodes, space) = setNumberOfNodesInGroup(groupIndex, uint(groupsData.getGroupData(groupIndex)), address(groupsData));\n\ncoverage_0x70343aa7(0x257595cf4c7cdb3898b8ee6fd8e051876c2a401ff4c5010d736d4bc3e1de2bbd); /* line */ \n        coverage_0x70343aa7(0x4e1e2969cab93de1e0276a364f522290dc6827d7a775bb19b114b15481253dac); /* statement */ \nnodesInGroup = new uint[](groupsData.getRecommendedNumberOfNodes(groupIndex));\n\ncoverage_0x70343aa7(0x7fae294c3912030be88a3e8ebf47edadba291846688033ccc5369a2208dfbbb6); /* line */ \n        coverage_0x70343aa7(0x97b9715f1c447e04f7c11e22966e5aaf79adc9a4a7454e240d20af7d0001b7d8); /* statement */ \nuint[] memory possibleNodes = this.isEnoughNodes(groupIndex);\ncoverage_0x70343aa7(0xaa9f4de1a3fe7dff111228b90c910f9c70670889c9f528ab799115ec289b2a25); /* line */ \n        coverage_0x70343aa7(0x0cd2d9cfb0fb4a9378f66ceb4e48ceb6850581a787a4a90ca2272e093246fc95); /* assertPre */ \ncoverage_0x70343aa7(0xdc6eaaf4bcd4eb49b0ad9aa31c7ebfa4894b129c7ac06c85f2315406e9b030b1); /* statement */ \nrequire(possibleNodes.length >= nodesInGroup.length, \"Not enough nodes to create Schain\");coverage_0x70343aa7(0x0a9ce59381e4a91966514bb2dbed689fdee9bf2ee3d0ec992bb812a5444f961e); /* assertPost */ \n\ncoverage_0x70343aa7(0xcaf6e47a4dd1be2007f7531f19691797d5645b90a4e66f27a034934b79ebaa71); /* line */ \n        coverage_0x70343aa7(0x17bc9aa3dfdfb33beab77d117320da93f74cc7cd80005dbf83d03fcd38b3d991); /* statement */ \nuint ignoringTail = 0;\ncoverage_0x70343aa7(0x8e70403dfeca86dd4302256590ed868687d98c62655b662757039e86115c2ebd); /* line */ \n        coverage_0x70343aa7(0x08dc517063514a4bb9422bcd6b3044c588663f5580536f56655d11afc9eaba28); /* statement */ \nuint random = uint(keccak256(abi.encodePacked(uint(blockhash(block.number - 1)), groupIndex)));\ncoverage_0x70343aa7(0xa614da5e3339159d0d2e7f83ebc243f763cb4ab82a419b99f5272322490a07bd); /* line */ \n        coverage_0x70343aa7(0x716eaaf23b3b758f056b8b46ecffdabb768c6bb32823715564114e788e64ffea); /* statement */ \nfor (uint i = 0; i < nodesInGroup.length; ++i) {\ncoverage_0x70343aa7(0xe5e6f7ef931870140b6282ad99bf8ecdc01d3b14d0a4229647545dc8ed9e561f); /* line */ \n            coverage_0x70343aa7(0x9b4d5ed56ffa1a4021a21620b57cc8b47954bd169a0c01fe27b3b67a73a3ffdc); /* statement */ \nuint index = random % (possibleNodes.length - ignoringTail);\ncoverage_0x70343aa7(0x8c2ddc6746c7eb7f6760bb13affba8785b457d878bc1008a5693fe3114730dd3); /* line */ \n            coverage_0x70343aa7(0xaba582c7316b177cb8b521f987093110dd722e0052dc5f644d4563ba221405cf); /* statement */ \nuint node = possibleNodes[index];\ncoverage_0x70343aa7(0x4bb7a00491047d7ac6c44203eb23855e69772809f35eb69496304dc97681791c); /* line */ \n            coverage_0x70343aa7(0x6a83980127987c74691bb4d8bf4235b7e2d2de75c80a0c2c568b42c48c997c58); /* statement */ \nnodesInGroup[i] = node;\ncoverage_0x70343aa7(0x4c0cabc3cadc25d360f787b5b161842346c1cc76b557d1054a610bcf6a0bcc7d); /* line */ \n            coverage_0x70343aa7(0x3d7138601187a1229d2ec2d1d68a099ead7efb228d3198b5f027a538aa2c0358); /* statement */ \nswap(possibleNodes, index, possibleNodes.length - ignoringTail - 1);\ncoverage_0x70343aa7(0x7efa92fc1ca690e8dbca4941424550070abf8e8d98184c7e678e3fd12e2cb296); /* line */ \n            ++ignoringTail;\n\ncoverage_0x70343aa7(0x467f35722793bbeb68296818cef3837faebde6743e525ef2506dea2f7a1cca05); /* line */ \n            coverage_0x70343aa7(0x1d41a06451446318cf75fca6502043a367634ca9f1cc0f165366d13bd05df031); /* statement */ \ngroupsData.setException(groupIndex, node);\ncoverage_0x70343aa7(0x5ce499da68917be14c715ca9d6ddcb0ba7b29433f081629479bb955addcb02c8); /* line */ \n            coverage_0x70343aa7(0xa358f6c0de43e4ff810354fca77ad61e8be84489d8181578c5748034fd284cd4); /* statement */ \nschainsData.addSchainForNode(node, groupIndex);\ncoverage_0x70343aa7(0x22f67234b7fa5ec1e8f61c0358d3eb96334830cdb7e092ea3f05fe10bfa41a72); /* line */ \n            coverage_0x70343aa7(0x16ce18198b2c727a3581a1c1af52034785a93eb7ed4113e8bd22b0b5b964a328); /* assertPre */ \ncoverage_0x70343aa7(0xf9ab81f6470c70c2983da1dca71e509b9f21447d52727bbe1d972a33a2f92b66); /* statement */ \nrequire(removeSpace(node, space), \"Could not remove space from Node\");coverage_0x70343aa7(0x9b39aefdd366f1c6a5315af2f2c4f32fe269549b24db21d8a5973fcc8576caa3); /* assertPost */ \n\n        }\n\n        // set generated group\ncoverage_0x70343aa7(0x1f62ad28aa05bc3487fd784ed75c3393daa409a35068381d83f51436aa12ca63); /* line */ \n        coverage_0x70343aa7(0xf58ad6ca2773e1d7e3f829d114dc27ac69e19a7b09c5885ef9f57617e15d0cd1); /* statement */ \ngroupsData.setNodesInGroup(groupIndex, nodesInGroup);\ncoverage_0x70343aa7(0x1d4928e6daf667b6d443c131d68fcc9371d3c1433db28bd5e721f164137cd810); /* line */ \n        coverage_0x70343aa7(0x4a7cbf5d21ba6dddc2ca36a1e0ed842ae96cfce4ccb892a6b82b63b3c2f304d8); /* statement */ \nemit GroupGenerated(\n            groupIndex,\n            nodesInGroup,\n            uint32(block.timestamp),\n            gasleft());\n    }\n\n    /**\n     * @dev removeSpace - occupy space of given Node\n     * @param nodeIndex - index of Node at common array of Nodes\n     * @param space - needed space to occupy\n     * @return if ouccupied - true, else - false\n     */\n    function removeSpace(uint nodeIndex, uint8 space) internal returns (bool) {coverage_0x70343aa7(0x0d02977b0ae04525237eb25156a17d8d3a8547227b4b55be855f548cbb23b702); /* function */ \n\ncoverage_0x70343aa7(0x40f55e95f78e1ddc97d592c7d54a513a83047baa61e87b71ae7bd17ac2794036); /* line */ \n        coverage_0x70343aa7(0xe168ac768d58a524b974f01004da3618d37d3f202df11eaab51870807df199ba); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\n        // uint subarrayLink;\n        // bool isNodeFull;\n        // (subarrayLink, isNodeFull) = INodesData(nodesDataAddress).nodesLink(nodeIndex);\n        // if (isNodeFull) {\n        //     return INodesData(nodesDataAddress).removeSpaceFromFullNode(subarrayLink, space);\n        // } else {\n        //     return INodesData(nodesDataAddress).removeSpaceFromFractionalNode(subarrayLink, space);\n        // }\ncoverage_0x70343aa7(0xa6cde34728ec1fd44903ac3b6d661136351adaeeadde27f3e541ce1702717569); /* line */ \n        coverage_0x70343aa7(0x38158bab9e4516ac26ed62b69c3d78fd218f225f33c36f6c3fc4eaa4b84837b1); /* statement */ \nreturn INodesData(nodesDataAddress).removeSpaceFromNode(nodeIndex, space);\n    }\n\n    function isCorrespond(bytes32 groupIndex, uint nodeIndex) internal view returns (bool) {coverage_0x70343aa7(0xc57e024e47eb9180550fac12b485dedd7ba699f6e95493e899c1ac2f22ddeeee); /* function */ \n\ncoverage_0x70343aa7(0x5a839753c9dafd3655397b985d762b4eb2bdf5d257a353dbca051220f8cafa42); /* line */ \n        coverage_0x70343aa7(0x900a1973a01de979d7ba16ffa13ae444603d211e950de6ff132275960b6ce8c0); /* statement */ \nIGroupsData groupsData = IGroupsData(contractManager.contracts(keccak256(abi.encodePacked(dataName))));\ncoverage_0x70343aa7(0x3e3a4b4d9c248de7ce30b63e0ca4cc2a8cee645146b44b5bbd1430a32d8bdfbf); /* line */ \n        coverage_0x70343aa7(0x572f95c6799d9bdd5c682f22b82618f0a46676b805f38991f1b29ec92e766d48); /* statement */ \nINodesData nodesData = INodesData(contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\"))));\ncoverage_0x70343aa7(0x48531b6eec9285ceb3ee3379fb7f69a6924206e42a12667b342e2f678866378f); /* line */ \n        coverage_0x70343aa7(0x1e09bdbb7ce630393c9720db122c0e807468b37720f75ac8052b889fe4d700e4); /* statement */ \nreturn !groupsData.isExceptionNode(groupIndex, nodeIndex) && nodesData.isNodeActive(nodeIndex);\n    }\n\n\n    // /**\n    //  * @dev setNumberOfNodesInGroup - checks is Nodes enough to create Schain\n    //  * and returns number of Nodes in group\n    //  * and how much space would be occupied on its, based on given type of Schain\n    //  * @param groupIndex - Groups identifier\n    //  * @param partOfNode - divisor of given type of Schain\n    //  * @param dataAddress - address of Data contract\n    //  * @return numberOfNodes - number of Nodes in Group\n    //  * @return space - needed space to occupy\n    //  */\n    // function setNumberOfNodesInGroup(bytes32 groupIndex, uint8 partOfNode, address dataAddress)\n    // internal view returns (uint numberOfNodes)\n    // {\n    //     address nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\n    //     // address constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\n    //     address schainsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsData\")));\n    //     // uint numberOfAvailableNodes = 0;\n    //     uint needNodes = 1;\n    //     bool nodesEnough = false;\n    //     if (IGroupsData(schainsDataAddress).getNumberOfNodesInGroup(groupIndex) == 0) {\n    //         needNodes = IGroupsData(dataAddress).getRecommendedNumberOfNodes(groupIndex);\n    //     }\n    //     numberOfNodes = INodesData(nodesDataAddress).getNumberOfNodes();\n    //     nodesEnough = INodesData(nodesDataAddress).enoughNodesWithFreeSpace(partOfNode, needNodes);\n    //     // if (partOfNode == IConstants(constantsAddress).MEDIUM_DIVISOR()) {\n    //     //     numberOfNodes = INodesData(nodesDataAddress).getNumberOfNodes();\n    //     //     nodesEnough = INodesData(nodesDataAddress).enoughNodesWithFreeSpace(partOfNode, needNodes);\n    //     // } else if (partOfNode == IConstants(constantsAddress).TINY_DIVISOR() || partOfNode == IConstants(constantsAddress).SMALL_DIVISOR()) {\n    //     //     space = IConstants(constantsAddress).TINY_DIVISOR() / partOfNode;\n    //     //     numberOfNodes = INodesData(nodesDataAddress).getNumberOfNodes();\n    //     //     nodesEnough = INodesData(nodesDataAddress).getNumberOfFreeodes(space, needNodes);\n    //     // } else if (partOfNode == IConstants(constantsAddress).MEDIUM_TEST_DIVISOR()) {\n    //     //     space = IConstants(constantsAddress).TINY_DIVISOR() / partOfNode;\n    //     //     numberOfNodes = INodesData(nodesDataAddress).getNumberOfNodes();\n    //     //     numberOfAvailableNodes = INodesData(nodesDataAddress).numberOfActiveNodes();\n    //     //     nodesEnough = numberOfAvailableNodes >= needNodes ? true : false;\n    //     // } else if (partOfNode == 0) {\n    //     //     space = partOfNode;\n    //     //     numberOfNodes = INodesData(nodesDataAddress).getNumberOfNodes();\n    //     //     numberOfAvailableNodes = INodesData(nodesDataAddress).numberOfActiveNodes();\n    //     //     nodesEnough = numberOfAvailableNodes >= needNodes ? true : false;\n    //     // } else {\n    //     //     revert(\"Can't set number of nodes. Divisor does not match any valid schain type\");\n    //     // }\n    //     // Check that schain is not created yet\n    //     require(nodesEnough, \"Not enough nodes to create Schain\");\n    // }\n}"
    },
    ".coverage_contracts/SkaleDKG.sol": {
      "content": "/*\n    SkaleDKG.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\npragma experimental ABIEncoderV2;\nimport \"./Permissions.sol\";\nimport \"./interfaces/IGroupsData.sol\";\nimport \"./interfaces/INodesData.sol\";\nimport \"./interfaces/ISchainsFunctionality.sol\";\nimport \"./interfaces/ISchainsFunctionalityInternal.sol\";\nimport \"./SchainsFunctionality.sol\";\nimport \"./SchainsFunctionalityInternal.sol\";\n\ninterface IECDH {\n    function deriveKey(\n        uint256 privKey,\n        uint256 pubX,\n        uint256 pubY\n    )\n        external\n        pure\n        returns(uint256, uint256);\n}\n\ninterface IDecryption {\n    function decrypt(bytes32 ciphertext, bytes32 key) external pure returns (uint256);\n}\n\n\ncontract SkaleDKG is Permissions {\nfunction coverage_0x645ceaf0(bytes32 c__0x645ceaf0) public pure {}\n\n\n    struct Channel {\n        bool active;\n        address dataAddress;\n        bool[] broadcasted;\n        uint numberOfBroadcasted;\n        Fp2 publicKeyx;\n        Fp2 publicKeyy;\n        uint numberOfCompleted;\n        bool[] completed;\n        uint startedBlockNumber;\n        uint nodeToComplaint;\n        uint fromNodeToComplaint;\n        uint startComplaintBlockNumber;\n    }\n\n    struct Fp2 {\n        uint x;\n        uint y;\n    }\n\n    struct BroadcastedData {\n        bytes secretKeyContribution;\n        bytes verificationVector;\n    }\n\n    uint constant P = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    uint constant G2A = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint constant G2B = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint constant G2C = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint constant G2D = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n\n    uint constant TWISTBX = 19485874751759354771024239261021720505790618469301721065564631296452457478373;\n    uint constant TWISTBY = 266929791119991161246907387137283842545076965332900288569378510910307636690;\n\n    uint constant G1A = 1;\n    uint constant G1B = 2;\n\n    mapping(bytes32 => Channel) public channels;\n    mapping(bytes32 => mapping(uint => BroadcastedData)) data;\n\n    event ChannelOpened(bytes32 groupIndex);\n\n    event ChannelClosed(bytes32 groupIndex);\n\n    event BroadcastAndKeyShare(\n        bytes32 indexed groupIndex,\n        uint indexed fromNode,\n        bytes verificationVector,\n        bytes secretKeyContribution\n    );\n\n    event AllDataReceived(bytes32 indexed groupIndex, uint nodeIndex);\n    event SuccessfulDKG(bytes32 indexed groupIndex);\n    event BadGuy(uint nodeIndex);\n    event FailedDKG(bytes32 indexed groupIndex);\n    event ComplaintSent(bytes32 indexed groupIndex, uint indexed fromNodeIndex, uint indexed toNodeIndex);\n    event NewGuy(uint nodeIndex);\n\n    modifier correctGroup(bytes32 groupIndex) {coverage_0x645ceaf0(0x48aaec2882e54fc1e12a777990d5cfc4b67cb94623342bb83858d90b0999635d); /* function */ \n\ncoverage_0x645ceaf0(0x6fe3f88dc770044f65f4a65e46ab6c1516348de94f3111c797af24dcd1c5b0d0); /* line */ \n        coverage_0x645ceaf0(0xe4d1a047554235de84f842d27624c49e5e3cbe17b2db86c81f0180770108009c); /* assertPre */ \ncoverage_0x645ceaf0(0x2b4336d7ed306324769369becd96916c24c3ce4d4040901d7f3fccc88e2e5124); /* statement */ \nrequire(channels[groupIndex].active, \"Group is not created\");coverage_0x645ceaf0(0xf6f2375edd49f349de24ff4f417e4f4e48558f550d7c1ed2417f12ec8711131d); /* assertPost */ \n\ncoverage_0x645ceaf0(0xf19dcf9c91581ade280192b8020d8251d457b79a0c31376f56d7b3ae503982a5); /* line */ \n        _;\n    }\n\n    modifier correctNode(bytes32 groupIndex, uint nodeIndex) {coverage_0x645ceaf0(0xb222551bc709c5e496b725eca2be2b151d9aec8a946cac6e7bc1b420fc6c4e48); /* function */ \n\ncoverage_0x645ceaf0(0x669aaf4fbbeab1f2f2b6ca2416df8a76bef275b39f2f934a499fc1aa976e7750); /* line */ \n        coverage_0x645ceaf0(0x902fd4a5744b06612eb29756229acc330dda6b219c73686444045cea64356db9); /* statement */ \nuint index = findNode(groupIndex, nodeIndex);\ncoverage_0x645ceaf0(0x7d3bd902e363c1aee5d6aef646450d516b6a23f79d7042c444662c27d0b8d004); /* line */ \n        coverage_0x645ceaf0(0x2d27ea88e3aefbd2fb30ec7964d6e65831ae68b0a339ee05c60f18e33fdc1835); /* assertPre */ \ncoverage_0x645ceaf0(0x7fdca51bdd7ddba26c68697159c48cbaa93e2437158fc4ae5beb2c52d9ded8f7); /* statement */ \nrequire(index < IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex), \"Node is not in this group\");coverage_0x645ceaf0(0xf172e002a279cd01480ec1c4b5a1e3a246be2a21960197ebc722b871f18570bd); /* assertPost */ \n\ncoverage_0x645ceaf0(0x0a0a2ea8c130a6df928fad48dea4a056013718bedd16dcea49864b0c8962a3d9); /* line */ \n        _;\n    }\n\n    constructor(address contractsAddress) Permissions(contractsAddress) public {coverage_0x645ceaf0(0x30e48e557d4be8e498d9f727aa5a71772e788d1e074a962d9947fd82f314bdcc); /* function */ \n\n\n    }\n\n    function openChannel(bytes32 groupIndex) external allowThree(\"SchainsData\", \"ValidatorsData\", \"SkaleDKG\") {coverage_0x645ceaf0(0xd98be14999f3b7a9f9605cb289ffa9b5b022e1107aa9c67d15293f6a32547951); /* function */ \n\ncoverage_0x645ceaf0(0xee7735984f767c554091fcbb40b5af5e14a6cf26f524de666dd8154c978551eb); /* line */ \n        coverage_0x645ceaf0(0x9a5483c2f8c3ac53dd9bc0e44ac9530d4900171cf923bc784f17706c86142ead); /* assertPre */ \ncoverage_0x645ceaf0(0xb5f13ddf6763e4e90f913e2a5730010b931b8d9aa5e7beac1f4ca2ea26a7187b); /* statement */ \nrequire(!channels[groupIndex].active, \"Channel already is created\");coverage_0x645ceaf0(0x96df81a6052202768e0da6658bd3dbcd94fbb4cc4bead1bf4de9100e32fcd1e3); /* assertPost */ \n\ncoverage_0x645ceaf0(0x15020d6c25d007dc37d1a5dc3c11d9bcfacaeaa916bb45c32369bf7dc819109a); /* line */ \n        coverage_0x645ceaf0(0x1eb8718c8382ed2237c5a6d026c9eb8b6794ff322ffed5e1e4ddd8c2907461d9); /* statement */ \nchannels[groupIndex].active = true;\ncoverage_0x645ceaf0(0x784dcc37ed8d4672a56542ee7448815552884615562bef5aedc8631dbd4a7608); /* line */ \n        coverage_0x645ceaf0(0xce22409f24e1861a6bf41279a4499f1996a1dbcdf306d6d4cf5a751790b03d74); /* statement */ \nchannels[groupIndex].dataAddress = msg.sender;\ncoverage_0x645ceaf0(0xc06212f71317c42b1d53af81f8b112deb47fa32b5e6a73cf54e6eb84b63e8b24); /* line */ \n        coverage_0x645ceaf0(0x51e51cbe99f006ffab2835049188b753f34fd4da3939679cb5f7c0fcd9a48f74); /* statement */ \nchannels[groupIndex].broadcasted = new bool[](IGroupsData(channels[groupIndex].dataAddress).getRecommendedNumberOfNodes(groupIndex));\ncoverage_0x645ceaf0(0xd08c362ae0c344cc9c5c7f702cb087015287766904d249777bf8bc2e0bdbddbe); /* line */ \n        coverage_0x645ceaf0(0xeb9597c9e234d0e2364d99fbdc94b0b528193a2228f80fa9af7a94c552e624e9); /* statement */ \nchannels[groupIndex].completed = new bool[](IGroupsData(channels[groupIndex].dataAddress).getRecommendedNumberOfNodes(groupIndex));\ncoverage_0x645ceaf0(0x73d57861ff99256ad5d987dfeffa60a3d01f39e24d1daa96d33c138a014c027e); /* line */ \n        coverage_0x645ceaf0(0xaef29fbc86ad505c3bdf01bf6e2b1b16249f001a8c397150c3501bffe34b24c5); /* statement */ \nchannels[groupIndex].publicKeyy.x = 1;\ncoverage_0x645ceaf0(0x820c11bfa2c6e97421db8792309d3e580f855987380f8ace8064501384de1a39); /* line */ \n        coverage_0x645ceaf0(0x358735560e4a1bc06ced808b5f417a1e5feafcdd924c307a1f412caabfac63d6); /* statement */ \nchannels[groupIndex].nodeToComplaint = uint(-1);\ncoverage_0x645ceaf0(0x5761d6d2df13622219a3430ff0481dd37a1d9f3a0a931aae9538fa2629888a60); /* line */ \n        coverage_0x645ceaf0(0x6835f1e28245cb3bae287d200627e5d754f8b6ea65f35edab8e30be0e070cbdb); /* statement */ \nemit ChannelOpened(groupIndex);\n    }\n\n    function deleteChannel(bytes32 groupIndex) external allowTwo(\"SchainsData\", \"ValidatorsData\") {coverage_0x645ceaf0(0xbecf45146e720f7653cd9794ed24bf7712007130f528bc648b60a43fd91c3b18); /* function */ \n\ncoverage_0x645ceaf0(0x6b567d91c03494b4239f9a62778a32fd578dec1efc7976aa1bdcbc2cd21f07be); /* line */ \n        coverage_0x645ceaf0(0xf6fedfc9704ca19f4a960c2142bed39ab3d5364f6dd19e5b39eb83f36b30d5f8); /* assertPre */ \ncoverage_0x645ceaf0(0x74094ba0cc6ad3374df021dafd78a9eb729758bbdb4fd65155479248616cd565); /* statement */ \nrequire(channels[groupIndex].active, \"Channel is not created\");coverage_0x645ceaf0(0xd98f9d243e6f5d800330ca2009bedfadb10cd07765b2e2ee9f113150509bb961); /* assertPost */ \n\ncoverage_0x645ceaf0(0x49096bdaee7744ea7d8949118f05cc564b4332c808424a6d46d601b9c082c79a); /* line */ \n        delete channels[groupIndex];\n    }\n\n    function broadcast(\n        bytes32 groupIndex,\n        uint nodeIndex,\n        bytes calldata verificationVector,\n        bytes calldata secretKeyContribution\n    )\n        external\n        correctGroup(groupIndex)\n        correctNode(groupIndex, nodeIndex)\n    {coverage_0x645ceaf0(0xb991a780bf882e1bc5e984e74b17c6f2bb32a755924b3bb69b27ff012bb81f8d); /* function */ \n\ncoverage_0x645ceaf0(0x428392bb535cf8123b7613aa421d43d96715f47037cdbec0fb60ebe152da0d9f); /* line */ \n        coverage_0x645ceaf0(0x65f5c28460daf57ed8d27aede937817f4b27d80656d3a4f341beb07382ab1e36); /* assertPre */ \ncoverage_0x645ceaf0(0x7989c76c14b07e409cb347c6db88861272e1886d45bc4aee5cd3cc850f680094); /* statement */ \nrequire(isNodeByMessageSender(nodeIndex, msg.sender), \"Node does not exist for message sender\");coverage_0x645ceaf0(0xf2836ae29512a94a04704cef584790797a68c704df2fd23734a7f2e50d993c60); /* assertPost */ \n\ncoverage_0x645ceaf0(0x8ee3c453879b1ca466d7b8198fec2420749764807e2d9aef5552c56bbc3c9adc); /* line */ \n        coverage_0x645ceaf0(0x185f16de2e6486495f7f6b61487295dfcfa81bdefe1b276e4ca0e74a7084b43b); /* statement */ \nisBroadcast(\n            groupIndex,\n            nodeIndex,\n            secretKeyContribution,\n            verificationVector\n        );\ncoverage_0x645ceaf0(0x40dabb9d42fcad9a678342f693c83d2c908ef495a05ebc398e45db89699946db); /* line */ \n        coverage_0x645ceaf0(0x3d8d31026078367f8511a05a5c1133512ac75a6a86b83db9d595bb7b90ebf30f); /* statement */ \nbytes32 vector;\ncoverage_0x645ceaf0(0x8f29fcc41574def15133e6958d1085994ec8f16f4be476d1e90363a7d11483fc); /* line */ \n        coverage_0x645ceaf0(0xbb271edda6b72810c75f05e8fdb841eedd3dca4c9a258f345f3bc257bd1c2d58); /* statement */ \nbytes32 vector1;\ncoverage_0x645ceaf0(0xb3ab2fad191b9a6487afb1b1cb90508195c8f480124ae8e7ffd8f968cc69538f); /* line */ \n        coverage_0x645ceaf0(0x9f30ec24808758a3a2c7d249e47d8f916ec88c132814a8b433bc5ce90964d994); /* statement */ \nbytes32 vector2;\ncoverage_0x645ceaf0(0xb7c551d5055d9bbc09d1015f76f53c082f1c869d456dd6b6576b07ce0b8e93a6); /* line */ \n        coverage_0x645ceaf0(0x9aa33c08e7b54009a7c6b25cf2f0510b104df32babce705ef95fc07b1d2ad0c7); /* statement */ \nbytes32 vector3;\ncoverage_0x645ceaf0(0xd5e6fc19adb0a68212e6ded4350c8e8dc367b8b97968f65b8c5e70619fcf0d20); /* line */ \n        assembly {\n            vector := calldataload(add(4, 160))\n            vector1 := calldataload(add(4, 192))\n            vector2 := calldataload(add(4, 224))\n            vector3 := calldataload(add(4, 256))\n        }\ncoverage_0x645ceaf0(0xbbd31cb09430cbd344e4d6c96ae16607adfe80839eed59bcc8fd521ca3c1642e); /* line */ \n        coverage_0x645ceaf0(0xee4a553dbd482422075e0395e0c046f2ce1c04e2c6d3d7babf1ddb8246d810ca); /* statement */ \nadding(\n            groupIndex,\n            uint(vector),\n            uint(vector1),\n            uint(vector2),\n            uint(vector3)\n        );\ncoverage_0x645ceaf0(0x3d875c2ff5e9d5643b9095f740ec75d2c9fc4caf22b4329a9672afd68247b938); /* line */ \n        coverage_0x645ceaf0(0x43e1237d8597078bc88a49b2f0a5c10fb204eead7c8b30c7974f12d5e335b8d9); /* statement */ \nemit BroadcastAndKeyShare(\n            groupIndex,\n            nodeIndex,\n            verificationVector,\n            secretKeyContribution\n        );\n    }\n\n    function complaint(bytes32 groupIndex, uint fromNodeIndex, uint toNodeIndex)\n        external\n        correctGroup(groupIndex)\n        correctNode(groupIndex, fromNodeIndex)\n        correctNode(groupIndex, toNodeIndex)\n    {coverage_0x645ceaf0(0x10ca5ca2094a49a04f32617399b8023224cf8a476bd1f6aaae74d28b6faf5766); /* function */ \n\ncoverage_0x645ceaf0(0x53138390bf1badcec1441d38099bea3a8db3d9227b15f89320ada33e0b8437fb); /* line */ \n        coverage_0x645ceaf0(0x57eda6a451d2528488b992ff436d5100a6a64497dcc85109f936540eb91637b8); /* assertPre */ \ncoverage_0x645ceaf0(0x7168da14de635c1020d11813ed5f4e14e7cbbf176de5cac4fb08494cfa10b1e6); /* statement */ \nrequire(isNodeByMessageSender(fromNodeIndex, msg.sender), \"Node does not exist for message sender\");coverage_0x645ceaf0(0xb71077d349c9d1f1c2114c066f488ed9312d1bc707c7b5f8333f15d727c4c8ef); /* assertPost */ \n\ncoverage_0x645ceaf0(0x72249aea8e8bf504e982603d0fad480b13e42c451b5a9f26d30619dda1356dbc); /* line */ \n        coverage_0x645ceaf0(0x1ecdf285d03d55a458959e95e00cbc0c82b3dcdc945b37c87345b68b6687a82b); /* statement */ \nif (isBroadcasted(groupIndex, toNodeIndex) && channels[groupIndex].nodeToComplaint == uint(-1)) {coverage_0x645ceaf0(0x218a34bfbd7bd8e5f41d09735b86a0f09ce2fab82c5f882d8b572eee4dd766b1); /* branch */ \n\n            // need to wait a response from toNodeIndex\ncoverage_0x645ceaf0(0xfb3f3283237aa74d00febd4d514a1b22cc24765f0781b055ed8cca4200a017fa); /* line */ \n            coverage_0x645ceaf0(0xf93854a656f88aec65e9e542c3ee049d86dcbe46f8672f86b8ea1d9d071738bd); /* statement */ \nchannels[groupIndex].nodeToComplaint = toNodeIndex;\ncoverage_0x645ceaf0(0x1d3efb0b6cf8e21e8273dcbcea4e7442aca90e1ec71963f6289bb5ce89c922cc); /* line */ \n            coverage_0x645ceaf0(0x927c6209593527bffaddf5b27dbc881c170fd9a920608fc0a990cc9c4cadf78b); /* statement */ \nchannels[groupIndex].fromNodeToComplaint = fromNodeIndex;\ncoverage_0x645ceaf0(0xf78577a28b133a4ea4bff35b4d19b79f42e33b12b2f0dcc80119120a2d162903); /* line */ \n            coverage_0x645ceaf0(0xa25df9a05cd1f9e2c3c84a0e68eeedb5e1ffc1393234db29e6427fb8188f5b07); /* statement */ \nchannels[groupIndex].startComplaintBlockNumber = block.number;\ncoverage_0x645ceaf0(0x7e2d849134624ed4ed23bc5d19e19ece84f5d63e29b03b3a0a8816d5930d60b0); /* line */ \n            coverage_0x645ceaf0(0x69c8c55d85c41824765a9bcec1710ddc35c538e82f0bd89c5b517780e0f3983b); /* statement */ \nemit ComplaintSent(groupIndex, fromNodeIndex, toNodeIndex);\n        } else {coverage_0x645ceaf0(0xb6e400b7052a4761897afc87adc9e17be85aca835882179a6e4e96ff0b557ce2); /* statement */ \ncoverage_0x645ceaf0(0xdc3dd731db0c216c862f2dd30c160d3e04642b3fb95d72d989576a3ea4dd0bc4); /* branch */ \nif (isBroadcasted(groupIndex, toNodeIndex) && channels[groupIndex].nodeToComplaint != toNodeIndex) {coverage_0x645ceaf0(0xa8bfd83b0ed75b2483b04153e0a41cad41fcc8f4a899e15ae01fbe4597e8396d); /* branch */ \n\ncoverage_0x645ceaf0(0x1db43bfebcbbc868d92a3678d1e6d5c826f63ca67b86e70cb3424240bf0cf2e7); /* line */ \n            coverage_0x645ceaf0(0x9a773cd05f4725ee2fc86a2fdf217bfba967618f603f4d2713addba20827010a); /* statement */ \nrevert(\"One complaint has already sent\");\n        } else {coverage_0x645ceaf0(0x9804c64e36b14b7d656d677f5eac9fbaa6661ac896ca6234edf185fba3020a56); /* statement */ \ncoverage_0x645ceaf0(0xa4ded7da104b9dcd583cf3b64ccd2e8e5fffece2072b142f6005f317480d6d9f); /* branch */ \nif (isBroadcasted(groupIndex, toNodeIndex) && channels[groupIndex].nodeToComplaint == toNodeIndex) {coverage_0x645ceaf0(0x019fe856efef5513243d545ac0252c4dd5de2be96e46504243d0e1c58733eb99); /* branch */ \n\ncoverage_0x645ceaf0(0xa53289dce208eb5fda58eb4b9fa5810d7b998538d2cb2dfd96f8a57d6f5e66a0); /* line */ \n            coverage_0x645ceaf0(0x60b5961c9131816710470800b0091c49042712f4f33a9e8675cc5ed0ebe7a68d); /* assertPre */ \ncoverage_0x645ceaf0(0xabf05fadd37ccb48515f65bdbc70932ec9314fa569f95eb43a11a3cc48a7c699); /* statement */ \nrequire(channels[groupIndex].startComplaintBlockNumber + 120 <= block.number, \"One more complaint rejected\");coverage_0x645ceaf0(0x5c59e9b9653257bff5bf14e9aa6ba02f92e98eecb2c8ed7cda013ff79d6a5531); /* assertPost */ \n\n            // need to penalty Node - toNodeIndex\ncoverage_0x645ceaf0(0x900871348566679087efb75da0c2e7106f680cfc18dd25d79411b57379aca63c); /* line */ \n            coverage_0x645ceaf0(0xb214b18ab441bbca0bed567d142004f150e292431a6249f4d65bf6530183d10c); /* statement */ \nfinalizeSlashing(groupIndex, channels[groupIndex].nodeToComplaint);\n        } else {coverage_0x645ceaf0(0x557a3ebd9ca0804f3278ff90ee37599b1104ae64134c3ef124fdd9b8c85449ac); /* statement */ \ncoverage_0x645ceaf0(0x8fefc518f85b2d0285de573e7f6756647fe221eb8ced93f4098fe5073ab3342b); /* branch */ \nif (!isBroadcasted(groupIndex, toNodeIndex)) {coverage_0x645ceaf0(0xce23ca88c9b2aaa222c91314ca19cbe1fc07bdedef439e0f66dcf3824b188e4d); /* branch */ \n\n            // if node have not broadcasted params\ncoverage_0x645ceaf0(0x3a5e63e89b1412c1c35bc9c9406b88878cf4e4590fb1b2f311630160c7b24ca5); /* line */ \n            coverage_0x645ceaf0(0x327c3699dea40ecca574e96ac27ab2a5e1906ae689be3929c4143184198374fa); /* assertPre */ \ncoverage_0x645ceaf0(0x7d0041221fcd14a90fecd789ab9865a5711b220d34a8c238ef14db1779bc86ac); /* statement */ \nrequire(channels[groupIndex].startedBlockNumber + 120 <= block.number, \"Complaint rejected\");coverage_0x645ceaf0(0xf19a5dafb60406b8c9b80040f0ca1a97f4d413bed4db743b1edef7b2b5be8632); /* assertPost */ \n\n            // need to penalty Node - toNodeIndex\ncoverage_0x645ceaf0(0x701def9629afb0997a9ffdda15dfc6baf72ba68467c08869fc472b4527fd7f8b); /* line */ \n            coverage_0x645ceaf0(0x9a9c475572b5580d761e5b168712a76e6329b17356a274aabe9c71bc97e87461); /* statement */ \nfinalizeSlashing(groupIndex, channels[groupIndex].nodeToComplaint);\n        }else { coverage_0x645ceaf0(0xf3ee6db3b00190ac200c3947de7bcaabeed7edafaf59eb4fe88e9cff103b0ec8); /* branch */ \n}}}}\n    }\n\n    function response(\n        bytes32 groupIndex,\n        uint fromNodeIndex,\n        uint secretNumber,\n        bytes calldata multipliedShare\n    )\n        external\n        correctGroup(groupIndex)\n        correctNode(groupIndex, fromNodeIndex)\n    {coverage_0x645ceaf0(0x9703955b0be7b485694c91752886d406fd9cd5682dac3e11231539b058648e8c); /* function */ \n\ncoverage_0x645ceaf0(0xa65fd922f483162ffae3d97ebe295c95894a6f324a4540f81009bb144c1c6a56); /* line */ \n        coverage_0x645ceaf0(0xadb36f1d82d3b9b4d24ffbdfe9738763f50a5a8f6f7e01c2c3f044b128a8ccb1); /* assertPre */ \ncoverage_0x645ceaf0(0x51e4a52159a727519e4ac8eb1a3f34782a9a9f3bf48af8b694fa6f81109f0c4f); /* statement */ \nrequire(channels[groupIndex].nodeToComplaint == fromNodeIndex, \"Not this Node\");coverage_0x645ceaf0(0x87cee31794f231dcbaff800a5087fa40a706bc8564a2442381b7e682d6b25676); /* assertPost */ \n\ncoverage_0x645ceaf0(0x9510631b78b6a436c6b304dc79f5c1d73792272fd69a0a3e5edadbbcdbbeaf7d); /* line */ \n        coverage_0x645ceaf0(0xdd08514ff585af885affbdba26fb1d398041ca7eac8722920b5ad12d580cbca7); /* assertPre */ \ncoverage_0x645ceaf0(0xfb770040b90f712710187ca4b52c6c515002f2628b010fe8373d140e4841c0f9); /* statement */ \nrequire(isNodeByMessageSender(fromNodeIndex, msg.sender), \"Node does not exist for message sender\");coverage_0x645ceaf0(0xa927e3cd20d8b19d17801d028a7ab1506753572bdfd441f004ccf6b0272bc354); /* assertPost */ \n\n\n        // uint secret = decryptMessage(groupIndex, secretNumber);\n\n        // DKG verification(secret key contribution, verification vector)\n        // uint indexOfNode = findNode(groupIndex, fromNodeIndex);\n        // bytes memory verVec = data[groupIndex][indexOfNode].verificationVector;\ncoverage_0x645ceaf0(0x195f4854b20d63348540dc062cef4754744e95e24eed1bfa0bbf60611068129a); /* line */ \n        coverage_0x645ceaf0(0x69066642b1b131622910ec94111026d33982f2cbca2b581f137381651d9b446c); /* statement */ \nbool verificationResult = verify(\n            groupIndex,\n            fromNodeIndex,\n            secretNumber,\n            multipliedShare\n        );\ncoverage_0x645ceaf0(0x2b560cdeaabd75328fe1b504f34b2fa290f57024ba2eca1889d047a14108a4aa); /* line */ \n        coverage_0x645ceaf0(0xac4fcf8d2b7a0e72af4f1e091a6fac26281e643a1977cd7c7cb83cb2f180de2f); /* statement */ \nuint badNode = (verificationResult ? channels[groupIndex].fromNodeToComplaint : channels[groupIndex].nodeToComplaint);\ncoverage_0x645ceaf0(0xddf02e497fdd5464247998bb1655b70448d62768ac5fe8105e870d78bd8e20aa); /* line */ \n        coverage_0x645ceaf0(0x3eabc3fa75e396c9d252c276f4995a3fa3f5be16c3a7e6211c345b0cc1ddf10e); /* statement */ \nfinalizeSlashing(groupIndex, badNode);\n    }\n\n    function allright(bytes32 groupIndex, uint fromNodeIndex)\n        external\n        correctGroup(groupIndex)\n        correctNode(groupIndex, fromNodeIndex)\n    {coverage_0x645ceaf0(0xd0f3d49632a833347ec3b5016a959f41a9a40cfcf0c8f471d995d01f9c5df95e); /* function */ \n\ncoverage_0x645ceaf0(0xaab8c2bc076289f1f00a2eb38ec61aa86668de1fdeec7f0dcc8f9b142399b1b2); /* line */ \n        coverage_0x645ceaf0(0x7db1630a6fa7a74cd16c34aa20e116d90f441711a62667317166faff5a265e39); /* assertPre */ \ncoverage_0x645ceaf0(0xabdba8788817a8ee9f03006952a9297b9e20afc7bb292c2c93b7874fe025d4a5); /* statement */ \nrequire(isNodeByMessageSender(fromNodeIndex, msg.sender), \"Node does not exist for message sender\");coverage_0x645ceaf0(0x76771bc0824c4ad27b34d135802696ff8dbebcc9aafe1d814546411637b29372); /* assertPost */ \n\ncoverage_0x645ceaf0(0xfaddcf704d8f3774e0c84a511f1c8fe261bde3630202d2539938ce975b8acfe5); /* line */ \n        coverage_0x645ceaf0(0xc89b00b00dbd05fca134d579836b67ab0f9bfbbbcc2348d03e80421db81e8232); /* statement */ \nuint index = findNode(groupIndex, fromNodeIndex);\ncoverage_0x645ceaf0(0x3b6e4e07419601cb1107bcfb5d6a69adf501f2a79d220b05dc324a69b9e1c761); /* line */ \n        coverage_0x645ceaf0(0x8967c26ba14cc6b07a4ed453e4f0dd5ecfbf8629445697dd80b9a251b515ca13); /* statement */ \nuint numberOfParticipant = IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex);\ncoverage_0x645ceaf0(0x143dbe727f42c0b031ab689363f9c6d6fd805bc6b5a650bbfca9a8ed2a34b500); /* line */ \n        coverage_0x645ceaf0(0xf67f19a93b484eb2166417d9d8bd8b3971c9052c0093ebd8b42bda9b646c86b6); /* assertPre */ \ncoverage_0x645ceaf0(0x8da6bf975e509a4c5913864a105730b90f92b1b42f36715aa2d538394ffc28d3); /* statement */ \nrequire(numberOfParticipant == channels[groupIndex].numberOfBroadcasted, \"Still Broadcasting phase\");coverage_0x645ceaf0(0xbfd89ae3f32329cc8609e2b65ae538cf99f2125c5eba7cb023abb107bc418176); /* assertPost */ \n\ncoverage_0x645ceaf0(0xc6870cce371e750c593ebe78eaec295ea357cad3ff70ecead5136810c9661472); /* line */ \n        coverage_0x645ceaf0(0x94d44308446105afeebe3d2f0049262443feee827b77e062f41b4641749c3d05); /* assertPre */ \ncoverage_0x645ceaf0(0xff625d07cf35f9edcdc10c22c05885637ab8eb5cba2aa390cc18b96b5973f26a); /* statement */ \nrequire(!channels[groupIndex].completed[index], \"Node is already alright\");coverage_0x645ceaf0(0x487d6beb9fb48a92ea475428b783ff2d3463c4c28cc429c94ac72ac871be8abb); /* assertPost */ \n\ncoverage_0x645ceaf0(0x535cb0809ebd8e4c3b37f19b8f7514689bf6232150ee17de5ec8a260a494372b); /* line */ \n        coverage_0x645ceaf0(0x12506e5f2a13cdf71a08ce1b01c9db3417f1c973d616985a1e37f10c617bb381); /* statement */ \nchannels[groupIndex].completed[index] = true;\ncoverage_0x645ceaf0(0x0e86874f5a4bf2256a8954e304585a06661ef29775e668e01bea458863d5b866); /* line */ \n        channels[groupIndex].numberOfCompleted++;\ncoverage_0x645ceaf0(0xd4809f6b740988cb700fa5a362824bc195d0139bcc53a6dba4baed6e97e43461); /* line */ \n        coverage_0x645ceaf0(0x588ea08757f0067c6b5983151c9ffc29d0b64f55ea6d99bb1b9e867829cdb54c); /* statement */ \nemit AllDataReceived(groupIndex, fromNodeIndex);\ncoverage_0x645ceaf0(0xf79623244c44d82f69f01ad8f7b7442a9ce9451ea451e1b992170f36f10ea7fd); /* line */ \n        coverage_0x645ceaf0(0x4cefee32005a17bee6cfe46be77b03006ffefe13637bfab548a0ee23f73012a1); /* statement */ \nif (channels[groupIndex].numberOfCompleted == numberOfParticipant) {coverage_0x645ceaf0(0x726f6821d5538a7e66ee093447d6c0fd3880f0e43adf33a3cf72eabfbcfa4fba); /* branch */ \n\ncoverage_0x645ceaf0(0xa8e9354b9ccd59c5ca4411d5ad0b91c4016b502562accf4f6cf5c19c4c2e8039); /* line */ \n            coverage_0x645ceaf0(0xc8847feab090c4210e058dd9ab9683f26b7b747d2b1b89b034914fa2ce7cf3c9); /* statement */ \nIGroupsData(channels[groupIndex].dataAddress).setPublicKey(\n                groupIndex,\n                channels[groupIndex].publicKeyx.x,\n                channels[groupIndex].publicKeyx.y,\n                channels[groupIndex].publicKeyy.x,\n                channels[groupIndex].publicKeyy.y\n            );\ncoverage_0x645ceaf0(0xf8d2b429ba1e626174b83155041247c1431cf4e9f72a8956fadf004a48fe5eb4); /* line */ \n            delete channels[groupIndex];\ncoverage_0x645ceaf0(0xc3cf14bb15f5e5297ad658b7d764112db85657c05e79901f1631af6e89bb1661); /* line */ \n            coverage_0x645ceaf0(0x3490d4683243ba0c16788704cdcc2c56b422a8678e24916213bb98da471922d7); /* statement */ \nemit SuccessfulDKG(groupIndex);\n        }else { coverage_0x645ceaf0(0xc652791869a4c4eb9391aa1c3171f490443cd38686cfbeb6a69c83fe34aa606d); /* branch */ \n}\n    }\n\n    function isChannelOpened(bytes32 groupIndex) external view returns (bool) {coverage_0x645ceaf0(0x9e76af25e674d7d95461f2cb9df5fa1268e416e46f3aae3a3fdeddae2b487455); /* function */ \n\ncoverage_0x645ceaf0(0x00cdcf1032dc71818c8ab3d94e31248c8700bc50383bb028bb2fff9e30aa3b3d); /* line */ \n        coverage_0x645ceaf0(0x19f87fe5f6dff2315b413b97a55dc3c4d53919125c6008b0c75b339ecad8d1f0); /* statement */ \nreturn channels[groupIndex].active;\n    }\n\n    function isBroadcastPossible(bytes32 groupIndex, uint nodeIndex) external view returns (bool) {coverage_0x645ceaf0(0x9b7f66a00fc58f2dec8331df32acf369cd5d278dcaf304542417690a6e46b014); /* function */ \n\ncoverage_0x645ceaf0(0x72115064f070bf97188cfdbe7d3072ae9ddce87350735a0214f21511af0c1873); /* line */ \n        coverage_0x645ceaf0(0x4829852004d8b8d8695413c31e512f5e02b7e8808613f8eb10b54aa44468d5ec); /* statement */ \nuint index = findNode(groupIndex, nodeIndex);\ncoverage_0x645ceaf0(0x2f0c24d58fb2f65e4c48d40d4c14c78686c8acbf2e14ceac5aae4a25599fb9a1); /* line */ \n        coverage_0x645ceaf0(0xc638ba461a7356f65b0bed42c8e72a99b41b8f64ef435b145e511541874e7baf); /* statement */ \nreturn channels[groupIndex].active &&\n            index < IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex) &&\n            isNodeByMessageSender(nodeIndex, msg.sender) &&\n            !channels[groupIndex].broadcasted[index];\n    }\n\n    function isComplaintPossible(bytes32 groupIndex, uint fromNodeIndex, uint toNodeIndex) external view returns (bool) {coverage_0x645ceaf0(0x5b16fa37d70755d20025234e165b195624a2802d3d614de039674323eb8d4145); /* function */ \n\ncoverage_0x645ceaf0(0xc920618cee0cbdd837e2f5530aad27b7451226c70abbb558b7fcfb7340740a93); /* line */ \n        coverage_0x645ceaf0(0xce6b35e812cb66c5aa01fc41aca0223b6622fb78d3a87fa77955e59c83985c3e); /* statement */ \nuint indexFrom = findNode(groupIndex, fromNodeIndex);\ncoverage_0x645ceaf0(0x725786b4eda1c4f6857f68bf325b9cdbae9036477993d4330f8f7a97245617f1); /* line */ \n        coverage_0x645ceaf0(0x30fa002297fa4c88c67b8818992fbad188d4be085fe5e4908bbc13efe41d1b87); /* statement */ \nuint indexTo = findNode(groupIndex, toNodeIndex);\ncoverage_0x645ceaf0(0x2004d3fc0b078c5c901918a26341147c3e7e37b45853894cd59995fd649af019); /* line */ \n        coverage_0x645ceaf0(0xb587697ae511fec9ffe9e3a6a02e96edeed9a092038cdfa70089defb16357a3a); /* statement */ \nbool complaintSending = channels[groupIndex].nodeToComplaint == uint(-1) ||\n            (\n                channels[groupIndex].broadcasted[indexTo] &&\n                channels[groupIndex].startComplaintBlockNumber + 120 <= block.number &&\n                channels[groupIndex].nodeToComplaint == toNodeIndex\n            ) ||\n            (\n                !channels[groupIndex].broadcasted[indexTo] &&\n                channels[groupIndex].nodeToComplaint == toNodeIndex &&\n                channels[groupIndex].startedBlockNumber + 120 <= block.number\n            );\ncoverage_0x645ceaf0(0xeb89e3264cfd6ee067b06f4d2e874a5a39d4f0ab0d75874402ffb62dc4f34206); /* line */ \n        coverage_0x645ceaf0(0x5ac4225814f91745b97db9bbf9fceece5fab67f91465e02fe5daebaffd43ba24); /* statement */ \nreturn channels[groupIndex].active &&\n            indexFrom < IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex) &&\n            indexTo < IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex) &&\n            isNodeByMessageSender(fromNodeIndex, msg.sender) &&\n            complaintSending;\n    }\n\n    function isAlrightPossible(bytes32 groupIndex, uint nodeIndex) external view returns (bool) {coverage_0x645ceaf0(0x61cbc044755161fd47aef5a95c45935bd81adc0ededbc1075dace4e50f0591c0); /* function */ \n\ncoverage_0x645ceaf0(0x6703af190f23fa0307fdcf26c14bd33b311b83ebb77c5996249b90efa161b79c); /* line */ \n        coverage_0x645ceaf0(0xe76b03b1ca77270af1b5acd7738b5077b7d8b76b628fb1f72184ab6d64db914f); /* statement */ \nuint index = findNode(groupIndex, nodeIndex);\ncoverage_0x645ceaf0(0x9f0117f1f2f1dc3ad81fc655d51947e99336d8a4cc63a39a746bb98ce5e224a6); /* line */ \n        coverage_0x645ceaf0(0x516f8ca6ca46378aab5484e47a471090a4a5c65eed6f81dab28412a1a0339f83); /* statement */ \nreturn channels[groupIndex].active &&\n            index < IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex) &&\n            isNodeByMessageSender(nodeIndex, msg.sender) &&\n            IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex) == channels[groupIndex].numberOfBroadcasted &&\n            !channels[groupIndex].completed[index];\n    }\n\n    function isResponsePossible(bytes32 groupIndex, uint nodeIndex) external view returns (bool) {coverage_0x645ceaf0(0x4f1964ff642f55137e00b9e9c61fe6ee40572eb748f94a543ca791c0585f13a7); /* function */ \n\ncoverage_0x645ceaf0(0xf001358367377b2ad9e818cffca120a87dd6212700f4b9be7d62b6cb33ccab38); /* line */ \n        coverage_0x645ceaf0(0x77a00048c8ab7bf07710265c0067c0927c7096abc924fff85789e15345176811); /* statement */ \nuint index = findNode(groupIndex, nodeIndex);\ncoverage_0x645ceaf0(0xc82fba232ecdf58bde23a13157c639fe3390dacd62ad91439285afb8b75585cc); /* line */ \n        coverage_0x645ceaf0(0x13228b2c93953411d69ee875ebf3035b0b5a66815838d6a69f05dac98a734fc6); /* statement */ \nreturn channels[groupIndex].active &&\n            index < IGroupsData(channels[groupIndex].dataAddress).getNumberOfNodesInGroup(groupIndex) &&\n            isNodeByMessageSender(nodeIndex, msg.sender) &&\n            channels[groupIndex].nodeToComplaint == nodeIndex;\n    }\n\n    function finalizeSlashing(bytes32 groupIndex, uint badNode) internal {coverage_0x645ceaf0(0xc7797167c312a23c53c4ca9803a9b789877541ec0397aed73101536fcac00397); /* function */ \n\ncoverage_0x645ceaf0(0x7b244c736d618bf6fe0b292614c79cc22f709e017017a01f18905d0ef42559c9); /* line */ \n        coverage_0x645ceaf0(0x371d692b1787eb1cf9fe20c99994ed63d2fd29663e1d6010b00705524ccb9ee1); /* statement */ \nSchainsFunctionalityInternal schainsFunctionalityInternal = SchainsFunctionalityInternal(\n            contractManager.getContract(\"SchainsFunctionalityInternal\"));\ncoverage_0x645ceaf0(0x902c120bba81b2a7f6d83be4a7e9c9c943962b7f8849f4aac8fdead471d5f526); /* line */ \n        coverage_0x645ceaf0(0x9703a7c5f30524d3b14e197b875d0b94446f466830200d81ac990dbc649a4606); /* statement */ \nSchainsFunctionality schainsFunctionality = SchainsFunctionality(\n            contractManager.getContract(\"SchainsFunctionality\"));\n\ncoverage_0x645ceaf0(0x33f3281780b270489637535bda843d158157f93f6c513e2d43a9d325f1b340b7); /* line */ \n        coverage_0x645ceaf0(0x50129aedea4b3b45f7c097dbfc2f1ddff9303a270fa1b726622305fcf4bda8f3); /* statement */ \nemit BadGuy(badNode);\ncoverage_0x645ceaf0(0xf7ad1d9521833601d2b7ec0268ae2929bda14f608fd06948c216d51f6043643c); /* line */ \n        coverage_0x645ceaf0(0xdf9bfac806bb792c5cf0e3e431db0ccca65fa2fbcc46e30b5d8f152626dfb3e6); /* statement */ \nemit FailedDKG(groupIndex);\ncoverage_0x645ceaf0(0x8bba511b0e6ed28dbb063a0a5dc914b88ae143b2f58a223e79c91d42be73f397); /* line */ \n        coverage_0x645ceaf0(0x194a2fa03ba9a755607a1bc5b341891e16376957812d7fbb8cb976cee06aca26); /* statement */ \nif (schainsFunctionalityInternal.isAnyFreeNode(groupIndex)) {coverage_0x645ceaf0(0x664124028aa7382b3057e994ed76f08a458c81ae5fbedddddebd6318836a2bcd); /* branch */ \n\ncoverage_0x645ceaf0(0x5479f4d95388904a972133cbc5f3567998bc02bc8a3baa8567b9b1eb40280a8f); /* line */ \n            coverage_0x645ceaf0(0x5cb471725b190f35087c9820c09d41f3eb9903b1db38db4de90cfc807f0da878); /* statement */ \nuint newNode = schainsFunctionality.rotateNode(\n                badNode,\n                groupIndex\n            );\ncoverage_0x645ceaf0(0xebe8e8da6397f033d29022e620e95f65f923e39663ffe8a98766bc155464db79); /* line */ \n            coverage_0x645ceaf0(0xe7d57a61c1bf8d4d60ff8716fc62b1d9b3f8f7fb79f3568c9b1dfbd799ae1044); /* statement */ \nemit NewGuy(newNode);\ncoverage_0x645ceaf0(0xf90c8bdb7a642977f5fd4a5cf6d6fd60baeae3ca733164f32a0a3172884e3864); /* line */ \n            delete channels[groupIndex];\ncoverage_0x645ceaf0(0x06f8ae87216a55771a33af342401d0b0e187ba3306ed382a362aeb7c829f68c7); /* line */ \n            coverage_0x645ceaf0(0xcd63aaa848fd49a829213a87c57b50aabb9fd974f39d20e660f8316ad0bc8e90); /* statement */ \nthis.openChannel(groupIndex);\n        } else {coverage_0x645ceaf0(0x43b3d800e895d35d9899bd909c4df2a9908ec08eb1cf5dfd801bd1ebe371284a); /* branch */ \n\ncoverage_0x645ceaf0(0x614bf0464eb2b5868c5158c465bffd98a0dca471031dbf4b1ca0c0483da1d354); /* line */ \n            coverage_0x645ceaf0(0x4c05804d0e9196eb117392fd5c2894c5dd687e4c6a676eec28c807f9b41e4113); /* statement */ \nschainsFunctionalityInternal.removeNodeFromSchain(\n                badNode,\n                groupIndex\n            );\ncoverage_0x645ceaf0(0x86fab1b80b73dbffb6e3f3a3b14386c4a7afee5b2d85ca1e7b0891095f20f3dc); /* line */ \n            coverage_0x645ceaf0(0x7c551b2509db939e83abdc87f14aee1ff833f9e651255fe8ae4ae2eadab2da50); /* statement */ \nIGroupsData(channels[groupIndex].dataAddress).setGroupFailedDKG(groupIndex);\ncoverage_0x645ceaf0(0x6f105f6f657d208358b12762e41d487dee52dac17c211ed9ec013bcd8a2df94d); /* line */ \n            delete channels[groupIndex];\n        }\n    }\n\n    function verify(\n        bytes32 groupIndex,\n        uint fromNodeIndex,\n        uint secretNumber,\n        bytes memory multipliedShare\n    )\n        internal\n        view\n        returns (bool)\n    {coverage_0x645ceaf0(0x24607103f6ffa6d6ee0f2abf72e03c428f75b35152e8229ce75744aed856daf6); /* function */ \n\ncoverage_0x645ceaf0(0xe1e28b9e7fe45af0b36b7b3969ae683682f3bfbb58a5778facfa585f9f36b7d1); /* line */ \n        coverage_0x645ceaf0(0x8bb0c299572296804c55d16bebe741ea26039472167e324b4bc9830a554db798); /* statement */ \nuint index = findNode(groupIndex, fromNodeIndex);\ncoverage_0x645ceaf0(0x8be74a2120cde7350a98cb93a3687aa93dea6e9a35c1d617bd7d9e4daa2e0202); /* line */ \n        coverage_0x645ceaf0(0xb8490e8d28d8823b2d2b2c54d9d1760c212b22d67b4e6c4d5cca54f3ed801888); /* statement */ \nuint secret = decryptMessage(groupIndex, secretNumber);\ncoverage_0x645ceaf0(0x989b1dcda648b510993da497ef8b4866a95d362fc44e08a25523c63dede2c583); /* line */ \n        coverage_0x645ceaf0(0xc904a64c43f661edebe71c49230ba78efb7f650c67b03f9d184e20fd9392b4c4); /* statement */ \nbytes memory verificationVector = data[groupIndex][index].verificationVector;\ncoverage_0x645ceaf0(0x52dee84762bab6a24332f077f6341f37bb67e776cbb5923e6c5e989a26ec4dba); /* line */ \n        coverage_0x645ceaf0(0x8c62c9869e24242762e9322ff24757ed9e010f956aeca258fafdda91d56431d3); /* statement */ \nFp2 memory valX = Fp2({x: 0, y: 0});\ncoverage_0x645ceaf0(0x988204c34904d3d7e00ccdeae4efbf2a67fea73793b33ded24ca32572d3a00b1); /* line */ \n        coverage_0x645ceaf0(0x0f2a4651c79a4f5c8b4f96d9578019505a6bffffa550a2ae547dd9d130ba66b7); /* statement */ \nFp2 memory valY = Fp2({x: 1, y: 0});\ncoverage_0x645ceaf0(0xf055a374ad755087fda2b894464cb7f16c70b125ec845e7e9d0230f293e0dfe7); /* line */ \n        coverage_0x645ceaf0(0x1758514e1f359585551bb5c478bbc5b1f6f2ede29a163bccfae5d31e4de5ae18); /* statement */ \nFp2 memory tmpX = Fp2({x: 0, y: 0});\ncoverage_0x645ceaf0(0x443d13a036c80d1108558341c257260ce70e43acf1b81df9a40cf13e1d3d7e63); /* line */ \n        coverage_0x645ceaf0(0xb779e767af383b32e6b8d5b64e869caeddede155b9ce411fee374111ea847bf5); /* statement */ \nFp2 memory tmpY = Fp2({x: 1, y: 0});\ncoverage_0x645ceaf0(0x3c70b9b6181ba10d2b73169dce25bd60d064f4583ce8e8cac3b111c12eb19f53); /* line */ \n        coverage_0x645ceaf0(0x20f7deef3aee073cb741371e50ff9d34237774bf35e47c69f65794740bcb8ee2); /* statement */ \nfor (uint i = 0; i < verificationVector.length / 128; i++) {\ncoverage_0x645ceaf0(0xaa12cea96f52fec0f9926dab1b50a3cf2f5b6e0441f4457b264fbc3c8e5d3ef2); /* line */ \n            coverage_0x645ceaf0(0xc6408e5f7132d6257f7a9ff189e385d015fa5108c3f158120699d2433f3a35a1); /* statement */ \n(tmpX, tmpY) = loop(index, verificationVector, i);\ncoverage_0x645ceaf0(0xf0ae3c6edc1c38c03a22f6f9f9ed89c909dcf250e688022b2a16d3ac367d9522); /* line */ \n            coverage_0x645ceaf0(0x04cd9fefe6ba797ff8f70b09fc0c26cf98a143a66c341f5c8ac614a03f81532c); /* statement */ \n(valX, valY) = addG2(\n                tmpX,\n                tmpY,\n                valX,\n                valY\n            );\n        }\ncoverage_0x645ceaf0(0x69ce34c0b190a6ea2eb33ba99397d2c6d96c9d2663f275a6d5bdd7a316494576); /* line */ \n        coverage_0x645ceaf0(0x426c66e9ae38f5e94fe43975b0166bf900925202fa7409e3c93fb8f4a2c6748e); /* statement */ \nreturn checkDKGVerification(valX, valY, multipliedShare) && checkCorrectMultipliedShare(multipliedShare, secret);\n    }\n\n    function getCommonPublicKey(bytes32 groupIndex, uint256 secretNumber) internal view returns (bytes32 key) {coverage_0x645ceaf0(0x06eec983deb42961b2156142de8df2976e8d6e38cf428a612b516ce0f8a23b39); /* function */ \n\ncoverage_0x645ceaf0(0x931f00672b13ec4418dcb6b05784b3bb6bbd0537a18355a7b6d445090f85f86b); /* line */ \n        coverage_0x645ceaf0(0xd9f829466668cda0d2592ac5bb102e5fdbe31c9ee6688dcc53f06651a38f1ff9); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x645ceaf0(0xb9c52d915350d8271f9b78f8227c2c9a62f67744201ca1062d678df3055fc3c0); /* line */ \n        coverage_0x645ceaf0(0x308b2397526ce5e79d26ae7c47f81505fb0e0d142b3d0be0aac46ccdfd625aef); /* statement */ \naddress ecdhAddress = contractManager.contracts(keccak256(abi.encodePacked(\"ECDH\")));\ncoverage_0x645ceaf0(0xae2f459d0d4fe8cc6a0c82076332fb3f5a7d6e47022f963313b15724d23bc6cb); /* line */ \n        coverage_0x645ceaf0(0xb749ab13287f236785c23a7d27979f8621327349497943c1e824148924301cd0); /* statement */ \nbytes memory publicKey = INodesData(nodesDataAddress).getNodePublicKey(channels[groupIndex].fromNodeToComplaint);\ncoverage_0x645ceaf0(0x3e2862b03a2adce287ac7de93b97af27caea1917069d6b8b640dad853f57a852); /* line */ \n        coverage_0x645ceaf0(0x65fcde1c9cfa4bcc4cb6a38b3bf1992dd08df47a63b079b9e7afb8a0ab0f55fa); /* statement */ \nuint256 pkX;\ncoverage_0x645ceaf0(0xe5b5bb934706aa68a920dba91d765ea017b9426a8bf0e420179d03b227338fcf); /* line */ \n        coverage_0x645ceaf0(0xd961532a339fc18363f692c94b3057a9c4b1d2d92765792fc629d9b59742fc55); /* statement */ \nuint256 pkY;\n\ncoverage_0x645ceaf0(0xd526b823aac4d6519de9114df8f1fd75eb3cf56bf910759aece495eefe99305f); /* line */ \n        coverage_0x645ceaf0(0x1037c0428487bac8aa8c08f6e904ffbb28f351b3e7a38f23bd4010c0642d700a); /* statement */ \n(pkX, pkY) = bytesToPublicKey(publicKey);\n\ncoverage_0x645ceaf0(0xf0b59ed7be807fbbe78526fe2b2994ee8c444554a014997f964ede692c1ef5d1); /* line */ \n        coverage_0x645ceaf0(0x53a87dcf330e20a71106d00d2a799d7fbf8bdc3a6506123fbc0df646747c76fc); /* statement */ \n(pkX, pkY) = IECDH(ecdhAddress).deriveKey(secretNumber, pkX, pkY);\n\ncoverage_0x645ceaf0(0x72777f6eaf2f791b070e83616ec32c933ee25adcb5ed0d3c7bbf4f577df80c47); /* line */ \n        coverage_0x645ceaf0(0xa37872b56ad4b1f655ae14879717db11041be53799486ce238d84f0c303d325d); /* statement */ \nkey = bytes32(pkX);\n    }\n\n    /*function hashed(uint x) public pure returns (bytes32) {\n        return sha256(abi.encodePacked(uint2str(x)));\n    }\n\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n\n    function uint2str(uint num) internal pure returns (string memory) {\n        if (num == 0) {\n            return \"0\";\n        }\n        uint j = num;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        uint num2 = num;\n        while (num2 != 0) {\n            bstr[k--] = byte(uint8(48 + num2 % 10));\n            num2 /= 10;\n        }\n        return string(bstr);\n    }\n\n    function bytes32ToString(bytes32 x) internal pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint charCount = 0;\n        for (uint j = 0; j < 32; j++) {\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }*/\n\n    function decryptMessage(bytes32 groupIndex, uint secretNumber) internal view returns (uint) {coverage_0x645ceaf0(0xc7f6faf3b568f69475b894240139fae6799e8d5e140056f7b82c70d54dc82ba8); /* function */ \n\ncoverage_0x645ceaf0(0x4fb365bfba9a23257c5635e12044a6560aafd54dcd97fc8d9f9c924be5efec2e); /* line */ \n        coverage_0x645ceaf0(0x963dcbb36c90a9542062d529a56f85886bda5e1ebc2187f78c563029311be044); /* statement */ \naddress decryptionAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Decryption\")));\n\ncoverage_0x645ceaf0(0xba6ee1fa47e2b4254f0ef0dfd70a242fbf8f0bda7e5ae36f40bc15311d2b254e); /* line */ \n        coverage_0x645ceaf0(0xc30694d37d24761dc9c6447b4c1ad9dfda908643c5dc260062e450645f3b0b7d); /* statement */ \nbytes32 key = getCommonPublicKey(groupIndex, secretNumber);\n\n        // Decrypt secret key contribution\ncoverage_0x645ceaf0(0xc61266a0aa69f793af6296a2223adaaab47fa50830fde1f3977ef8de235b8e4b); /* line */ \n        coverage_0x645ceaf0(0xe7ada9121f379bcd4bd545783cea8790a3b5566adebe15cbf87c1fee94466e7a); /* statement */ \nbytes32 ciphertext;\ncoverage_0x645ceaf0(0xd1e4b855cf6812c0b350ea6acc50d2ba1fce89713be9e7ef1cdd390b13b3442b); /* line */ \n        coverage_0x645ceaf0(0xe07c28730abfde5c6027fbbc95aeb9a268949c7849da1bb6030f6dd3063714b2); /* statement */ \nuint index = findNode(groupIndex, channels[groupIndex].fromNodeToComplaint);\ncoverage_0x645ceaf0(0x966d22a2a4dd719d83f8c0289c025281ce8e41e87906ba79f600f70d01ebd9e5); /* line */ \n        coverage_0x645ceaf0(0x89605c6925059355048ec606809d17dd375fc6da74c6a60499de6f9e88c6fe10); /* statement */ \nuint indexOfNode = findNode(groupIndex, channels[groupIndex].nodeToComplaint);\ncoverage_0x645ceaf0(0x9abb3ff91b0fee41223e6234f0a5e90f811e9a00518c2ce2a8a7ec03c04185ed); /* line */ \n        coverage_0x645ceaf0(0xcce942a2dd80080a44f37f3b0af6d67cfa384bb5eeba9e568b02aa24395f3033); /* statement */ \nbytes memory sc = data[groupIndex][indexOfNode].secretKeyContribution;\ncoverage_0x645ceaf0(0x6cf5a26b36d17a74fd73b3dac1aa13b7e49167740ed15beede3241ff8ffe1d38); /* line */ \n        assembly {\n            ciphertext := mload(add(sc, add(32, mul(index, 97))))\n        }\n\ncoverage_0x645ceaf0(0xbf8b8389be8886b82b33a62de7b23e70345b48f83925dc519700536f975773cc); /* line */ \n        coverage_0x645ceaf0(0x4c5d3f5320d9d717aabb1b80e34f7e3043d26ca332ceea29a4bf3904926dbb4d); /* statement */ \nuint secret = IDecryption(decryptionAddress).decrypt(ciphertext, key);\ncoverage_0x645ceaf0(0xa288e2357d9d0bb5a8e5f7665b479d3ddf8f23d1660992813e6fa50fff67106a); /* line */ \n        coverage_0x645ceaf0(0xa7b0c484a4f542f04f0c0a7281af8085e9d9e672b6ea1bdcec9587eee5cc5777); /* statement */ \nreturn secret;\n    }\n\n    function adding(\n        bytes32 groupIndex,\n        uint x1,\n        uint y1,\n        uint x2,\n        uint y2\n    )\n        internal\n    {coverage_0x645ceaf0(0x3424dac9ffa62f64a918423fe57273929eab357cce281569dc78a30f954bf4c9); /* function */ \n\ncoverage_0x645ceaf0(0x5940bcc3afcf18590ed495b4328341293b3089e82799c747bef58560f28ca632); /* line */ \n        coverage_0x645ceaf0(0x20a37630c77c37e1ab0830948092549eb69baa45be5b0ea2a04b3902680e8cbd); /* assertPre */ \ncoverage_0x645ceaf0(0x208e820e0fd12a6d081c6fccd75c9bf82ac4ce430a991bdbe3e8de728cb4e64e); /* statement */ \nrequire(isG2(Fp2({ x: x1, y: y1 }), Fp2({ x: x2, y: y2 })), \"Incorrect G2 point\");coverage_0x645ceaf0(0x27c392e6fed2449dc1aeda0d80cbbc31e07df993f2715e25661af10d42852519); /* assertPost */ \n\ncoverage_0x645ceaf0(0x3ef596a35daac48dcf08d98e987cdebdc8628f7f7640f67b50e8a2ac032cda94); /* line */ \n        coverage_0x645ceaf0(0xffaa9a66f8912a5c78bbbcf676897e8d95ab27fe81de1436171c66a26fef704d); /* statement */ \n(channels[groupIndex].publicKeyx, channels[groupIndex].publicKeyy) = addG2(\n            Fp2({ x: x1, y: y1 }),\n            Fp2({ x: x2, y: y2 }),\n            channels[groupIndex].publicKeyx,\n            channels[groupIndex].publicKeyy\n        );\n    }\n\n    function isBroadcast(\n        bytes32 groupIndex,\n        uint nodeIndex,\n        bytes memory sc,\n        bytes memory vv\n    )\n        internal\n    {coverage_0x645ceaf0(0x59534b3f052b3e521999f693e022c1c41b3b5a6b923d343bc6f189d1704249c5); /* function */ \n\ncoverage_0x645ceaf0(0x025b373c7f64e9f23360115b973f730c4c918c0dca900d30f03e221ee2336b3f); /* line */ \n        coverage_0x645ceaf0(0xbaa8b59b30ec7fffce5cd02a6925a8af5ea6a9f5dd948402090c317f021a28a4); /* statement */ \nuint index = findNode(groupIndex, nodeIndex);\ncoverage_0x645ceaf0(0xdce36e72f1a2be9690f9a0c6f059d8b8a27eec6b9e18a0bc07332da164517cdc); /* line */ \n        coverage_0x645ceaf0(0x16a04a8745816e40ced66f452844dbd76619313886af5228340e1324729dda3a); /* assertPre */ \ncoverage_0x645ceaf0(0xdde7bfb219fa6665d046e8f59a300ee2f3deedc0ec48353cb63ec2eecc285410); /* statement */ \nrequire(channels[groupIndex].broadcasted[index] == false, \"This node is already broadcasted\");coverage_0x645ceaf0(0x167fc4da3f164a8bacb7672401de1c7d27fcaf8a605cb9747a2ba3d1500f6b67); /* assertPost */ \n\ncoverage_0x645ceaf0(0xf4707d6e4caff1f091c22f2ecfd3f0e213b5bb0ab7cd80d863bba2a547cc5c0f); /* line */ \n        coverage_0x645ceaf0(0xc38be4c02086d404c4c4e4fe5b0882b53aa9bd817e7d72ea10ee3a3115c72067); /* statement */ \nchannels[groupIndex].broadcasted[index] = true;\ncoverage_0x645ceaf0(0x8d93a9375b0920a802ad8d5b36690ca0d484f27430c60ca38186d653fc3d0b0a); /* line */ \n        channels[groupIndex].numberOfBroadcasted++;\ncoverage_0x645ceaf0(0x086457f34e26bdb86760562fc7d4ac4605a52f0b3dce8048649c3e3098a392c7); /* line */ \n        coverage_0x645ceaf0(0x236380fb64b6491525df8f1f2406d8940c1a6a6315ae225011cfbff6bc01ce16); /* statement */ \ndata[groupIndex][index] = BroadcastedData({\n            secretKeyContribution: sc,\n            verificationVector: vv\n        });\n    }\n\n    function isBroadcasted(bytes32 groupIndex, uint nodeIndex) internal view returns (bool) {coverage_0x645ceaf0(0xfb3c66a70f7b9d95a89bfbb06f6eb56f97f0a3c7683d0c7d1853b7e88a0feaaa); /* function */ \n\ncoverage_0x645ceaf0(0x2abc5f3dad104fe9ed73a6b1b9391e3c193228ff853d65f666cf917d79258661); /* line */ \n        coverage_0x645ceaf0(0x604ec66ccec791536d007c081da6f330478f26064c8531400987df181220860d); /* statement */ \nuint index = findNode(groupIndex, nodeIndex);\ncoverage_0x645ceaf0(0x3de9964c5fb3cbdcc1f19e1afd6c642630b6b844f18b7610c587ba47d11fdfbd); /* line */ \n        coverage_0x645ceaf0(0xfb890ff38c614ad7d39c5a792c7d90c9ac00f619901f471c68a6b9e36a956d49); /* statement */ \nreturn channels[groupIndex].broadcasted[index];\n    }\n\n    function findNode(bytes32 groupIndex, uint nodeIndex) internal view returns (uint) {coverage_0x645ceaf0(0x9e0869d618dde668a087681213b9df9a5f17972cc6cd7c005f37a1e6f9121ba5); /* function */ \n\ncoverage_0x645ceaf0(0x9439c3110fdea480a8819a757db2cfb5201bc2194036e8606db1bd325109cded); /* line */ \n        coverage_0x645ceaf0(0xc8b15ab2d9276597d3b99427c3bc1fbcdd1f9f60fd34e9633a9bc77c7498f47b); /* statement */ \nuint[] memory nodesInGroup = IGroupsData(channels[groupIndex].dataAddress).getNodesInGroup(groupIndex);\ncoverage_0x645ceaf0(0x0150b21f5ee420bc8851a7f925f3b61470c1a56589a50b91b9e9368acc63c9cd); /* line */ \n        coverage_0x645ceaf0(0x21e85e87fb78ea15e7e5a7db02c194d15bddf6b1482a998176ac064dc81dfde6); /* statement */ \nuint correctIndex = nodesInGroup.length;\ncoverage_0x645ceaf0(0xf5aab728a245e724a01143ffe41602e8ddfa85ea198c923fbfe7eb76e15ca0a1); /* line */ \n        coverage_0x645ceaf0(0x7201912c565776c2f92ffc867f42ee50d3b518630c86d418bfa7ba992c22cd3b); /* statement */ \nbool set = false;\ncoverage_0x645ceaf0(0x7b9b2c6c05f5353bdeb5d32f0d68ab508b7cc790dcf05a83e17b30d388ceaef1); /* line */ \n        coverage_0x645ceaf0(0xe84a1d30d50cab6ffe2e76f9d2d2ebb83c9a5502903708f84e8bafa308e4e652); /* statement */ \nfor (uint index = 0; index < nodesInGroup.length; index++) {\ncoverage_0x645ceaf0(0x371d62cd6bac1debce8db3c99ef42c58609baa2e2abdc4fc2c5d54bfb8c5d02e); /* line */ \n            coverage_0x645ceaf0(0x5faa202affb6f827018d4652be93787815e0f87cd3945d4f6ec218bd599ced04); /* statement */ \nif (nodesInGroup[index] == nodeIndex && !set) {coverage_0x645ceaf0(0x596b97876939f8730377ff04a1e6bd1c2a7ed0b62e0445e7f20de09b09cf636c); /* branch */ \n\ncoverage_0x645ceaf0(0xbeb7948f14d1d4b295120b11809ae26372b70f206acba383aa6f55cc25cd6d91); /* line */ \n                coverage_0x645ceaf0(0xa3c4ecfd00383749dfc8f9cdee82a4c92e3d6243075fc474d77448210585fb00); /* statement */ \ncorrectIndex = index;\ncoverage_0x645ceaf0(0xb80a3f81b3c49eae296bd024e7ae646faa264f29e3bd89f9c98073cbab431166); /* line */ \n                coverage_0x645ceaf0(0x2c14e64b58d8db6b0ed7f68cad7722238a718161fd24fa4b8428d60accb27235); /* statement */ \nset = true;\n            }else { coverage_0x645ceaf0(0x6b6ee9482402a446188ac9593e763db6a85df9dc76789145d399f8fbd7b0593f); /* branch */ \n}\n        }\ncoverage_0x645ceaf0(0x9a8a3016b71ab58232ffd55c9add812183933e0b1a24604456327c4d20fdedcf); /* line */ \n        coverage_0x645ceaf0(0xa5347e30ef1011998fffa36c648133f9e282e9fb0c6d04d24cfaafafadd89113); /* statement */ \nreturn correctIndex;\n    }\n\n    function isNodeByMessageSender(uint nodeIndex, address from) internal view returns (bool) {coverage_0x645ceaf0(0xa0b5626e0572461f87f6500b2edf7336b30eee6b5b29a4979364d5a96b7e2c1b); /* function */ \n\ncoverage_0x645ceaf0(0x28a5f6accce6ffd3c21c9ff7b4d130772f871c3b486e4a54c85b4cb814cd006b); /* line */ \n        coverage_0x645ceaf0(0xfb665f9755c8b42b2d019dac15a274741fa3cc0fd176ad00c8b784be517da1cc); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x645ceaf0(0x759c5fea589f8b9e382b3ca46bb9d660eca77b74f74ccd045b7a7b6ea7651256); /* line */ \n        coverage_0x645ceaf0(0x35e5a929dacd835ad5007967b3b1e4b409ca7c4e451a85892dcc64a9b467131d); /* statement */ \nreturn INodesData(nodesDataAddress).isNodeExist(from, nodeIndex);\n    }\n\n    // Fp2 operations\n\n    function addFp2(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x9208d867432faad615719ea1e56e04de3e3bdccac02b6b1514f35eff70ba7f10); /* function */ \n\ncoverage_0x645ceaf0(0xa95d63d1a8124ef0de62a2cfb25e188d399cc5401b9f6f3fc249d3e7c10071df); /* line */ \n        coverage_0x645ceaf0(0x36d50c7b92c5196ea4d0638107d7549128ddd5df64af208733c04ee05978f0a7); /* statement */ \nreturn Fp2({ x: addmod(a.x, b.x, P), y: addmod(a.y, b.y, P) });\n    }\n\n    function scalarMulFp2(uint scalar, Fp2 memory a) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x877e97abbc2d6d8cd3e1f1390e231d39d70d4ab71291461f764508f7478d683f); /* function */ \n\ncoverage_0x645ceaf0(0xf5a0cc0407b1e544916bd93cdc1403b472feedc705ab9a10cea298bb0404cdb8); /* line */ \n        coverage_0x645ceaf0(0x9258549fbd6d56aa111080854ccc470feb3f7fe6189efe4bdde3e217c3389df2); /* statement */ \nreturn Fp2({ x: mulmod(scalar, a.x, P), y: mulmod(scalar, a.y, P) });\n    }\n\n    function minusFp2(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x4ad89662fd10bf9c17b181fcbdc92b10f720069a652a9d234e4f4e4bc3a58c68); /* function */ \n\ncoverage_0x645ceaf0(0x8ab5fa2a60f1a24c9eb6602c29605ee0c4682966b2eff01b5b58dfda055a83f2); /* line */ \n        coverage_0x645ceaf0(0xf03865be24d617d74925bf8f360217357f322099f2fc0780127f867441ee8563); /* statement */ \nuint first;\ncoverage_0x645ceaf0(0x0109d28032ca1c626b53fbeb15df9dfc273fdbc453e3e25bd6a10326f4ea4fd7); /* line */ \n        coverage_0x645ceaf0(0xfa2485da355ee4294a6b4439d53fc7038cb9e073b81616e013de6d81e0ea3e65); /* statement */ \nuint second;\ncoverage_0x645ceaf0(0xc0fdec4ac9deca0018dcbda65fc3379ff2fec69ef3d1b2fffe66e9c51a4d7595); /* line */ \n        coverage_0x645ceaf0(0x2335a47648d1a4814d33da1644e011e82906056b26f7c1acd1dc42a038c42313); /* statement */ \nif (a.x >= b.x) {coverage_0x645ceaf0(0xa20ee0ef33c2e9a034c6808b38903e70776360635a9468e942b19d3eab450551); /* branch */ \n\ncoverage_0x645ceaf0(0x8a990ea558e4b5bae7c18e18f177ffae82538b0e3b74f41fbcd7241b0f2577c6); /* line */ \n            coverage_0x645ceaf0(0xe4c3c54340bcc6f01f5cf5f69c2c69910b6e79584ca55fa15818c3d8cbf6422c); /* statement */ \nfirst = addmod(a.x, P - b.x, P);\n        } else {coverage_0x645ceaf0(0x75a6eefdb452249f672a8b14d33498f55b738457d842c23cc836c1ec467f9f55); /* branch */ \n\ncoverage_0x645ceaf0(0x1f396bda12a6ded6dab9c66e6ff3b1adb3e27d25488b9b3769aad3301f832ae0); /* line */ \n            coverage_0x645ceaf0(0xf1d6e74ff5891412a113925520e4bf5ef1c8dae0496c07120be204791edc7af6); /* statement */ \nfirst = P - addmod(b.x, P - a.x, P);\n        }\ncoverage_0x645ceaf0(0x626b2f2de9a577b307671e8c5c45c5f364bf29beaf140e13ed4fb20887b722b2); /* line */ \n        coverage_0x645ceaf0(0xce4c292ea3c727bae7e1d3d5e0043d3271cfff73eedd85039f823f4b3fd35b75); /* statement */ \nif (a.y >= b.y) {coverage_0x645ceaf0(0x620440013c6a854ff10a18b15960829c97cb335042b4a99b9054f3e1c953ec89); /* branch */ \n\ncoverage_0x645ceaf0(0xaef818f6172a6e9751bc1bc9320e7749f7e977dbfc5bd0b3ce1e51f0e71dfdef); /* line */ \n            coverage_0x645ceaf0(0x80ba709336ba7178728cf125ce876a06b10276e0b1a6df388ecc603f000c4212); /* statement */ \nsecond = addmod(a.y, P - b.y, P);\n        } else {coverage_0x645ceaf0(0x890d9758d7bdaf0d0a87e0860a711234d927dde26f3ba0051271e48a24b134d1); /* branch */ \n\ncoverage_0x645ceaf0(0xe637e876c38c571d1f61b0d8a3c62f91a0ca7a1232aee6a90da4292ccce9052d); /* line */ \n            coverage_0x645ceaf0(0x89bc85d04062d9638ff3d2fa0cf193d29308e2c1d6b2c7083c675f89fb751199); /* statement */ \nsecond = P - addmod(b.y, P - a.y, P);\n        }\ncoverage_0x645ceaf0(0xd3e8f117372f4c8ad22771bf95250016554272592c903bea636490de4f5016b7); /* line */ \n        coverage_0x645ceaf0(0xf3afd48060d334fecaa4cc1b535eafb9ef09b6db9192a1bb411af80baa2db42f); /* statement */ \nreturn Fp2({ x: first, y: second });\n    }\n\n    function mulFp2(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0xdd7bf0744346c7b961de7528353987a0de9691eccfc855c6536c7c339c10e619); /* function */ \n\ncoverage_0x645ceaf0(0x16e0cd300501dd426e2a57a8e3471f78630dee3418cb88e9c216e0e0084fa0b3); /* line */ \n        coverage_0x645ceaf0(0xed1e96f0b95622300c47cb47fb8649f492b06a4f5ff9081776d873df6ed5f4e9); /* statement */ \nuint aA = mulmod(a.x, b.x, P);\ncoverage_0x645ceaf0(0xab2d8b5bd3c2f1275d3ee1016b3d217ca97650ed8eebba6b969bcac733590ff7); /* line */ \n        coverage_0x645ceaf0(0x9320c5e7519a2e97a2d29101496cbb604fa374deb8b8b5ead197fdb7cc8908d1); /* statement */ \nuint bB = mulmod(a.y, b.y, P);\ncoverage_0x645ceaf0(0x2753df80eb807983a8c3e194aef4f23951ada1cc73e096e8e9fcb6d8316fc02d); /* line */ \n        coverage_0x645ceaf0(0xa47a22b1aba20081809598e521d7af24b6a85a30d150162a5e8fd56ff05aa529); /* statement */ \nreturn Fp2({\n            x: addmod(aA, mulmod(P - 1, bB, P), P),\n            y: addmod(mulmod(addmod(a.x, a.y, P), addmod(b.x, b.y, P), P), P - addmod(aA, bB, P), P)\n        });\n    }\n\n    function squaredFp2(Fp2 memory a) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x1d921f44161cba86daffc500c4f6d7dfa8509b46f3158e07609d3075c5737f4b); /* function */ \n\ncoverage_0x645ceaf0(0x2f0c6a4e2196f8d9ab937fb9fc95fcfde816b45af730c29228101a758bb0c85a); /* line */ \n        coverage_0x645ceaf0(0xee6bc98731e49ecd568c604b24d6ee723032ec79261355b69f86159c1adc46a1); /* statement */ \nuint ab = mulmod(a.x, a.y, P);\ncoverage_0x645ceaf0(0x3cf798506b66d651565f664471702a80216fbb0f3426b44e7d6c4e98e8518108); /* line */ \n        coverage_0x645ceaf0(0x8eed56ff9f0d6c53a4587c5ff0198abab29d7263bcab55d39fec6b921e567ea4); /* statement */ \nuint mult = mulmod(addmod(a.x, a.y, P), addmod(a.x, mulmod(P - 1, a.y, P), P), P);\ncoverage_0x645ceaf0(0x0a1b3223d81f0130ab512183bbe5e43294586ea850efb8fdad93b09983cd2f16); /* line */ \n        coverage_0x645ceaf0(0xacfcaf0c660248bb6c05e3026a7ef1f7687e85a2ebcccbc4830707a921e5b45a); /* statement */ \nreturn Fp2({ x: mult, y: addmod(ab, ab, P) });\n    }\n\n    function inverseFp2(Fp2 memory a) internal view returns (Fp2 memory x) {coverage_0x645ceaf0(0x699eaa5f228d58c4925ff4dc6b6c41f73ab481aece5ce07964aaa04ea8079d35); /* function */ \n\ncoverage_0x645ceaf0(0x659201115e66c7412d90756870165e712391a0f9de00e41180009ed85dd89616); /* line */ \n        coverage_0x645ceaf0(0xba0ad8deab75c956c6272ded5e56ac7ad790105c25a0c5e96a493450a91780b7); /* statement */ \nuint t0 = mulmod(a.x, a.x, P);\ncoverage_0x645ceaf0(0xa96f487c63fe487792997e5f16386fa497fad5eb2f7870094586360ae1457e22); /* line */ \n        coverage_0x645ceaf0(0xa76d9159065da23df71b6c9a7117fc39fdb06c92efeb7859afaf5f5319084539); /* statement */ \nuint t1 = mulmod(a.y, a.y, P);\ncoverage_0x645ceaf0(0xa74408030daf3f61503d16570e4af3ceb63459caf538c6a4aa701a4e239b6dab); /* line */ \n        coverage_0x645ceaf0(0x71a800ea47f3fcd5fed107baa4092ab60bd8ab2e9389e843c3fa0be480735c9f); /* statement */ \nuint t2 = mulmod(P - 1, t1, P);\ncoverage_0x645ceaf0(0x79602293c60d29ecc0f069ee1e3e6f489686ef51c145472e03006670d3a3277b); /* line */ \n        coverage_0x645ceaf0(0xd219855fe8bc9369a7498e3c2c1dc389e0feeb2ca3648b8fe27fc7df2d916784); /* statement */ \nif (t0 >= t2) {coverage_0x645ceaf0(0x22bb426e30eca41ef742a5bbdc55643bff2186d3494303cf53d62a3020f68519); /* branch */ \n\ncoverage_0x645ceaf0(0x34645963edc847b050c2fdda5df7cef852d674f180833d275f70da5abc10ead6); /* line */ \n            coverage_0x645ceaf0(0x9d13fcbbc28529dc013af0c147577dc00c7eef192d364212405247a1617f0afb); /* statement */ \nt2 = addmod(t0, P - t2, P);\n        } else {coverage_0x645ceaf0(0xa9601813f9dee58677dd449eaf64a72fdf82814b5cbbb3983633f3fc88d022ae); /* branch */ \n\ncoverage_0x645ceaf0(0x8b2356ee109ecc6127645510d0f66989f85ecc6aea515f5db2f886ef913e95c7); /* line */ \n            coverage_0x645ceaf0(0x46ba9cca98c7c21338039a1cc2837085c7a4433a171068b12fcf85dcceaf0de8); /* statement */ \nt2 = P - addmod(t2, P - t0, P);\n        }\ncoverage_0x645ceaf0(0x38b6520bb1aa33477f9fadc2025f0e7faf21a82ac24444db9dbdc60c73acaa52); /* line */ \n        coverage_0x645ceaf0(0x5444fe5071c138705cd7017f6abf9cf03eab7709e9b13960403b5012fe839901); /* statement */ \nuint t3 = bigModExp(t2, P - 2);\ncoverage_0x645ceaf0(0x5b244fc8fcae211d8e31afd8203196ceefb7a4135e5f3ad1a79124f96feb4a82); /* line */ \n        coverage_0x645ceaf0(0x6f1c4876cb4ef2cc8b7a9449e33fd6804b7b0425094c8a0e6232e81116fe970b); /* statement */ \nx.x = mulmod(a.x, t3, P);\ncoverage_0x645ceaf0(0x440e9435a1c9e7af4b6958612c81be5498a518564b863e1ab89a57d098c7aca9); /* line */ \n        coverage_0x645ceaf0(0xd45a689f3d0a0a7bf7daba130c212243982f9647a971e5926fd850e4ff75048f); /* statement */ \nx.y = P - mulmod(a.y, t3, P);\n    }\n\n    // End of Fp2 operations\n\n    function isG1(uint x, uint y) internal pure returns (bool) {coverage_0x645ceaf0(0xebb21f8fb4e000d3faa696e7f108eb5d8c3cdcab2ed9ba427a1daa12c57edf14); /* function */ \n\ncoverage_0x645ceaf0(0x9b1057a3bbb0ab15000b93a98ecc210ffda4aa02082888f3b19fdcf864022295); /* line */ \n        coverage_0x645ceaf0(0x890efdd2c68951cb88a1fca68593c9fe4c034cd5e8562b51e48bc11ad643216a); /* statement */ \nreturn mulmod(y, y, P) == addmod(mulmod(mulmod(x, x, P), x, P), 3, P);\n    }\n\n    function isG2(Fp2 memory x, Fp2 memory y) internal pure returns (bool) {coverage_0x645ceaf0(0xa6ef654fbf5775c6b065232cf706887e4ce1d4117b62ab430c78436c3e24999c); /* function */ \n\ncoverage_0x645ceaf0(0x54c0c601fb66a42959a326f2c4232e9a47552c1b9c2ccd0ba62e36cddf354a08); /* line */ \n        coverage_0x645ceaf0(0x4ca1e33245d738de8e99c5259ce85dcca2ebea21eda3c67150ee122438052da5); /* statement */ \nif (isG2Zero(x, y)) {coverage_0x645ceaf0(0x9d7246d15f942195dd2fa55af570ac025d4bca01b17fcd09a8b3e6dd53fac3cb); /* branch */ \n\ncoverage_0x645ceaf0(0x7f3b80bc22cd4bf62287d5fd71cda8f9f18ca8a88aac63684adc5f42cea73648); /* line */ \n            coverage_0x645ceaf0(0x9dbde3b386774690f02b27fc460a330a32ebf8623652bd2239c218305a098937); /* statement */ \nreturn true;\n        }else { coverage_0x645ceaf0(0xd6fd19f615b5a9dd8f3659bc4d65e768b935e99e64e6f7586787a93a58c4c65c); /* branch */ \n}\ncoverage_0x645ceaf0(0x0450570697705f42a50de0a9fc1855893236cad6f79fbd642f10f83e2d6cb5a0); /* line */ \n        coverage_0x645ceaf0(0x7d07871deb5c974ea1e33e79b9c206a8ecea82c691c6225d0aa54b78b8de483c); /* statement */ \nFp2 memory squaredY = squaredFp2(y);\ncoverage_0x645ceaf0(0xe76fb752c5c08e031c19d4a73ede947e7b35c64fa835b9f6984967f77d90fff1); /* line */ \n        coverage_0x645ceaf0(0x4b87d4b6a7c4fa25e9582f652cc41b619333c24e71743e7b3f7d6983e739a33a); /* statement */ \nFp2 memory res = minusFp2(minusFp2(squaredY, mulFp2(squaredFp2(x), x)), Fp2({x: TWISTBX, y: TWISTBY}));\ncoverage_0x645ceaf0(0x754b74e9dea5575a50c58bac827b9ed951e566063e0ae52942a6d4d2dbddf9c4); /* line */ \n        coverage_0x645ceaf0(0x071310f39d305deb2ee2e973231d757ea7287e0b91c4be41371552504188fd59); /* statement */ \nreturn res.x == 0 && res.y == 0;\n    }\n\n    function isG2Zero(Fp2 memory x, Fp2 memory y) internal pure returns (bool) {coverage_0x645ceaf0(0xd6146ad550b61af96af91e7e2d0910e1538300872ed4beeefc51756aec8b1d1e); /* function */ \n\ncoverage_0x645ceaf0(0xb17e33167f999fa2dd7143a9f4c1575b251b4e6c7d5165115ccc86a748fe274d); /* line */ \n        coverage_0x645ceaf0(0x8a08ec4e8f5a8aada6b4ad0325cf7391f9d044336213b989190907e3512408ac); /* statement */ \nreturn x.x == 0 && x.y == 0 && y.x == 1 && y.y == 0;\n    }\n\n    function doubleG2(Fp2 memory x1, Fp2 memory y1) internal view returns (Fp2 memory x3, Fp2 memory y3) {coverage_0x645ceaf0(0x6af7fbe6895c0f20eea8045af8de3eec16858f793a4580af26649c13b9bfe8b6); /* function */ \n\ncoverage_0x645ceaf0(0x6a7a497f938414b446f4a3c9cfb8a2afc29901c6220e5676bd03681edd16fc99); /* line */ \n        coverage_0x645ceaf0(0xb8c6b107567a54610c15dcc50db1247b4c32b187aabe9905b436644114054b22); /* statement */ \nif (isG2Zero(x1, y1)) {coverage_0x645ceaf0(0x82b741ab88b8ab27fc850055385a28cf1e6d9fe755e23af3a4ec7a3a6eb5b53c); /* branch */ \n\ncoverage_0x645ceaf0(0xd195b0f55a93b1e3edc62d9d2bec5e29817159544001ab22d2bd2de0c6bba2f0); /* line */ \n            coverage_0x645ceaf0(0xd7083fff42a6a4afd1425596c8638ab59d64f3e2426b5b496ae199394b373de2); /* statement */ \nx3 = x1;\ncoverage_0x645ceaf0(0x9171df77efe1ea6252112c12a69a9371b7869b0ec26403af8a993a7c13c0bef4); /* line */ \n            coverage_0x645ceaf0(0xee54915362110dba430c1008e00c22260537f5929033c92fcb864b535490dbec); /* statement */ \ny3 = y1;\n        } else {coverage_0x645ceaf0(0x6bf71db5eb1753f3864cbec57eb7519fdbf02de8f6b8635017f5754dd3019759); /* branch */ \n\ncoverage_0x645ceaf0(0xe917e3c7aa5c8ff01322486e403255ceb1d3822ca5cd2ddd3604812cea1cd935); /* line */ \n            coverage_0x645ceaf0(0x1d1cedacfd252ba2d638ab9b23692ad29a66b45deb54835aedd38e147daced40); /* statement */ \nFp2 memory s = mulFp2(scalarMulFp2(3, squaredFp2(x1)), inverseFp2(scalarMulFp2(2, y1)));\ncoverage_0x645ceaf0(0x6e7e69cc629bf6e475a1edd5ca441c0cda807e81ffdbc609baaaa4df075855c4); /* line */ \n            coverage_0x645ceaf0(0x108678d0eeff6c85aa7d67c42d1d67a6bf04af9cab451ac833b593efa4c57d82); /* statement */ \nx3 = minusFp2(squaredFp2(s), scalarMulFp2(2, x1));\ncoverage_0x645ceaf0(0x3f356d6f5e320ac5e91732f483ba012cc1b15c0e55f67b54d43637f613440604); /* line */ \n            coverage_0x645ceaf0(0x828a0c4a7294b6806a55494c8b3e7220801df38a3c063383dd530480040b8ead); /* statement */ \ny3 = addFp2(y1, mulFp2(s, minusFp2(x3, x1)));\ncoverage_0x645ceaf0(0xb7ce92a34926c4681e14f1308fefe1d1de8c89487d80b84124a381bf3a4f9cd2); /* line */ \n            coverage_0x645ceaf0(0xa43fecb80544ad54a56b8b8261b1efe4b0d11f8876e5cb25a69954c3bd24d7e3); /* statement */ \ny3.x = P - (y3.x % P);\ncoverage_0x645ceaf0(0x142b56fa9ccd262c9c144ca7d95335af91eb4b2ba54935736beaed8354bacbc6); /* line */ \n            coverage_0x645ceaf0(0x5ecd27293e0107e61a666bc0fcbb721343114c92e44abf55db36735fd2c875d4); /* statement */ \ny3.y = P - (y3.y % P);\n        }\n    }\n\n    function u1(Fp2 memory x1) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0xa5382154a8ff0b07c1ed7a1e24ba3e5563d536ed9c68532ee4612d3eeeff536a); /* function */ \n\ncoverage_0x645ceaf0(0xdba9814d2c32818b52f416706150ce3135673b7b085e7236e060196fe33d790b); /* line */ \n        coverage_0x645ceaf0(0x3d5464b53c283a329ba50a553d79b5204ad14f3607b160fdbfa89ea93f479ddb); /* statement */ \nreturn mulFp2(x1, squaredFp2(Fp2({ x: 1, y: 0 })));\n    }\n\n    function u2(Fp2 memory x2) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x8f332641b948f0797e9f181a3a471d10de8ac2485ec090ef6b38927e9e16e033); /* function */ \n\ncoverage_0x645ceaf0(0xc880c33fc089fd06b696ee5f0cc139b0a1f85f2740600c0d13fd56aafa8e70cf); /* line */ \n        coverage_0x645ceaf0(0x7b4668afb6751d83d7c6f2731946b3a478522d8c673b032cd1086c187ee447f7); /* statement */ \nreturn mulFp2(x2, squaredFp2(Fp2({ x: 1, y: 0 })));\n    }\n\n    function s1(Fp2 memory y1) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x4269d849f505375648899aa697852cf1dc44e851858b4fff70f21245b19f6ae4); /* function */ \n\ncoverage_0x645ceaf0(0x4a574d59849b0c61fa66a9c47710dc8d192052298cb4dd703a591c61314825c3); /* line */ \n        coverage_0x645ceaf0(0x9fa328545b2735243ffe14a6bc4fd0e95cfe89526edfc64ee6596bb05252a988); /* statement */ \nreturn mulFp2(y1, mulFp2(Fp2({ x: 1, y: 0 }), squaredFp2(Fp2({ x: 1, y: 0 }))));\n    }\n\n    function s2(Fp2 memory y2) internal pure returns (Fp2 memory) {coverage_0x645ceaf0(0x06fa88c23e2ac298b91f5375526d1b7f166c6ef1dca92423d6740324bd44b33c); /* function */ \n\ncoverage_0x645ceaf0(0x4352cb2e058c674dc969cd3e4e7d451f7ddb49af684f0bdb7cdb570ea6b76d99); /* line */ \n        coverage_0x645ceaf0(0x23ce9ef867e9cb097966a9f7b1a0caf06d57e730c132848b05a9aec0c3570e94); /* statement */ \nreturn mulFp2(y2, mulFp2(Fp2({ x: 1, y: 0 }), squaredFp2(Fp2({ x: 1, y: 0 }))));\n    }\n\n    function isEqual(\n        Fp2 memory u1Value,\n        Fp2 memory u2Value,\n        Fp2 memory s1Value,\n        Fp2 memory s2Value\n    )\n        internal\n        pure\n        returns (bool)\n    {coverage_0x645ceaf0(0x4e25bef3ab1010483723cc69d3892cc1c64e0ae2a9dd1b20d6f1171913d23bf7); /* function */ \n\ncoverage_0x645ceaf0(0x91af7348f28db359efb0e0174f9c1a53b21b9fba8ed419c4c7c85255306e73b2); /* line */ \n        coverage_0x645ceaf0(0x49ebe9ab979f775c266061b30a5cfec2f1fe53edaf85c6210c199894d19a053c); /* statement */ \nreturn (u1Value.x == u2Value.x && u1Value.y == u2Value.y && s1Value.x == s2Value.x && s1Value.y == s2Value.y);\n    }\n\n    function addG2(\n        Fp2 memory x1,\n        Fp2 memory y1,\n        Fp2 memory x2,\n        Fp2 memory y2\n    )\n        internal\n        view\n        returns (\n            Fp2 memory x3,\n            Fp2 memory y3\n        )\n    {coverage_0x645ceaf0(0xf06c0be975574c1e767cfb742da206cce9c92d144b01f91a05f672532eb55ded); /* function */ \n\ncoverage_0x645ceaf0(0x914bf811e61e2e82f7ec68ea051bc8d9092e356081795153d4ef12f411dd8e25); /* line */ \n        coverage_0x645ceaf0(0x62366088453bc891543cb75dec1fe9f8b34e054426e0a5f7b2893d8622761792); /* statement */ \nif (isG2Zero(x1, y1)) {coverage_0x645ceaf0(0x90f6a815fdbab1627020c914c3205ae74230172ac1a295a2ba31498a9d6dc875); /* branch */ \n\ncoverage_0x645ceaf0(0x3b91f0e29d3ced406ab02f26aa516659fe2486b69f2ed1fb0d521130cd5d852a); /* line */ \n            coverage_0x645ceaf0(0x3baa95376c8b53a7f4d387fcf120010b66aefe6e29d3948605a248ef7ea9554b); /* statement */ \nreturn (x2, y2);\n        }else { coverage_0x645ceaf0(0x428eae9f041c451d05fddbbd3dd9acc2f32e94efccdef4ae1fcda49f7886f229); /* branch */ \n}\ncoverage_0x645ceaf0(0x12e5532d00cb409d5419dc07a3a0a492e6b5d569fcf6b9c657462a62871c6e7e); /* line */ \n        coverage_0x645ceaf0(0x1ec50c990e5de3cb9b556da4ecc62989de575a6b0aaf9e06cc0c42517086b82a); /* statement */ \nif (isG2Zero(x2, y2)) {coverage_0x645ceaf0(0x686259a2f47bd158b324d4bf57ed4fe8cd94f8e3f70c94ab89d011d2d7465b74); /* branch */ \n\ncoverage_0x645ceaf0(0xae37fd5173929f11e8e38132a0cda5658d6fc8aefadc62d191df014df6ddcbaf); /* line */ \n            coverage_0x645ceaf0(0x086b5a89c228807235f4b50f8a806df41a8abd149aa6da1f39a25af0c3dd84c7); /* statement */ \nreturn (x1, y1);\n        }else { coverage_0x645ceaf0(0x2f62c041462ca86fac44fc27f8c9067d86650ea05450c5c4d13da1323dbeca17); /* branch */ \n}\ncoverage_0x645ceaf0(0xbcc9f4357ebc232e0b95773926c398434c9df7f8fe418aa8e04a463889a991a9); /* line */ \n        coverage_0x645ceaf0(0x4f9698a1320ff5f54d53a5b9b1c26ddd03a71f63306d8ad8f52dcf88ff76429d); /* statement */ \nif (\n            isEqual(\n                u1(x1),\n                u2(x2),\n                s1(y1),\n                s2(y2)\n            )\n        ) {coverage_0x645ceaf0(0x652aefa13a83d412b40ceebd2cc4da9ee858af67b333541631e1432b17b454ce); /* branch */ \n\ncoverage_0x645ceaf0(0x950b21294dc63778e8037c9dea0f99eb8f11b0c9de6309125cb6ef1ba4fec43d); /* line */ \n            coverage_0x645ceaf0(0x965ff59fbca869742ab8598925be01cdb865f74c4daf86c365f982f1edea4b5a); /* statement */ \n(x3, y3) = doubleG2(x1, y1);\n        }else { coverage_0x645ceaf0(0xcda666679d83af22cedc6d9209ff84719bb19bfaf22e287788aba4f44d02c599); /* branch */ \n}\n\ncoverage_0x645ceaf0(0x42344f22f1f4bc1908e565e6c0b7dc34698fee4e4a98dd5fbcfc79a13a3118ed); /* line */ \n        coverage_0x645ceaf0(0x83bde8533d29644c476a7cbefc9ca68abed0a3af2e17c5264d633f132acac82d); /* statement */ \nFp2 memory s = mulFp2(minusFp2(y2, y1), inverseFp2(minusFp2(x2, x1)));\ncoverage_0x645ceaf0(0xeaad9eee6613f994ba817aff9849a8d59ba9514d1ac0740b74d68c1e7a189213); /* line */ \n        coverage_0x645ceaf0(0x9a17811b57f6d4121a596af2def44eb3a3589936c5e62b88c3b73f8d32acadc5); /* statement */ \nx3 = minusFp2(squaredFp2(s), addFp2(x1, x2));\ncoverage_0x645ceaf0(0xfd46b55f6666ebe9bf67a83162932cbf8cc35dbdc97d9b21f5088b05f58f3f4d); /* line */ \n        coverage_0x645ceaf0(0xb350808b92df3172d55c4b9fd5f9bf04b706cea152c19c63ca72fa788879faac); /* statement */ \ny3 = addFp2(y1, mulFp2(s, minusFp2(x3, x1)));\ncoverage_0x645ceaf0(0xa5e6aa49f8ae82afb93a49f122dcc66b20928bc108d0fabd0d83f6d3e83168ca); /* line */ \n        coverage_0x645ceaf0(0x1123456c2ae8881449823210ed7d5043bd229580e1f7e1bad30198f0893b5f73); /* statement */ \ny3.x = P - (y3.x % P);\ncoverage_0x645ceaf0(0x15fc0f832d2f02c8a9b3dab625948a74afbfe5b7ed74a1dbbb8532244715fe02); /* line */ \n        coverage_0x645ceaf0(0x739807342c87182eeb046e30da5fa304c8b1864015cbebbe263d1aaba16ebc83); /* statement */ \ny3.y = P - (y3.y % P);\n    }\n\n    // function binstep(uint _a, uint _step) internal view returns (uint x) {\n    //     x = 1;\n    //     uint a = _a;\n    //     uint step = _step;\n    //     while (step > 0) {\n    //         if (step % 2 == 1) {\n    //             x = mulmod(x, a, P);\n    //         }\n    //         a = mulmod(a, a, P);\n    //         step /= 2;\n    //     }\n    // }\n\n    function mulG2(\n        uint scalar,\n        Fp2 memory x1,\n        Fp2 memory y1\n    )\n        internal\n        view\n        returns (Fp2 memory x, Fp2 memory y)\n    {coverage_0x645ceaf0(0x98f0e9336b99ace224eeda14d28c64c72f12436a4f86165714d098971e4c0fbd); /* function */ \n\ncoverage_0x645ceaf0(0x6e4ba3455ad68aba563857fb118699f80ac35692911071b98899599f9f6d2e15); /* line */ \n        coverage_0x645ceaf0(0x768ba7c73e438423ef9400891789572dd56889fea9900486778aa217a5d90277); /* statement */ \nuint step = scalar;\ncoverage_0x645ceaf0(0x78dbddd0c9e8960f0a2d8277209408531d8bbc3a893b098e2eb2815be0f3cccc); /* line */ \n        coverage_0x645ceaf0(0x4b871a01c5e9ed9a3dad80e3be9d10b7f6503abf3968c6cbb9571c38eac84b64); /* statement */ \nx = Fp2({x: 0, y: 0});\ncoverage_0x645ceaf0(0x5d903baf1ddf0122053b89ded84910204d83a70e772165c3526673f876f3017e); /* line */ \n        coverage_0x645ceaf0(0xdaa9d201dc8111977d7f8f2498fa1e89856c0bfa1b036019c81e636e3d55239d); /* statement */ \ny = Fp2({x: 1, y: 0});\ncoverage_0x645ceaf0(0x8c8e81334ae43ac58257434cf0e699ae21772f475e4bb204588469beb3c13760); /* line */ \n        coverage_0x645ceaf0(0xbf6b6493f899ff5e26db16536dfb08369acebbde8062e3f31820e3542a9511d0); /* statement */ \nFp2 memory tmpX = x1;\ncoverage_0x645ceaf0(0x6ecde3566b7d0da38cd7774de4f8755da9fea05fe2a770d943611775382c184b); /* line */ \n        coverage_0x645ceaf0(0x0d5693464328a0b78798cde75a18acb710bd494e3a525aba9dab7a038e586413); /* statement */ \nFp2 memory tmpY = y1;\ncoverage_0x645ceaf0(0xb83112a5e71dc874428c38b167fb56c4cdd8b9d88207b6c5b8ec644d2afb1f54); /* line */ \n        coverage_0x645ceaf0(0x2902b202bb905cca5a0272105ef42f3d1eac63b2e530eed1e34f10db0babae77); /* statement */ \nwhile (step > 0) {\ncoverage_0x645ceaf0(0x89cc940d2862d2431a915e45758253c81b7a5472287a1dbaa8b15ea4d79d8b65); /* line */ \n            coverage_0x645ceaf0(0xe133287ef4bc4b5ae8487905506c5356c0a1f2b404f9aa7fbe714cb90c11c444); /* statement */ \nif (step % 2 == 1) {coverage_0x645ceaf0(0xd29cae5478045f33aafa039aea3e552a841bc014e1ecebcd66c2ca9e30ceff86); /* branch */ \n\ncoverage_0x645ceaf0(0xfc75a4ebf5d218b098e28cb8a8a00ecd71bec8cddad926cbdec5a2cccc31cd0b); /* line */ \n                coverage_0x645ceaf0(0x131c4cdfdc8ee742d098c44d21841cd7244c2ce7d2da13098fe70dbf3adf1115); /* statement */ \n(x, y) = addG2(\n                    x,\n                    y,\n                    tmpX,\n                    tmpY\n                );\n            }else { coverage_0x645ceaf0(0x9d1960770ab90c606272a9589b6b8d90d3ace27204d4d61989c2f6f707ac810c); /* branch */ \n}\ncoverage_0x645ceaf0(0x52b56173da5a7c8d40f10931cb374d151437718d1f1bcbefce60502c18738c17); /* line */ \n            coverage_0x645ceaf0(0x0b65a122900430c0154e2e823103317abdeb42883e19d79491287356c214566f); /* statement */ \n(tmpX, tmpY) = doubleG2(tmpX, tmpY);\ncoverage_0x645ceaf0(0xa5fb9a5a4da59bf744e5ecde4641f8d3bf0cbacaf9e1cffe87266b8b8c9d6d76); /* line */ \n            coverage_0x645ceaf0(0xb85cdcac0fb462e53bcb045c27f2dae7f7f8e0d126cf2d50110d3276e65dcd46); /* statement */ \nstep >>= 1;\n        }\n    }\n\n    function bigModExp(uint base, uint power) internal view returns (uint) {coverage_0x645ceaf0(0x1f6daf657132454733918187ea573fd2dee9480326c51459042a748c0fecfba8); /* function */ \n\ncoverage_0x645ceaf0(0x517a4becdb88ecf969e760f88d59e8777f7db5dc4a3d4f624aad7b510e1543cc); /* line */ \n        coverage_0x645ceaf0(0x3277c5d18ac49fe56fcdb1e361c6f7feff98a5c9cd1cf53f5db97944c0599b9c); /* statement */ \nuint[6] memory inputToBigModExp;\ncoverage_0x645ceaf0(0x9ef6282ef812cbb3108814b18c241a538282ce548c87b164453218791c1543ae); /* line */ \n        coverage_0x645ceaf0(0xbdcbddf23dc8630589741810160325f39a7eed8054bfbfbdd7a2b3f98d60046b); /* statement */ \ninputToBigModExp[0] = 32;\ncoverage_0x645ceaf0(0x5557717da362c411d590fd3b1806af2615d9dcce34e5716aac41047b0eae1063); /* line */ \n        coverage_0x645ceaf0(0xdc0c6914f0fefe56c78011c404e76b5f6255317dbe2d368ce55395bc9e1c5989); /* statement */ \ninputToBigModExp[1] = 32;\ncoverage_0x645ceaf0(0xf4648b6693977c3a7b43539204e13091aa9c10d5373d895e157e60ec426118c5); /* line */ \n        coverage_0x645ceaf0(0x1df7da7d34d69da2feba849930ab627944c74579565e0b7159505e90fcaf47d9); /* statement */ \ninputToBigModExp[2] = 32;\ncoverage_0x645ceaf0(0x9c86dd5786e3586037081ca6170e0d028d5ed40ec61d0a659cbdaa8b264a8f6c); /* line */ \n        coverage_0x645ceaf0(0x665e3250089676ed7aca0f3b7c01dcfdfb4faa8648bcb7253c54eca0a466d55a); /* statement */ \ninputToBigModExp[3] = base;\ncoverage_0x645ceaf0(0xc61a8c4e7c044789992d0c83309c8631659b53426c6683a57fecdf90f53ac60e); /* line */ \n        coverage_0x645ceaf0(0xa8f8b9cb0ccf5e10112b813297f32b20922d9c14c3c8e1666642bc38eb07c67c); /* statement */ \ninputToBigModExp[4] = power;\ncoverage_0x645ceaf0(0x516953cc106aec1db5f9701d166e3115aa6fbfe794fd6a40586a8f8396badd33); /* line */ \n        coverage_0x645ceaf0(0x096c0ff529f56e6f0161bc0341f061b1f19f999642c3d21699f9b3a38a0f5ef3); /* statement */ \ninputToBigModExp[5] = P;\ncoverage_0x645ceaf0(0x677e0efb291b3abf6b74b2a07be404a0858dc1dc6e59c23706a27588db0832cb); /* line */ \n        coverage_0x645ceaf0(0x9a69d3fb17bd308a53a88bdf60fff160a0d536843ac36b67c4b09e9b4063d3e1); /* statement */ \nuint[1] memory out;\ncoverage_0x645ceaf0(0x36c328fa2405e8d2bfced794964a198dfd90bfbbedafb07ca29dbd1f0ab7005c); /* line */ \n        coverage_0x645ceaf0(0x7f7c70b7561bc1fc0f09a2d805db547ae05f2c6d9e071312574d6ffc60dcb066); /* statement */ \nbool success;\ncoverage_0x645ceaf0(0x7aa5e2170ae286627e2d38fe29b9e6d81f6345f28c95d3ef6d1f2d4f81df7683); /* line */ \n        assembly {\n            success := staticcall(not(0), 5, inputToBigModExp, mul(6, 0x20), out, 0x20)\n        }\ncoverage_0x645ceaf0(0x0723c9151370f3917a397069794a833c1455833fb53fd320a0df90e149994717); /* line */ \n        coverage_0x645ceaf0(0x28141ad070bdb2372a6d3dcb76f72e56733cbda2b9c6fc1ab619fb40100ae858); /* assertPre */ \ncoverage_0x645ceaf0(0x7e9772b5883e05594ade5601080151e924992e021fb0720516a0396e3ec8f8ec); /* statement */ \nrequire(success, \"BigModExp failed\");coverage_0x645ceaf0(0x05e2a4304eca425b0ca6c6fccbb24d28243b85daab03698a89c24e50d16c70a3); /* assertPost */ \n\ncoverage_0x645ceaf0(0xefc663b66f5a7354f25664a38f63cc5c12d48508c91ced3ca52467145f54b9bf); /* line */ \n        coverage_0x645ceaf0(0xd8f89c2aef06e8d4ecb3285ba2b0eea1dafe7f24b052bca081083d7a0b4b7651); /* statement */ \nreturn out[0];\n    }\n\n    function loop(uint index, bytes memory verificationVector, uint loopIndex) internal view returns (Fp2 memory, Fp2 memory) {coverage_0x645ceaf0(0xf71ad90e215f031f4e1c55b530a0a7d1105800639d7d049ccdf8dde050d3679b); /* function */ \n\ncoverage_0x645ceaf0(0x4fd2b0ba85c861a5526160e0130b9df1fdc8a1aade7a405ca45bed0e5d8f8e38); /* line */ \n        coverage_0x645ceaf0(0x6f93edc8f040d5621fb8d829a12f6113d95b60ff02a6e08dcad5654de88ebcb4); /* statement */ \nbytes32[4] memory vector;\ncoverage_0x645ceaf0(0xf080dbe48f68a5f0a1080b860a108b909bbf5edbf13bc9292c3d54bc96c89d1c); /* line */ \n        coverage_0x645ceaf0(0x5df762c402697bbbc2543a44276376ebc64f4b0a443560933dfd099b27a2568e); /* statement */ \nbytes32 vector1;\ncoverage_0x645ceaf0(0xd0540b08e0fff4f5314e133b27d0ae62af450ac6a6c730911b32e53ad9c9f12e); /* line */ \n        assembly {\n            vector1 := mload(add(verificationVector, add(32, mul(loopIndex, 128))))\n        }\ncoverage_0x645ceaf0(0x03b60a33d2e6b9f58bd0d62649361b764fc72397dadfc41ea0bae43bbc40f034); /* line */ \n        coverage_0x645ceaf0(0x3f5846a35e733e4f13594d7869b39d0b6d62bb3fd77da125acc45b07eddcc06e); /* statement */ \nvector[0] = vector1;\ncoverage_0x645ceaf0(0x9878d60a61f9a51e94422596f9aa9362d454a63db022d9a873241525e4b0e2c1); /* line */ \n        assembly {\n            vector1 := mload(add(verificationVector, add(64, mul(loopIndex, 128))))\n        }\ncoverage_0x645ceaf0(0x9a9ce32f80307f9fad0cc2e8024aaebc31da560ac718b9d1c2fe2bb0215f9b2b); /* line */ \n        coverage_0x645ceaf0(0x9962aa9df5f259d2fbc9b3ad113cece1bff5b185098f62fe2a6f914c88af5f71); /* statement */ \nvector[1] = vector1;\ncoverage_0x645ceaf0(0xb60d19f7a2b52b5cc2229f8fc86498df0ac75a534d50d371edfe2483b90b91bf); /* line */ \n        assembly {\n            vector1 := mload(add(verificationVector, add(96, mul(loopIndex, 128))))\n        }\ncoverage_0x645ceaf0(0x65486da06a6efff2c360059e50a1ee2c511fee3087bd328d6e27ed6dc36fd1aa); /* line */ \n        coverage_0x645ceaf0(0x3243c60f9e694b3307f91aad5c555ea939bf0bc1f0bd20ab0115daad9a66b74a); /* statement */ \nvector[2] = vector1;\ncoverage_0x645ceaf0(0x3c997d4443a1b8981d5c857d01e3f8185dcd0079f41a8a10ab7378771fd51f0e); /* line */ \n        assembly {\n            vector1 := mload(add(verificationVector, add(128, mul(loopIndex, 128))))\n        }\ncoverage_0x645ceaf0(0xa320bf98c8c72c82939188b80bcab7908cd34958bc95f3891c5368c60a0cb19a); /* line */ \n        coverage_0x645ceaf0(0x9387fb364509d05011d72fbdca8e20289ca40b7ee0214e4e918580657f98e45b); /* statement */ \nvector[3] = vector1;\ncoverage_0x645ceaf0(0x8415d3f7f7cfc981d95383071a91a225cc0ddf99d188741d969493fa47daea87); /* line */ \n        coverage_0x645ceaf0(0x73f9aa788ca3b5de7b1a5f6d7d67fa0af1d09f835ecc089c0ed66d8d3cfad4c7); /* statement */ \nreturn mulG2(\n            bigModExp(index + 1, loopIndex),\n            Fp2({x: uint(vector[1]), y: uint(vector[0])}),\n            Fp2({x: uint(vector[3]), y: uint(vector[2])})\n        );\n    }\n\n    function checkDKGVerification(Fp2 memory valX, Fp2 memory valY, bytes memory multipliedShare) internal pure returns (bool) {coverage_0x645ceaf0(0x5ec20d1232a3cff3e0f65be7f07ed80a97bf55c8a857f89d9ff7f9d83b736216); /* function */ \n\ncoverage_0x645ceaf0(0x13daa41543ae541d0f93b9b29b40cd08ade8d09e1597774e4f42450b16bfd5c0); /* line */ \n        coverage_0x645ceaf0(0xd4d34cad1963249a282a816b90c493f898b896452830bc386b3de933aef36dd6); /* statement */ \nFp2 memory tmpX;\ncoverage_0x645ceaf0(0x7371909d5841a486b46fb5aa9454fb4117c6c4b3d8904a0f4e7babf00c3980a1); /* line */ \n        coverage_0x645ceaf0(0xf6fbd13f4535b561d6c4e1cd38888ece0521aec8bb7ab3a8a1f7134f60a29124); /* statement */ \nFp2 memory tmpY;\ncoverage_0x645ceaf0(0x7ca76c99a34242bcccd9e637bba5c14506d7827418d53108deef80c63781899e); /* line */ \n        coverage_0x645ceaf0(0x0811e701ce11c0444861b7f76a622f0f8a659a28124337ccdeff436355809956); /* statement */ \n(tmpX, tmpY) = bytesToG2(multipliedShare);\ncoverage_0x645ceaf0(0xa99d34b45bed6f8a6254359058b123df087c43bc6d79ce2869325cf919a44a3f); /* line */ \n        coverage_0x645ceaf0(0x370023e015227d62701270117ac319fb0fb28188e3ba646cc629f8d349aed357); /* statement */ \nreturn valX.x == tmpX.y && valX.y == tmpX.x && valY.x == tmpY.y && valY.y == tmpY.x;\n    }\n\n    // function getMulShare(uint secret) public view returns (uint, uint, uint) {\n    //     uint[3] memory inputToMul;\n    //     uint[2] memory mulShare;\n    //     inputToMul[0] = G1A;\n    //     inputToMul[1] = G1B;\n    //     inputToMul[2] = secret;\n    //     bool success;\n    //     assembly {\n    //         success := staticcall(not(0), 7, inputToMul, 0x60, mulShare, 0x40)\n    //     }\n    //     require(success, \"Multiplication failed\");\n    //     uint correct;\n    //     if (!(mulShare[0] == 0 && mulShare[1] == 0)) {\n    //         correct = P - (mulShare[1] % P);\n    //     }\n    //     return (mulShare[0], mulShare[1], correct);\n    // }\n\n    function checkCorrectMultipliedShare(bytes memory multipliedShare, uint secret) internal view returns (bool) {coverage_0x645ceaf0(0x064fd7980792c7e17e5850e1d1d5b080c515f717df23f684a96524e2361fdb7f); /* function */ \n\ncoverage_0x645ceaf0(0x7db02d227ad005c4e8c664ac276ca88975b2a47177da45564cc5fbfa0b5c81b6); /* line */ \n        coverage_0x645ceaf0(0xf0139afac38cbc2b6f5a0fa53ee0a37d4a3ba4080e8e82bff762b38f8dd22e79); /* statement */ \nFp2 memory tmpX;\ncoverage_0x645ceaf0(0xfc784a3ed36525c1982ff7dd45c41b6b2b7e263d886080b1d8a42598972fe5e5); /* line */ \n        coverage_0x645ceaf0(0x068a171f53f9c424e5ea3e649e56e4f4ada88cf5a2261a7184de81b98496f25d); /* statement */ \nFp2 memory tmpY;\ncoverage_0x645ceaf0(0xd7ce0debb6f99b5f7e90be3ca5d25e645017cfb6e0409c1d5c521a5c69b1557f); /* line */ \n        coverage_0x645ceaf0(0x5570597501f66fbd054aa5c92fbcbc571de32a2f035edfce9803f5a396eee3d6); /* statement */ \n(tmpX, tmpY) = bytesToG2(multipliedShare);\ncoverage_0x645ceaf0(0x795d1b6ffe13031ca860ef2e393ba93286079f29cd3ff60040f469bbeb0a4e56); /* line */ \n        coverage_0x645ceaf0(0x42cfe0171203c5045fa9a99c5bc9934e3d3dea79c3e4f7f98162de8b26780234); /* statement */ \nuint[3] memory inputToMul;\ncoverage_0x645ceaf0(0xfe2765377bf5fada2c2aedf57ffec28bfbdcbacbd7d5a8f7beed0df8075495e4); /* line */ \n        coverage_0x645ceaf0(0xf2d9e5f26ab1b42f512d1960e42f95bf23bdc719cb345c0cdffaee696459c3cf); /* statement */ \nuint[2] memory mulShare;\ncoverage_0x645ceaf0(0xf0ce37a923699fffbe14303fd562ed1e7574cd878ff591bb94aab6f6495238f1); /* line */ \n        coverage_0x645ceaf0(0x5671fed921ef6065f1c71605bf18af16fb59448c9af40fa5201e4596380edb80); /* statement */ \ninputToMul[0] = G1A;\ncoverage_0x645ceaf0(0x9f70d8f2a64d808c25e290083fe957fa29e07a8c59ea049cc3760c801f715421); /* line */ \n        coverage_0x645ceaf0(0x57349ef298f64cebaec71f908baf87871af672b69bdc17bf9475d6ef0cfc176d); /* statement */ \ninputToMul[1] = G1B;\ncoverage_0x645ceaf0(0xf2bea0cc61cc4dea5e99e3cb431faa22303c2fe21cbc8c3be0c401d9313ec9fb); /* line */ \n        coverage_0x645ceaf0(0xcf12dee6aa968f67a82a41864eec4b3bddf4be20f02d9bd44c0f1bcc5c8940f2); /* statement */ \ninputToMul[2] = secret;\ncoverage_0x645ceaf0(0x116d1382233e35db3fd27f89cf5f19ef3df64b3cf040bff183844df13b290a9c); /* line */ \n        coverage_0x645ceaf0(0xc11edb7da5ab4ae0fd36eedeec1d6b3fd0ab30384fcebff8156696be7ec55207); /* statement */ \nbool success;\ncoverage_0x645ceaf0(0xfa11f31916446d4720a222826eabcd61a11ac7b0e9f79abf4b3ac38718a8a594); /* line */ \n        assembly {\n            success := staticcall(not(0), 7, inputToMul, 0x60, mulShare, 0x40)\n        }\ncoverage_0x645ceaf0(0x9c90cde09c50954a4abc78f662753f88b19d6754baed84a3cd798685ac8c1cee); /* line */ \n        coverage_0x645ceaf0(0x2a74aaf25bf9522281d65ec088a73bbff765e3b94856fd08d517e20df68cd091); /* assertPre */ \ncoverage_0x645ceaf0(0x80cc7a78508db83fc6f68bda465dbe910950ff102f44d7c23f2393998e0dc193); /* statement */ \nrequire(success, \"Multiplication failed\");coverage_0x645ceaf0(0xc8abceb3482443001167927af63d4be113d338d302e05a7e30f7d740476a1fdd); /* assertPost */ \n\ncoverage_0x645ceaf0(0xe5f29aa0a94c09bf9af3f1723b532e12fa70ff69cc87a8b1199bc22ae901a308); /* line */ \n        coverage_0x645ceaf0(0xb3bef8e471d5698a3f946501da6b681c32ce8f892b13f16fd993e03a246f7a58); /* statement */ \nif (!(mulShare[0] == 0 && mulShare[1] == 0)) {coverage_0x645ceaf0(0xfa9b425c573d8ab06f472dd2a63614c237b82c21bba65ae8b8207a54dc18d099); /* branch */ \n\ncoverage_0x645ceaf0(0x12534e4a329775b3b9c2246adb5ad214eeee865deeff1cd1044238d0c0ce4028); /* line */ \n            coverage_0x645ceaf0(0xdecf1db4b574dd48bd2b7deb46da45f6ca8afaaea0c5a39af132c734899a9e65); /* statement */ \nmulShare[1] = P - (mulShare[1] % P);\n        }else { coverage_0x645ceaf0(0x08dd1b1133b8cf63f7d36551a3e6dff98c26bd817a104bd7847877509303ecba); /* branch */ \n}\n\ncoverage_0x645ceaf0(0x27efc5281e33d26af67b811165b26fb7230e4afbb6939bdecc0aa6373b99d2c8); /* line */ \n        coverage_0x645ceaf0(0x48b31f7b2e3dc3c871c53d73aa46d3b706455a643a4bcc34bc0aac7196afb262); /* assertPre */ \ncoverage_0x645ceaf0(0xed6f4dde39b4565140fc89a4c06190c0a0b8afcf705106cc3a171bc07a9defd3); /* statement */ \nrequire(isG1(G1A, G1B), \"G1.one not in G1\");coverage_0x645ceaf0(0x669d78c00f89242f13eee9909867656cd4e41dd245e52cb5517b889907090079); /* assertPost */ \n\ncoverage_0x645ceaf0(0x21c4987976e779fb0dc83037f64979d6239bcee3a43b6ef2e8e50307c473b553); /* line */ \n        coverage_0x645ceaf0(0x1b485d5f8f412c044302d1f7e376e2ecc3e85ca13bdf54173d9ef65cecd4289c); /* assertPre */ \ncoverage_0x645ceaf0(0xde1e5c0f681cc4f5237b4b83975b0fc139959e0bfd908cf18ab419cba93e794a); /* statement */ \nrequire(isG1(mulShare[0], mulShare[1]), \"mulShare not in G1\");coverage_0x645ceaf0(0x654d2e7e480df014c858f6dcbbbde70ac23ce70a7308a8021c4cc170ccca02b0); /* assertPost */ \n\n\ncoverage_0x645ceaf0(0x7bd99ff2e619aaf362048e634390b5bbc3fe44dea3ac90e1aa4f79a89810014c); /* line */ \n        coverage_0x645ceaf0(0x1e20d00e3cd11d00fa3d54f463c6e0f89496e9b6fc7930bf48e91107eef8606b); /* assertPre */ \ncoverage_0x645ceaf0(0x5a9ca79a5bc3f4482a88ff3172eb6dd8eead6389b95ae5e1e0d061aa233e2cbe); /* statement */ \nrequire(isG2(Fp2({x: G2A, y: G2B}), Fp2({x: G2C, y: G2D})), \"G2.one not in G2\");coverage_0x645ceaf0(0xab3782028a4faa9aeca634f638624218134368a9d35b82e8ac7d2af2bc65f3fc); /* assertPost */ \n\ncoverage_0x645ceaf0(0xdeb61ccfd5baea1e117fe490f200164d7bcb5b9aa96f6fa62e07751de54f90bb); /* line */ \n        coverage_0x645ceaf0(0x134d26a9cc2097efc9fb0966f1577da0b4bfe376838398037b4ee6e3854889a0); /* assertPre */ \ncoverage_0x645ceaf0(0xb83a41ecf4bd6f702c6ce98e739fbf0b6ed25f9f27981da1101117ba44ef3a3e); /* statement */ \nrequire(isG2(tmpX, tmpY), \"tmp not in G2\");coverage_0x645ceaf0(0x119bb5998156bfb3356858f23a7d48f9c20b9641f38efaae9cd25f595eb108ad); /* assertPost */ \n\n\ncoverage_0x645ceaf0(0xc37762a23f092407a49eaa4a848c6603113575e4be3c07286df5bb915c67d1dc); /* line */ \n        coverage_0x645ceaf0(0x5d9c733fe3cb345922cead6a9ef78528c1f2db850ae6f9c533d582c73c9ccc45); /* statement */ \nuint[12] memory inputToPairing;\ncoverage_0x645ceaf0(0x0da441f7fa948a820de7bb5a63652aa8ad2f78d52103d856b401933974f9dabc); /* line */ \n        coverage_0x645ceaf0(0x0f3f97909383050b111c75df563d3e75f2546aef805fbbd91974b85dd11de662); /* statement */ \ninputToPairing[0] = mulShare[0];\ncoverage_0x645ceaf0(0x716b7028a083f769634a0d54e2a936ca7db4c32b8748fccdb8fef5d850096044); /* line */ \n        coverage_0x645ceaf0(0xf9437a36931d007d39a42b7cf24f1c63c8f1e511035393937b7c303011c3c451); /* statement */ \ninputToPairing[1] = mulShare[1];\ncoverage_0x645ceaf0(0x4e09cbae8a471f76d73647cc45b32cabf58cda767994ba813e803df1cd60c9d6); /* line */ \n        coverage_0x645ceaf0(0x39b3ea8691a3f22e59d1bc8e8193a0776771a885325efdf0ecb96375a6a7b5ad); /* statement */ \ninputToPairing[2] = G2B;\ncoverage_0x645ceaf0(0x456757a6c6fcf712aeaaa7290c1acbfb039756a02e861ff0becaf644c8e58b10); /* line */ \n        coverage_0x645ceaf0(0xb57c18bac58a23b65b7604ab8c97112d6408358dabc7f2e29d221c88266c0063); /* statement */ \ninputToPairing[3] = G2A;\ncoverage_0x645ceaf0(0xbe39fa2a9eaf4b62734e3b8d8b2a3e968a212bb606a2f80e041f72542775ea98); /* line */ \n        coverage_0x645ceaf0(0x2d9fc5e3e3d631e1ce8ee3531906cb179faf2b151e589103ec2e3dc82a2c5840); /* statement */ \ninputToPairing[4] = G2D;\ncoverage_0x645ceaf0(0x73b80e0e451af716789c0e69b5b457b60ab7319bddedff3da33ec5e3fa6ca549); /* line */ \n        coverage_0x645ceaf0(0xa0084ce869fdae30ed0fc3fd19bc7d7489f08d20764678fe7fb455f95ebc781b); /* statement */ \ninputToPairing[5] = G2C;\ncoverage_0x645ceaf0(0x9f66f2cedd2d4c2bc7b64d742683fb73ec9140de6f1543a06b2551d9c1c79b60); /* line */ \n        coverage_0x645ceaf0(0x4108347690259f39fe8d4fae0f9b550355b22702e7635d03be78b50d6c1528dd); /* statement */ \ninputToPairing[6] = G1A;\ncoverage_0x645ceaf0(0x5384452656828598119a69492dd3aa386bc222231f800d73f398c281e244e3cf); /* line */ \n        coverage_0x645ceaf0(0x26f470865da81a0c58bd7b926133b19cc14b5734fa51db5fd2ea0ff068d6fcdf); /* statement */ \ninputToPairing[7] = G1B;\ncoverage_0x645ceaf0(0x068110ee640730963e6e478eed04ca896c81a9905562f1bad0a56034b2f2e2cd); /* line */ \n        coverage_0x645ceaf0(0x9eb72c1149e4b262b30bb27b6625a484d01410a1639e0a63418b25e2e54da1ee); /* statement */ \ninputToPairing[8] = tmpX.y;\ncoverage_0x645ceaf0(0xadb8ccbb9b82ef31314adbf864aec002b01020293b1bb17d49341c341427a16e); /* line */ \n        coverage_0x645ceaf0(0xdbf3a72bd0b81a07b95931243ea1a22ef861c0c39e967b667811db073b7ef50b); /* statement */ \ninputToPairing[9] = tmpX.x;\ncoverage_0x645ceaf0(0x7d0f9482533be8d2d6eceae28dd0c626638785889a059f8eaa91b4e98d1e22e8); /* line */ \n        coverage_0x645ceaf0(0x12f43db3ba07613ded530dab3190c5727de4a7ce6dac45e023318ee86869df35); /* statement */ \ninputToPairing[10] = tmpY.y;\ncoverage_0x645ceaf0(0x2f679eb18669b78e389e6da09aeab73e60e6227dc143a9e509b1b070f30082e4); /* line */ \n        coverage_0x645ceaf0(0x35ab6350537f5b1a490861fb98d59208b3d2293673ad0f9bc4bbdd8db4ac4b3d); /* statement */ \ninputToPairing[11] = tmpY.x;\ncoverage_0x645ceaf0(0x27f09cc4853558db10749f70d1409295073ccc6669ce2caea2e0c0a95e4df678); /* line */ \n        coverage_0x645ceaf0(0x4354c6ea3770a9bd67000be4b1e151a9eb4ba39989a18d3b40772402b9ce9f3e); /* statement */ \nuint[1] memory out;\ncoverage_0x645ceaf0(0x15036f2cd543445c66fd70e68c3b4359508ee788397b3d17ac96ec9f5ce3860d); /* line */ \n        assembly {\n            success := staticcall(not(0), 8, inputToPairing, mul(12, 0x20), out, 0x20)\n        }\ncoverage_0x645ceaf0(0xbb7faa5bb8f706bdf8dc11cc898e0db81315461baa3356ef9fe75692d18f5991); /* line */ \n        coverage_0x645ceaf0(0x809d7dec17e7d7f7ee9e9d632afc0c7c3113639b0f11e76316f90ee51a81e0ae); /* assertPre */ \ncoverage_0x645ceaf0(0x17c4781ccc0e8bf50e6401c78f9bed5aa10fa190c6169b3a010e1f93c1a06682); /* statement */ \nrequire(success, \"Pairing check failed\");coverage_0x645ceaf0(0x454d43ea241eb5ce51d27f27d1259ed81c7925afa7d8735df08ef51f623c2b74); /* assertPost */ \n\ncoverage_0x645ceaf0(0x06bce11d35e342ed913cd450533fdbc066d69eebae8fc8b7ebc0d28a846b9ac6); /* line */ \n        coverage_0x645ceaf0(0x0b4579f72fd8c328fc41fad542bf13bf516c94c59ab699c9e154a118fbb4c01d); /* statement */ \nreturn out[0] != 0;\n    }\n\n    function bytesToPublicKey(bytes memory someBytes) internal pure returns(uint x, uint y) {coverage_0x645ceaf0(0x1894829098f465f9dafd8f4ce169ee65acb72bd6f6e52504bd4928223d8c911b); /* function */ \n\ncoverage_0x645ceaf0(0x25594f485b77499546c164881bc9e393d6fe6e5bc008c691c1ebbaad5c17703c); /* line */ \n        coverage_0x645ceaf0(0x3fa950aa23b94e96f0c1d2ee96e1180a627772f0138070447c7a8b162e60d9f5); /* statement */ \nbytes32 pkX;\ncoverage_0x645ceaf0(0x890af7542d79651c5b0e582d4694d135e4f3a87459b8e1f55a70b69e9c4470a9); /* line */ \n        coverage_0x645ceaf0(0x6f3258d93a28e558fd93eee4385134db13a9e65446aa2938a642d1f43ac49d0c); /* statement */ \nbytes32 pkY;\ncoverage_0x645ceaf0(0x1666502116b71bf7970fd6cc7774029250574f50c3c6961e34e678376a0866d6); /* line */ \n        assembly {\n            pkX := mload(add(someBytes, 32))\n            pkY := mload(add(someBytes, 64))\n        }\n\ncoverage_0x645ceaf0(0x21ecf1984db293918f8f42f4ee69c0e5ec7d16333910a7a4e5a5441881da535d); /* line */ \n        coverage_0x645ceaf0(0x87d9a85cdadcb2e83d55e71c542522cd8019f0b746bcb3770c5259dc4fc42efc); /* statement */ \nx = uint(pkX);\ncoverage_0x645ceaf0(0xd49e470fd3519d1a8c6a52e443e59d3166c258f3867e48780d82ba44a52afc78); /* line */ \n        coverage_0x645ceaf0(0x16b52b0f1589033b9df8abfe86aa5fd4b0516b401088b1ddc7860b11908fca05); /* statement */ \ny = uint(pkY);\n    }\n\n    function bytesToG2(bytes memory someBytes) internal pure returns(Fp2 memory x, Fp2 memory y) {coverage_0x645ceaf0(0x7017cf32b4acb37648b3794e6fb4a7bbaab593e87df8a3e7abe28d376a02d1dc); /* function */ \n\ncoverage_0x645ceaf0(0x08c49155edd2d870af4d5432f1fd286636727a581940027c4f3b601cd80a908c); /* line */ \n        coverage_0x645ceaf0(0x45d222ba32c66047678184442cfdd8e1743af3e0c51eb0d798c0b25627ccc31a); /* statement */ \nbytes32 xa;\ncoverage_0x645ceaf0(0xaab1991807d0730348bb11fe7a749523a4ece5d8dfcffd2299c52021342055a5); /* line */ \n        coverage_0x645ceaf0(0xdedb24831d9fc21a54e922d9853fbada929cea5c6ae37dca8efe3ae394783a5f); /* statement */ \nbytes32 xb;\ncoverage_0x645ceaf0(0x91af717392f76baeba955f10b487bfe19447b2cff29e286affc7b63eaa586706); /* line */ \n        coverage_0x645ceaf0(0xcc803bc58139fe0470122938d08601156196db2c396dbbad2d8450b42f3a8075); /* statement */ \nbytes32 ya;\ncoverage_0x645ceaf0(0xefeeb949c34bfd67c1ab1eb169ff79501e1c6ecb4c04e4e2fb0c634594b3ef28); /* line */ \n        coverage_0x645ceaf0(0x1ccb13099e8b652b7847ea950e49faacbfb6396db4901fa7e59b6d2e97b5cde7); /* statement */ \nbytes32 yb;\ncoverage_0x645ceaf0(0x5d85329ddd75e459de0c0d0de5c0e3316aea396804afdbf430ef9d9d80dd0f45); /* line */ \n        assembly {\n            xa := mload(add(someBytes, 32))\n            xb := mload(add(someBytes, 64))\n            ya := mload(add(someBytes, 96))\n            yb := mload(add(someBytes, 128))\n        }\n\ncoverage_0x645ceaf0(0x9b2915a90c89a837b603d282ed707fcff4867251dde18e6299dfa14d8eef076c); /* line */ \n        coverage_0x645ceaf0(0x3eef435dc2cca2118f44321857d48da7ca8eb9e3eeb37279f333a01f3bd367c5); /* statement */ \nx = Fp2({x: uint(xa), y: uint(xb)});\ncoverage_0x645ceaf0(0xbe25f8578f73bb47bf80a1899d504dcd1aa53af142f500a26591427e16d54ea1); /* line */ \n        coverage_0x645ceaf0(0xbb0e68d7ebb3b6f9ed4965f26ec771247c45b246660ea4a07915f22d3e518091); /* statement */ \ny = Fp2({x: uint(ya), y: uint(yb)});\n    }\n}"
    },
    ".coverage_contracts/SkaleManager.sol": {
      "content": "/*\n    SkaleManager.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/INodesData.sol\";\nimport \"./interfaces/IConstants.sol\";\nimport \"./interfaces/ISkaleToken.sol\";\nimport \"./interfaces/INodesFunctionality.sol\";\nimport \"./interfaces/IValidatorsFunctionality.sol\";\nimport \"./interfaces/ISchainsFunctionality.sol\";\nimport \"./interfaces/IManagerData.sol\";\nimport \"./ValidatorsFunctionality.sol\";\nimport \"./NodesFunctionality.sol\";\nimport \"./NodesData.sol\";\nimport \"./SchainsFunctionality.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\n\n\ncontract SkaleManager is IERC777Recipient, Permissions {\nfunction coverage_0x49c6355c(bytes32 c__0x49c6355c) public pure {}\n\n    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    enum TransactionOperation {CreateNode, CreateSchain}\n\n    event BountyGot(\n        uint indexed nodeIndex,\n        address owner,\n        uint32 averageDowntime,\n        uint32 averageLatency,\n        uint bounty,\n        uint32 time,\n        uint gasSpend\n    );\n\n    constructor(address newContractsAddress) Permissions(newContractsAddress) public {coverage_0x49c6355c(0x28d7df800499915974f1a120baa5d845ff1d9a6ab1d7a8b86d6e0a2dba329f84); /* function */ \n\ncoverage_0x49c6355c(0x9048cc566547b3c4245e8d92b690595f9c3ab4b7799c7f9f19f216b191db9616); /* line */ \n        coverage_0x49c6355c(0x2499df1a003a426bf5be5071f1d2d5b7118929b6e65ca885ec57375d9aaa8777); /* statement */ \n_erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )\n        external\n        allow(\"SkaleToken\")\n    {coverage_0x49c6355c(0x34c05c2e2afb2c3ccec8f6ab87440a5cd40c05402770e44bfe52150f679e8718); /* function */ \n\ncoverage_0x49c6355c(0xfe6ac4020ff259926ef4124e1cdcef27d7b1ce2e63e16168a85098230d4d68f1); /* line */ \n        coverage_0x49c6355c(0x535375ac99f20c24703492765f2f6592b080cac60ad96b66da44acf8ecf68faa); /* statement */ \nTransactionOperation operationType = fallbackOperationTypeConvert(userData);\ncoverage_0x49c6355c(0x22920f3d26880fbbfd8064de3ed959afbf477a82d4f6c221668d6a731db2e153); /* line */ \n        coverage_0x49c6355c(0xcd1faba79d8ec88166e2ac430caa81eefadb570853db3846901ae566f6abe721); /* statement */ \nif (operationType == TransactionOperation.CreateNode) {coverage_0x49c6355c(0x5a2e117cfd7500f8aa9c3ba25d1d093f58058231807d92d8004af0dc081a665d); /* branch */ \n\ncoverage_0x49c6355c(0x64d67aa6cabff34cc34d8db3e984ad8ec0a58fce0a5502950470058c9b95a77a); /* line */ \n            coverage_0x49c6355c(0x45da303bd311182ed4c39e2b369320000a94a822124dcd9776d829e0a1212d98); /* statement */ \naddress nodesFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesFunctionality\")));\ncoverage_0x49c6355c(0x6fe6029eb42f1e00747d45cc01ba2f5867d8105ba9cac76589d85350598c50a2); /* line */ \n            coverage_0x49c6355c(0x30ac260e76c9755e7025b75a2ff4f54e1d2694ec743678ab303df894d3c645d7); /* statement */ \naddress validatorsFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"ValidatorsFunctionality\")));\ncoverage_0x49c6355c(0x5ce3358767ef7cff84d0273a3b6e0bcdaf4218c81a3fbfc06520704b4135c115); /* line */ \n            coverage_0x49c6355c(0xf122f7ea3800b93ab095102e05db4f01450f6581ca8b5c440b0485e9f2c4d406); /* statement */ \nuint nodeIndex = INodesFunctionality(nodesFunctionalityAddress).createNode(from, value, userData);\ncoverage_0x49c6355c(0x438f992e77231d0c0449e2c6bcc1180267e43cd725e4de83825ff9e98172c7c3); /* line */ \n            coverage_0x49c6355c(0x713023e36d3a1c14e677f141359b51d4125eeb856f5b6c68b05e85e90e66e7cd); /* statement */ \nIValidatorsFunctionality(validatorsFunctionalityAddress).addValidator(nodeIndex);\n        } else {coverage_0x49c6355c(0x19049b18f8c250c41e03e2de1abb8f5ed316474119c75c6ac731641b3187bb49); /* statement */ \ncoverage_0x49c6355c(0xda462fa2eb9b2e566983d7fe690b924e8c298a70da1e6475820316c2c6aa8673); /* branch */ \nif (operationType == TransactionOperation.CreateSchain) {coverage_0x49c6355c(0xb0e8f0fa33a71a291c78093730adb4cb68b2393f6037f01dbc92d5185e538a9d); /* branch */ \n\ncoverage_0x49c6355c(0x4dded7587601e3ed75461c7227bc6a4a86a65b595df6d03a90df3e08afb27830); /* line */ \n            coverage_0x49c6355c(0x26c2f47cc1824eab2171f71afc385453e9d0041e89a0a174836e1d0c165e8da6); /* statement */ \naddress schainsFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionality\")));\ncoverage_0x49c6355c(0x118ded1f7105b8915740c5100f2256e4c1e48be3840411d2c432e7fdafebb068); /* line */ \n            coverage_0x49c6355c(0x376e88b89e9dd7f1edd665ba5d5788ec8b0064aa86beeee359322fa75f46bd9b); /* statement */ \nISchainsFunctionality(schainsFunctionalityAddress).addSchain(from, value, userData);\n        }else { coverage_0x49c6355c(0xe054a9e13024d184a768d94217d5d521f0677899d409cf364692aed6d06a5a34); /* branch */ \n}}\n    }\n\n    function nodeExit(uint nodeIndex) external {coverage_0x49c6355c(0x6312bdd2d9596fd1a10b4fa1533a19daf0dca15adfeb931f2f24e2b47c72e7fc); /* function */ \n\ncoverage_0x49c6355c(0xe694d32fe35a5597a264b00bc9d2af94e275dc3229c37affa0eab574ce93b2f8); /* line */ \n        coverage_0x49c6355c(0x720f96920b7af2fca4aa1c78f47095cf1162fd2d2726aa21fdc0ea9b3c94adf5); /* statement */ \nNodesData nodesData = NodesData(contractManager.getContract(\"NodesData\"));\ncoverage_0x49c6355c(0x49491d5e4f65318a794a9d2fa5715fe6583cf5800db671a1aa8f34ac26ad1b2a); /* line */ \n        coverage_0x49c6355c(0x10140e5ed129024ae435b079789d908c686430fc822ed78e4cf5186b10d8f1e0); /* statement */ \nNodesFunctionality nodesFunctionality = NodesFunctionality(contractManager.getContract(\"NodesFunctionality\"));\ncoverage_0x49c6355c(0xc17e54ea223d9e437029c175c93786b4405f49ac52882b239013f40b8129474d); /* line */ \n        coverage_0x49c6355c(0xbc66508cbd21e6fb5d7fc49006ec272bd11efbff0f1fcf4631d7ff59eb4ed78f); /* statement */ \nSchainsFunctionality schainsFunctionality = SchainsFunctionality(contractManager.getContract(\"SchainsFunctionality\"));\ncoverage_0x49c6355c(0xa3951510d206662ef77a0e8965288ebb6bab36fce4ff7ca55adaad96520e8056); /* line */ \n        coverage_0x49c6355c(0x73fa211773a033f3674e28e8dffe7f6f8b4507b29e27f36ea5ab213a13f068ab); /* statement */ \nSchainsData schainsData = SchainsData(contractManager.getContract(\"SchainsData\"));\ncoverage_0x49c6355c(0xd67ff7b730e99960c24bf6c4fe929680f1c3c07d912f8e11a562aa54eb6b3eb1); /* line */ \n        coverage_0x49c6355c(0x88caac20f68abda17f61d2ec723b709967441549328af66642369a89148d1cdc); /* statement */ \nschainsFunctionality.freezeSchains(nodeIndex);\ncoverage_0x49c6355c(0xc91f1f64a3ed45bc98211e81d6c868edddfc4dfa52dd2599ee5a3e6d344df700); /* line */ \n        coverage_0x49c6355c(0x2664b5184c071f081f7f700659dbfe61d6396c36cccb895e51bf32218d440cd1); /* statement */ \nif (nodesData.isNodeActive(nodeIndex)) {coverage_0x49c6355c(0x366ae3591d6385280b264b01f248eaf22bd966304580807bb0963c1419b73d82); /* branch */ \n\ncoverage_0x49c6355c(0x2a68e3d2f9fe127a7d128dedd4e8e577ae163237aa3f7ff8084166aeecd2a43a); /* line */ \n            coverage_0x49c6355c(0xaee612852718512932e515fb2cd9da6bc6cc09b752fa50e20cc0bbd92c9156da); /* assertPre */ \ncoverage_0x49c6355c(0x3910414285512ebbaa20fe435cab6f044372ed04714e0d409e81eb6e6b91a9b8); /* statement */ \nrequire(nodesFunctionality.initExit(msg.sender, nodeIndex), \"Initialization of node exit is failed\");coverage_0x49c6355c(0x7fc689f04ae896f34bbf7f97b21df57e367388798a772d0ad12e208c1cac15a8); /* assertPost */ \n\n        }else { coverage_0x49c6355c(0x4652c96323b5338fdc465a30797672863bfc9fbef052f6176458b69eed16343a); /* branch */ \n}\ncoverage_0x49c6355c(0x81f291df052749b378b41c4a7e4574ce8876b4715bdadc8e11a691e990a39b91); /* line */ \n        coverage_0x49c6355c(0x661c17bc1ab6aafe9579e20462a0595d86ff641c49b2aa1e9f464854ecf874df); /* statement */ \nbool completed;\ncoverage_0x49c6355c(0x67f86e68c221ae5222966cfe699aad6a57246d9ea094ee3c9dddd67efca4528c); /* line */ \n        coverage_0x49c6355c(0x4db43b28748188db1a1730de3272271c819b02b1faa5311346fe06a2b0c59e5a); /* statement */ \nif (schainsData.getActiveSchain(nodeIndex) != bytes32(0)) {coverage_0x49c6355c(0x0b58d9ca9d74a3c0e87ee2a72cbecfa037cf93e7f425983c916037283c2c060b); /* branch */ \n\ncoverage_0x49c6355c(0xe1680f31ffa678476de9040041186e823e748c086ac18c0f340793dbb3562fe0); /* line */ \n            coverage_0x49c6355c(0x76230b54e87f5d6a1afcda51ec0269ae245cf09adccc392061e6bbdca26b03e9); /* statement */ \ncompleted = schainsFunctionality.exitFromSchain(nodeIndex);\n        } else {coverage_0x49c6355c(0x910559b0f463ff8e47cb307d38bfe90fbd0f73ce71248c6a363ceb75ee269325); /* branch */ \n\ncoverage_0x49c6355c(0xa12218a532baae0a062091e24237b9d536ad75155d1fb0401523c7d39b3c9b41); /* line */ \n            coverage_0x49c6355c(0x8396fb73e5df6d074bc00677e2965c724f348475feef3feb7bbc3d8c9c80d013); /* statement */ \ncompleted = true;\n        }\ncoverage_0x49c6355c(0x9cfcf37a33d95cda6e57834a88317046067450d43aaf4cd7225a346bef8d23fc); /* line */ \n        coverage_0x49c6355c(0xcac38f28784f73888e1b038f135de995c45d3b9e10ced3cc15ae285bf0eb4c5d); /* statement */ \nif (completed) {coverage_0x49c6355c(0x5bbd36c0eb696125ebb9e8ffd603c593f11a255f86eb149cf4e97fbe2a93ce1d); /* branch */ \n\ncoverage_0x49c6355c(0xeaee82812597188641677d3f6e2e1d27803ded5e886f47c25ddf072e724c8875); /* line */ \n            coverage_0x49c6355c(0xf46f27a63461c8d54dc267ea9e8bb6576ef746f2925295445aa2504e542928b1); /* assertPre */ \ncoverage_0x49c6355c(0xc60b6a80dcc987bb8d243e8c0e3c848c960c8aca0210f2f98dbdd34f1d66fd02); /* statement */ \nrequire(nodesFunctionality.completeExit(msg.sender, nodeIndex), \"Finishing of node exit is failed\");coverage_0x49c6355c(0xc43f01d4446fe79c37b8420d49b770710e1cde13e06e694eee1688eaa6c84d31); /* assertPost */ \n\n        }else { coverage_0x49c6355c(0x5e89ae1fbefcf11036ce811e10d64c4fb3fca05dcbd4b87c69c782bb7b72d3a7); /* branch */ \n}\n    }\n\n    function deleteNode(uint nodeIndex) external {coverage_0x49c6355c(0xc3c63188b29f6b7aeb3b22c8cdce0178dca559a05b6efa99e6acb8b918b3626d); /* function */ \n\ncoverage_0x49c6355c(0x8867df4e78839720e943f6ba7abb7616d7596a54a4dc41a7e26e02d3a2613cc9); /* line */ \n        coverage_0x49c6355c(0xe9028a40de9db2451d7ebaa14ce898f2574cf3979dfb7e53dfede7cc570f09e9); /* statement */ \naddress nodesFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesFunctionality\")));\ncoverage_0x49c6355c(0xd4816c236a874ba4124814515e631fcc27889b93da10fd975d040e7c64d814f2); /* line */ \n        coverage_0x49c6355c(0xcea458ddc0358759121b028cb546d1db27d1896124d43d103a7dcd6363eea2ba); /* statement */ \nINodesFunctionality(nodesFunctionalityAddress).removeNode(msg.sender, nodeIndex);\ncoverage_0x49c6355c(0x69a686953eba4c3267decccd43025574702537bd21f764ae09d293452ac498f3); /* line */ \n        coverage_0x49c6355c(0x31df127ef2158e72720000213390ba7b5437a78c5cae1860441b52b25136f3f9); /* statement */ \naddress validatorsFunctionalityAddress = contractManager\n            .contracts(keccak256(abi.encodePacked(\"ValidatorsFunctionality\")));\ncoverage_0x49c6355c(0x5845e719eb33d63e7e8b06af5cf1246de9f0b08f7f4f886e4783bc5b53465d94); /* line */ \n        coverage_0x49c6355c(0x1bbd33d695eb3b3d3d52e73b0380aa3b392faa524544ac2af794dda743899c6e); /* statement */ \nIValidatorsFunctionality(validatorsFunctionalityAddress).deleteValidatorByRoot(nodeIndex);\n    }\n\n    function deleteNodeByRoot(uint nodeIndex) external onlyOwner {coverage_0x49c6355c(0xba0b1568834e0fc63e5aa89e259553bdfa7821e92b930d7a71ef15a9a54fc9f3); /* function */ \n\ncoverage_0x49c6355c(0x344c743954f1dde7f3965a988dd28228d51f3df6a889dff719dad90db61d6315); /* line */ \n        coverage_0x49c6355c(0x338e331227b4bf14c31c7b3998d4d6fcbd34db62d06f4649263968a10734b10d); /* statement */ \naddress nodesFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesFunctionality\")));\ncoverage_0x49c6355c(0x8a4038fe9a26f4d0ed9170f57c15392d8bf02e09fd0583b6f79c0434f071f632); /* line */ \n        coverage_0x49c6355c(0x2da56a0df171c97ec451c9e8f528496f21f0edf570931f38d58d82385428a066); /* statement */ \nINodesFunctionality(nodesFunctionalityAddress).removeNodeByRoot(nodeIndex);\ncoverage_0x49c6355c(0x0dd8d4efb5bf379cbb51b3c2e31d88a5135e20428d474aac352483f7e61ec290); /* line */ \n        coverage_0x49c6355c(0xd2b77447297b45966bced01513c19b34c74eb7652063305270f35b36587fda97); /* statement */ \naddress validatorsFunctionalityAddress = contractManager\n            .contracts(keccak256(abi.encodePacked(\"ValidatorsFunctionality\")));\ncoverage_0x49c6355c(0x0f98e87241bad831085134a2e3fb9505256dfb1fd764622b8374393bf9b78204); /* line */ \n        coverage_0x49c6355c(0x04b4ab8904ff791feb535eab240e3b5b6f41d26f15f428d8e345c0811f630991); /* statement */ \nIValidatorsFunctionality(validatorsFunctionalityAddress).deleteValidatorByRoot(nodeIndex);\n    }\n\n    function deleteSchain(string calldata name) external {coverage_0x49c6355c(0x3b67199c66339e9011c86158d7f58461fd4aae5abdd8247d5b2ebf68b4b80aca); /* function */ \n\ncoverage_0x49c6355c(0x5ecf7ee8a555792ff370a380aef31a28e11d38c23064ff87d81199fba34395be); /* line */ \n        coverage_0x49c6355c(0x02f9c8dc76361a8dbde11eacf164fda891aeafb719428a25261df759ae4cf6af); /* statement */ \naddress schainsFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionality\")));\ncoverage_0x49c6355c(0x8bb581d18033e3be029a2f5d3c4b21b155cd2d2588e1724baa72b46c1dc3dfae); /* line */ \n        coverage_0x49c6355c(0x66b024826290f8d704019c7a2b8ed342ed4c67eef48bb31d5ebfb101382d9685); /* statement */ \nISchainsFunctionality(schainsFunctionalityAddress).deleteSchain(msg.sender, name);\n    }\n\n    function deleteSchainByRoot(string calldata name) external {coverage_0x49c6355c(0x4ee85d5c44dfe6fce6c3582ab6b10e3c0c5e568a0e3bbeed610c20966656177e); /* function */ \n\ncoverage_0x49c6355c(0xc4e6d56ba95f1dddc2416aeef523bc776db3b5056b34462b748f833d78533e09); /* line */ \n        coverage_0x49c6355c(0x979bffaf8fc57a92ffb2f500b182b4b91bd99caa5b4c61d746d80d35a0d4bde9); /* statement */ \naddress schainsFunctionalityAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsFunctionality\")));\ncoverage_0x49c6355c(0x65b740858649b38b499a364fe9e99af19d02718a61191eb44e7c86a068d218fe); /* line */ \n        coverage_0x49c6355c(0x426e5332f90174d233a5a5dac08c222499767c93c068fdcf161f90b8cbe3a7af); /* statement */ \nISchainsFunctionality(schainsFunctionalityAddress).deleteSchainByRoot(name);\n    }\n\n    function sendVerdict(\n        uint fromValidatorIndex,\n        uint toNodeIndex,\n        uint32 downtime,\n        uint32 latency) external\n    {coverage_0x49c6355c(0x155b6a8f97ae88da3bd76baaca7f85a49e6c9db82a63fc55a1c6b95f24a80e8a); /* function */ \n\ncoverage_0x49c6355c(0x081613da3e6efd9550d4269f0e1b08a96e121448b110944aa15585074179c037); /* line */ \n        coverage_0x49c6355c(0xeeb62ce193cb0a38fa67e2589be93579050713e7008969e32f3fd45dcf05a9ab); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x49c6355c(0x5fc7a6c2c5027dc472d63039fd438887c81daa3ee9a0f9b16cfd4a1d9a756bb0); /* line */ \n        coverage_0x49c6355c(0xa49271469286b8740b7b9e812c2063f982012a8169e20f8476ff61c29c18fc83); /* assertPre */ \ncoverage_0x49c6355c(0x669add77acf1d0d7c5be52917763329384229167672455fe15c041bff4f84d37); /* statement */ \nrequire(INodesData(nodesDataAddress).isNodeExist(msg.sender, fromValidatorIndex), \"Node does not exist for Message sender\");coverage_0x49c6355c(0x5b113b1832a38e14dada703c158192429c9e257dfa4700648663669d590284d9); /* assertPost */ \n\ncoverage_0x49c6355c(0x834e18d3d61ea223aecb4cd75f767ed610efdc1206e6566629e2af421b5acf91); /* line */ \n        coverage_0x49c6355c(0xa6d4cbfe7b49200e4ced4eb5f3894bcb896a7d641a043371c6a9a173f0288ffd); /* statement */ \naddress validatorsFunctionalityAddress = contractManager\n            .contracts(keccak256(abi.encodePacked(\"ValidatorsFunctionality\")));\ncoverage_0x49c6355c(0xbda33ec7e929d009492223ab62ae8000936f825002b6dcbcc9a248f5846d7d0c); /* line */ \n        coverage_0x49c6355c(0x92d9dcdadcae3ffff5e628453901f5b475442077388c1041181a7a06a7346be7); /* statement */ \nIValidatorsFunctionality(validatorsFunctionalityAddress).sendVerdict(\n            fromValidatorIndex,\n            toNodeIndex,\n            downtime,\n            latency);\n    }\n\n    function sendVerdicts(\n        uint fromValidatorIndex,\n        uint[] calldata toNodeIndexes,\n        uint32[] calldata downtimes,\n        uint32[] calldata latencies) external\n    {coverage_0x49c6355c(0x2200a1930ad5d585a375f560dc3ff701a123cd0584861ed55857bcc7a1cac78c); /* function */ \n\ncoverage_0x49c6355c(0xb2f25f14fa80129dd6c08d4334668316c85a77b740936245134af8f35b13a913); /* line */ \n        coverage_0x49c6355c(0xc70e5acb88e926eb086e534e1cb096e1d772a628e7ede0a83090fab432fcbd0d); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x49c6355c(0x7ccf5ed8ed488673e310c32df7291093a47a6bad91cd7199676a89eefa9f7cf9); /* line */ \n        coverage_0x49c6355c(0x15889faa45af1d532ceeeaacf59b1a134df0b741768a7bce4e548bae76decd98); /* assertPre */ \ncoverage_0x49c6355c(0xdcdbd3d7cf34684d19b35498067368fb1ae9c911def08cca27df531cc3486841); /* statement */ \nrequire(INodesData(nodesDataAddress).isNodeExist(msg.sender, fromValidatorIndex), \"Node does not exist for Message sender\");coverage_0x49c6355c(0x9bbb0f2d6343ae7371b6bc0f92e1a48e32eefb7ce6317c03dc6431849b552b25); /* assertPost */ \n\ncoverage_0x49c6355c(0x814418480f7a6b27d8427c2d22584e8038c66513f3a72dcc96e30494c721fccc); /* line */ \n        coverage_0x49c6355c(0xaaafaa74f696a2b2f29c936d557f8ac2b1233ca5af83aaeff14f35ecf4d5addb); /* assertPre */ \ncoverage_0x49c6355c(0x872cf5d665ddc27a3a128a8dc82bd8625319a22e9e2f91ed2ce07220df8796d9); /* statement */ \nrequire(toNodeIndexes.length == downtimes.length, \"Incorrect data\");coverage_0x49c6355c(0x80f9406f4351feb4f5eefeb1da0b9b7a12797c67edc8b4e2285bab25da1176d7); /* assertPost */ \n\ncoverage_0x49c6355c(0x77b8b0011d3ff8fdb22f3f7c7c44328c3168b71d6cf8d3bfb5604edf371205d9); /* line */ \n        coverage_0x49c6355c(0xb2cc60bcf5a9909e1f0b2f511ab9515bc7ffa32b74e4d7adbbf4ba997441ca65); /* assertPre */ \ncoverage_0x49c6355c(0x3f76b6ac4ab0e78d65464ce7f93e21e4dec0a07f837191fa9caa1560c20ada39); /* statement */ \nrequire(latencies.length == downtimes.length, \"Incorrect data\");coverage_0x49c6355c(0x2163bd7f5fa8d5e5bc5e0b63cd08e3e07d67767d6e84b3e592e542c6634863e3); /* assertPost */ \n\ncoverage_0x49c6355c(0x5e95997c28983d05c555ae829958a62affba396fde242d71f69d20a8b26567d2); /* line */ \n        coverage_0x49c6355c(0xac3eebc6f8379914c29199c3eb08a31b0929c1b61de055b12552c6ab140b3491); /* statement */ \naddress validatorsFunctionalityAddress = contractManager\n            .contracts(keccak256(abi.encodePacked(\"ValidatorsFunctionality\")));\ncoverage_0x49c6355c(0x179acf411b9057caec99e0dc6affa3702888cf246afd63de5fac51e3e4e8454e); /* line */ \n        coverage_0x49c6355c(0x609d90888442f6dd3f88477cae5e48763b783944abcd1876624773d54e20fd5a); /* statement */ \nfor (uint i = 0; i < toNodeIndexes.length; i++) {\ncoverage_0x49c6355c(0xbcf57b8b2f290b2409f2fa456416ec9e28083697d0febcfd5aed1c4a528eb18f); /* line */ \n            coverage_0x49c6355c(0xbb4163dbdbc8224b3f7f975814c559bc6a0cb106f7706fd7e7dd4c0bd54168c6); /* statement */ \nIValidatorsFunctionality(validatorsFunctionalityAddress).sendVerdict(\n                fromValidatorIndex,\n                toNodeIndexes[i],\n                downtimes[i],\n                latencies[i]);\n        }\n    }\n\n    function getBounty(uint nodeIndex) external {coverage_0x49c6355c(0x4a31fee7a0df3fe8e26fcfca89cde1eec1b72e5995d00d9702aa2b73daeee3cf); /* function */ \n\ncoverage_0x49c6355c(0xb4121158b8dfd9be5be0f38664f466ba44ae6c39146876b484705d7bb100bde3); /* line */ \n        coverage_0x49c6355c(0x79a02159bad0ad12eca1d74cf1b65cb6d954d1c504ca6ba74b89069f49063154); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0x49c6355c(0x41e91e56fe7b75ce71bf97cab2fcf6cf5f01d036730ff13959651c3f44f377be); /* line */ \n        coverage_0x49c6355c(0x1e1bcff3cf37206973352d06d8d9847a00995b91741acca2c5c6727a38ff608c); /* assertPre */ \ncoverage_0x49c6355c(0xe68935bf432a3d91ae61b61b289b23a9e4bc13298304b1abb06fe6f86ab50fb6); /* statement */ \nrequire(INodesData(nodesDataAddress).isNodeExist(msg.sender, nodeIndex), \"Node does not exist for Message sender\");coverage_0x49c6355c(0x347a32abcdbf2d029cb2a3261206767f14f90e4d8b36b450080aff6e9a8408f5); /* assertPost */ \n\ncoverage_0x49c6355c(0x45183520e4f4208803bf7128a8abfb30bef1eb89d64d93e66f2441615ca83c8a); /* line */ \n        coverage_0x49c6355c(0x7d1dc0993a96c45d09f1932003935341b0fe4e6518ddaf7e2e9ab3c76543aa22); /* assertPre */ \ncoverage_0x49c6355c(0x17700ac572a07dbd6febaf7849ecace5c6583ed3c91a9e0f419b097354b11f57); /* statement */ \nrequire(INodesData(nodesDataAddress).isTimeForReward(nodeIndex), \"Not time for bounty\");coverage_0x49c6355c(0xa76e94ab6c2373f94520d7ed962c6a540822ac4d8eb38f4231af221c225bb6d4); /* assertPost */ \n\ncoverage_0x49c6355c(0x9de14bf76fcb4a522acbfcca0a66b152e60919482ccc6d6faee81e01302352ac); /* line */ \n        coverage_0x49c6355c(0x357ff6174ff9117d0e9e14ef98c2d4d723036a7ac3bac1603f880e9d6a959418); /* statement */ \nbool nodeIsActive = INodesData(nodesDataAddress).isNodeActive(nodeIndex);\ncoverage_0x49c6355c(0x15e790baebbb2da75c0a75d9364fef85bc2dc2086ce70d96b4921a4e752048ac); /* line */ \n        coverage_0x49c6355c(0xcfae773833e1bb8fee2dc0b194a89c87542031cb1913425fbe48e6ba035264b1); /* statement */ \nbool nodeIsLeaving = INodesData(nodesDataAddress).isNodeLeaving(nodeIndex);\ncoverage_0x49c6355c(0x0c78e2d943889db3e31d0e8bc4bbc68abbf3ace86a88bebdb8f3a8bbf3442aeb); /* line */ \n        coverage_0x49c6355c(0x0595a98b28d13f3b293c168c2cbae177f9eac6b71b31c801822f923e61405882); /* assertPre */ \ncoverage_0x49c6355c(0xfe33cedd39fe910c56f03dc024ad7758a4cdbf5a2454a5dd7d00a4db52328404); /* statement */ \nrequire(nodeIsActive || nodeIsLeaving, \"Node is not Active and is not Leaving\");coverage_0x49c6355c(0xfcd800b442c79d1912cb6d8d07722b27e758e6252e993b1435ab349a77165e8e); /* assertPost */ \n\ncoverage_0x49c6355c(0x034dca2e3774c2215030be320d7bc072830b55b827ff767f2e3c493f90a70f49); /* line */ \n        coverage_0x49c6355c(0x4431faf1c64a688f1bc497a26666db437267dd6a102f1f3f0c47cb6e5f0e4ecd); /* statement */ \nuint32 averageDowntime;\ncoverage_0x49c6355c(0xf69cde63ffa20820f749712f2d06c5ba806c514a473fc1e9b1924a477cc6490d); /* line */ \n        coverage_0x49c6355c(0xc0d7f4e8c756d48a546bc1f5e9f2738cd4064d36479c0e2f02946ca5b559284c); /* statement */ \nuint32 averageLatency;\ncoverage_0x49c6355c(0x6d7c5e772e6105183013e78e9406189e0682766da179a7f342f65537333ba2f2); /* line */ \n        coverage_0x49c6355c(0x18222aea5943b610b94c016c0385240a12f1734bcc7140c0917d78be8564f968); /* statement */ \naddress validatorsFunctionalityAddress = contractManager.contracts(\n            keccak256(abi.encodePacked(\"ValidatorsFunctionality\")));\ncoverage_0x49c6355c(0xd825f61ea1a7f72328a32b5f546fa8b772dbd4c90a32ce280583ed9d821777ed); /* line */ \n        coverage_0x49c6355c(0xb0207b4d97f0f3e30e60edff34ddd0150b283b6889c62e2e5d4353c8a5071aa1); /* statement */ \n(averageDowntime, averageLatency) = IValidatorsFunctionality(validatorsFunctionalityAddress).calculateMetrics(nodeIndex);\ncoverage_0x49c6355c(0xc8f8b716b281a09d0bd30b8a9cde16d6e1d64e5b0ed232c8666ec07f39a0180c); /* line */ \n        coverage_0x49c6355c(0xa9ee64a5e391b8601a71da8ca9668723a9462d18dbf9dc51113110dacb9e53c0); /* statement */ \nuint bounty = manageBounty(\n            msg.sender,\n            nodeIndex,\n            averageDowntime,\n            averageLatency,\n            nodesDataAddress);\ncoverage_0x49c6355c(0x03145e2d4a497cc843d565d952edf68e37deec1ec209a2c81ce39e71f5cb44ba); /* line */ \n        coverage_0x49c6355c(0x15fd26f3e34accd5d834dadc153852873ffdad6be7fc7d08134fc0ecb597b5bb); /* statement */ \nINodesData(nodesDataAddress).changeNodeLastRewardDate(nodeIndex);\ncoverage_0x49c6355c(0xf0549acefaf5bd7425233482fc9b711e2bc6e2209ec352083bd011d8453f2965); /* line */ \n        coverage_0x49c6355c(0x09aa3ba03fbc2448e0d36fee901a88b7b553b87c73fbc8879344b744394d5fc0); /* statement */ \nIValidatorsFunctionality(validatorsFunctionalityAddress).upgradeValidator(nodeIndex);\ncoverage_0x49c6355c(0xfdcce90230439b808ac950077f2d938bbf91567561e2252a3ea609897baabaa7); /* line */ \n        coverage_0x49c6355c(0x1c505511fda12fc8dd2d2af1e2d24a65c24eecc0c80e902c318b515a014eb537); /* statement */ \nemit BountyGot(\n            nodeIndex,\n            msg.sender,\n            averageDowntime,\n            averageLatency,\n            bounty,\n            uint32(block.timestamp),\n            gasleft());\n    }\n\n    function manageBounty(\n        address from,\n        uint nodeIndex,\n        uint32 downtime,\n        uint32 latency,\n        address nodesDataAddress) internal returns (uint)\n    {coverage_0x49c6355c(0xb935368b8cbb1d13b6df78aa81346849b5642c3ad20eee0ace2d0f65f139ca17); /* function */ \n\ncoverage_0x49c6355c(0x4b02bd6922bdfc3b2b23da806f0c909fb8c828abd2d2c434cf552e85cb64a074); /* line */ \n        coverage_0x49c6355c(0x58de7d3b3dca617d111584abcb5aefb71bdafd234596275ad55878ad27d0b621); /* statement */ \nuint commonBounty;\ncoverage_0x49c6355c(0x7f64e531e2689c35b3c033d3a2a7f854db9bc197ff4bd12af11ef43a6aef5e8c); /* line */ \n        coverage_0x49c6355c(0x12176c462d07544b3ec946d40f934f265b46083733d0b57aeb764c0b74c19ef7); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0x49c6355c(0x384ca1a1f819fd73c43deea298294fc560ba69d07d3dc4444f2a8200c4ab67ed); /* line */ \n        coverage_0x49c6355c(0x8c7a68c0b4562781cb22cc48b4bd41e6546319f0e7bc20bcabac5b137c88e4dd); /* statement */ \nuint diffTime = INodesData(nodesDataAddress).getNodeLastRewardDate(nodeIndex) +\n            IConstants(constantsAddress).rewardPeriod() +\n            IConstants(constantsAddress).deltaPeriod();\ncoverage_0x49c6355c(0x9a237b27c8f70dab65d9966335912ce3cb22175e4ef5a518ed40a4c7d2c22248); /* line */ \n        coverage_0x49c6355c(0x3662dc74cb817ec8b1308526cf9a8299009bc2057978af625e274e95f9fdc2a8); /* statement */ \naddress managerDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"ManagerData\")));\ncoverage_0x49c6355c(0x8589cc761fa40ad1b224ec6114ee71b849c8746060de60db9199bdb590c5fdbe); /* line */ \n        coverage_0x49c6355c(0x36df137f9f8ff34a0dd9e15421625c017d5ab9772581449b1af2066eeae6ae4a); /* statement */ \naddress skaleTokenAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SkaleToken\")));\ncoverage_0x49c6355c(0x064d077e614c3904fa377ef5e6ed38e10f29a0e4e7b06556c9089d5643247d37); /* line */ \n        coverage_0x49c6355c(0x945e38f96a7b8efac0da196e9d7355cb84efdeb9b1df0f531611b96e912a98c9); /* statement */ \nif (IManagerData(managerDataAddress).minersCap() == 0) {coverage_0x49c6355c(0xa61629672098a1ae0289dbcc8c873e77733a75856cb13713a6fe1b99335a41fc); /* branch */ \n\ncoverage_0x49c6355c(0x50333ca59db846190bfb955ce8a4a368429f2bf872da67b92cdf98c798138c86); /* line */ \n            coverage_0x49c6355c(0x74cf5248834981c1731790586873fc67658986df9a109ac742bbec48c282268b); /* statement */ \nIManagerData(managerDataAddress).setMinersCap(ISkaleToken(skaleTokenAddress).CAP() / 3);\n        }else { coverage_0x49c6355c(0x5672cb35bfe56d71c6f8a0a465cddc0053009ecc3d0f24c92c2ddd7b43a300ca); /* branch */ \n}\ncoverage_0x49c6355c(0xe6d2fe3a40a7ce90e65d802bf6d8bae14961fa5936ede1d73477fd4077e45139); /* line */ \n        coverage_0x49c6355c(0x3fe961808ab0d325bd084c6d98d81d7527d3620bd55694557d5efacffa5d5051); /* statement */ \nif (IManagerData(managerDataAddress).stageTime() + IConstants(constantsAddress).rewardPeriod() < now) {coverage_0x49c6355c(0xffd3d13ea4276cf8e0d3835cee5b2bb1144402ffdbe3ca53a72e9a8947d5e3c0); /* branch */ \n\ncoverage_0x49c6355c(0x47e5a54d2a64f68782fe7b96b53009cc8fff6179b4633d8823313e81dd334b58); /* line */ \n            coverage_0x49c6355c(0x42f34cbfddfcafbc2e0d21a64b988bc20683a04331dc290f76c526a7586ceef3); /* statement */ \nIManagerData(managerDataAddress).setStageTimeAndStageNodes(INodesData(nodesDataAddress).numberOfActiveNodes() + INodesData(nodesDataAddress).numberOfLeavingNodes());\n        }else { coverage_0x49c6355c(0xcd267070975574bc2a232f6d06e987148e887e86143c09124e422df0f2eb1edd); /* branch */ \n}\ncoverage_0x49c6355c(0x75cc5412bb2e587a6af12274ba662d02977893c3a0ce07c4a0098744eb06badf); /* line */ \n        coverage_0x49c6355c(0xe1ab7fd94fcc616bcf4b3dd953862ccbfa358b2bc4663cb7889cfc5a6c3169a8); /* statement */ \ncommonBounty = IManagerData(managerDataAddress).minersCap() /\n            ((2 ** (((now - IManagerData(managerDataAddress).startTime()) /\n            IConstants(constantsAddress).SIX_YEARS()) + 1)) *\n            (IConstants(constantsAddress).SIX_YEARS() /\n            IConstants(constantsAddress).rewardPeriod()) *\n            IManagerData(managerDataAddress).stageNodes());\ncoverage_0x49c6355c(0x5d08b250a1f4df6ae029d1c7ee05e38cfc8ab983bca6e67277da2fb23c6a28ea); /* line */ \n        coverage_0x49c6355c(0xc6866c7ad0088d923a09b2536bc96247e23eecddbad2559c03641cde3e1993c1); /* statement */ \nif (now > diffTime) {coverage_0x49c6355c(0x44268fb16861e9e74ffaa063acb9ff3301dc0e61e0357ebb373f7dfa918a4403); /* branch */ \n\ncoverage_0x49c6355c(0x1e394728b46672fb82725d4459613118915ad08fb37b3946fa1820676c943c01); /* line */ \n            coverage_0x49c6355c(0x261250cb2c52f08d07a5559a02c1aef53528300ee8028fcf9ae0d1943061b564); /* statement */ \ndiffTime = now - diffTime;\n        } else {coverage_0x49c6355c(0xc2cc32af9bbdfa01b50c8ca5757f9d51cf3185e03ca915946a4ea534bcba76a7); /* branch */ \n\ncoverage_0x49c6355c(0x97b4e8386ddcdb082cc2651d6a5d526cdd4fe47a46ec1bfe106cfcca1d4385dd); /* line */ \n            coverage_0x49c6355c(0x7dc4ededa9abc2b2c74dc269f065a34e7e428bbd62e009f607d1574c5ecfdb59); /* statement */ \ndiffTime = 0;\n        }\ncoverage_0x49c6355c(0x35ce61f00b83affe657b416b0eeb6fa2bf325adcac1a340602269ce4a5580a1c); /* line */ \n        coverage_0x49c6355c(0x9e5bfc070a11b7ddcef8b404864b8ebd3f9b5782770590823289fe2e126e4d05); /* statement */ \ndiffTime /= IConstants(constantsAddress).checkTime();\ncoverage_0x49c6355c(0x3058e543afde11ca1a5a1fdca768e6a1d789b0de156d1e10f22a3b54fff4217a); /* line */ \n        coverage_0x49c6355c(0xc2b0b47818b7bdf90f749ba0a13ba363f52f2f91428c64f339e9e4841406d79d); /* statement */ \nint bountyForMiner = int(commonBounty);\ncoverage_0x49c6355c(0x85cfebe13ad48f555cd4cea5041da7948eb7e8bd30fae28b7d39740745fddf9b); /* line */ \n        coverage_0x49c6355c(0x5b2054165329f6eac336686ed9aafd1bed274cb1885b34d3b551260973eb050d); /* statement */ \nuint normalDowntime = ((IConstants(constantsAddress).rewardPeriod() - IConstants(constantsAddress).deltaPeriod()) /\n            IConstants(constantsAddress).checkTime()) / 30;\ncoverage_0x49c6355c(0x61f5f79f8a36222d7c611e8d9461ff4c71561e555fb9d96ad639d9fdfe15ca5c); /* line */ \n        coverage_0x49c6355c(0xa817918dca427d6099da92c61ce2f82004f14fc473009cf3024c14c555a93ed6); /* statement */ \nif (downtime + diffTime > normalDowntime) {coverage_0x49c6355c(0xcbd9964c4e6a8dd35255430ccf15c7621959ba6daf46c50b576f4c34d24a4192); /* branch */ \n\ncoverage_0x49c6355c(0x81791ed901f7ac713a9d1788c0aeb77d55bba1bcb003b9b25954e8525dbdd3a1); /* line */ \n            coverage_0x49c6355c(0x6bcf0939dc55a9477c7625856865166eb7b963471a02f5c1c29c923a5fe34734); /* statement */ \nbountyForMiner -= int(((downtime + diffTime) * commonBounty) / (IConstants(constantsAddress).SECONDS_TO_DAY() / 4));\n        }else { coverage_0x49c6355c(0xd33ccb913b9f4b149cc3204bda366922fd66c5ec9d2071b5dfa34d452ddaef38); /* branch */ \n}\n\ncoverage_0x49c6355c(0x92ff448b5590cd286d701fe572c0026c578a110fb5b3934a883578fe8d0e1ca8); /* line */ \n        coverage_0x49c6355c(0x80c947a331caab634f830be1a6d7cf7f5dc00850049bafd0c06f3097c9c58755); /* statement */ \nif (bountyForMiner > 0) {coverage_0x49c6355c(0xe57164a57bf404c5d3add455d1108ff9b937f7bc584fc57004805cf9d255573f); /* branch */ \n\ncoverage_0x49c6355c(0xdd49d073c4b4bda787db85293df9c123dd0fcd9c5bcd8f60690c76312f480f21); /* line */ \n            coverage_0x49c6355c(0xe99c4608fdfad93542ffb30e79ebf4811b2c0cb1bd359b612f333a0198f8ac90); /* statement */ \nif (latency > IConstants(constantsAddress).allowableLatency()) {coverage_0x49c6355c(0x1a099f0abcab9c3a6d45a15c572515a4337c937f9453a425cdd5da22897a919e); /* branch */ \n\ncoverage_0x49c6355c(0x6843fd875446769002f7f42f031b7db5c25696c7c5f9c8508e3e47d220c81b40); /* line */ \n                coverage_0x49c6355c(0xea25df6df3850178a93792d984421814a2657c27b4d9afd37928fb639ee6f534); /* statement */ \nbountyForMiner = (IConstants(constantsAddress).allowableLatency() * bountyForMiner) / latency;\n            }else { coverage_0x49c6355c(0x1a05c86fddb3f2773665cdae8919cddd2ac598333ca6d2b6fbb479bae1cf91e0); /* branch */ \n}\ncoverage_0x49c6355c(0x59b6607f969bd1cb66265f81116c6d92aecb997bd3f0c858ee4acff0bc303e17); /* line */ \n            coverage_0x49c6355c(0xda67688cecdf38542185148da01be8c6b9ab99a82865ae760b61614aea675786); /* assertPre */ \ncoverage_0x49c6355c(0xbac2ec82192e1bafe8b5b98ddc2ca34db122d6196540010f4da534b72eb2719c); /* statement */ \nrequire(\n                ISkaleToken(skaleTokenAddress).mint(\n                    address(0),\n                    from,\n                    uint(bountyForMiner),\n                    bytes(\"\"),\n                    bytes(\"\")\n                ), \"Minting of token is failed\"\n            );coverage_0x49c6355c(0x3117e8f7fb617e4b7291dee88ae5513edca91143d1471bd4c337a039dbc1e906); /* assertPost */ \n\n        } else {coverage_0x49c6355c(0xd2bf9149d4f60dfe50225e16fbe1a0b31fac4fb0d1b24378f10cc3c714f64a0a); /* branch */ \n\n            //Need to add penalty\ncoverage_0x49c6355c(0xca759123a6bcbd9fc1d071bcddd64410befaf1b9fbe57dc26aae343017554e19); /* line */ \n            coverage_0x49c6355c(0x4da6e367612956654141da0559c3c2961572da7986dd2c7d1ef99730da8e9195); /* statement */ \nbountyForMiner = 0;\n        }\ncoverage_0x49c6355c(0x0e10b181fcdeb81befa533d2a6a9fbd2fdedc14f5053bc00e93b6fe0d615608e); /* line */ \n        coverage_0x49c6355c(0x18ef346cf04a10cff703d5b01854ccc92f32e03b10e337e137ba0fc80d44c9c8); /* statement */ \nreturn uint(bountyForMiner);\n    }\n\n    function fallbackOperationTypeConvert(bytes memory data) internal pure returns (TransactionOperation) {coverage_0x49c6355c(0x59cef5963981d4801fbc4076aea2c337c10122b317a36d3997e96c1b5fe4db25); /* function */ \n\ncoverage_0x49c6355c(0x5b102f70b9f37977526d72ada7d1e1d36c9bd43ac05f759a245fe379baf125c0); /* line */ \n        coverage_0x49c6355c(0xb2113085e0e27f8340d77adc704bbeb314e4c0dd902da26ddca90313c6d09447); /* statement */ \nbytes1 operationType;\ncoverage_0x49c6355c(0x11c3bc8cbd57de38780b2ad1cc53b5529ecace8ac2fd1d13dda1896b2a637c47); /* line */ \n        assembly {\n            operationType := mload(add(data, 0x20))\n        }\ncoverage_0x49c6355c(0x3beef034235fe39199226091daacbc1917eb47d3394d95b866f4a5c47d31308a); /* line */ \n        coverage_0x49c6355c(0xff34e5717c375d65b9b732ed5c2b5670f331185caa82820c21f6fb7039842503); /* statement */ \nbool isIdentified = operationType == bytes1(uint8(1)) || operationType == bytes1(uint8(16));\ncoverage_0x49c6355c(0xac67155df4491da931cf9c4da2f214aad31da2a515a4b6c08ad594e575e84aa3); /* line */ \n        coverage_0x49c6355c(0x7ab305f8f71ac2ed69f72cc93e028919d9e5eac8d721c437e4a4b3862908d335); /* assertPre */ \ncoverage_0x49c6355c(0xead63839274fa28e2937de1ea4554ea32834eb2ae8f7cf9469c30329577470e8); /* statement */ \nrequire(isIdentified, \"Operation type is not identified\");coverage_0x49c6355c(0x1a0d1b0a2722aa2ba417c9707de4e7db220fd2da2891f0ba5ab8dc50e84c4874); /* assertPost */ \n\ncoverage_0x49c6355c(0xd67bd0f88c44ef102e95d364dbc5e6d98d89b4914bd233dc5f7fc4ce3b12df98); /* line */ \n        coverage_0x49c6355c(0xfa5ede927956624abf03437f36d2b6704ce0c8806999ffa1617dad21d330e223); /* statement */ \nif (operationType == bytes1(uint8(1))) {coverage_0x49c6355c(0x03158322bcc0d6f8d2121b3f9228688b239eaa5d9179521c0a18cf7f2f79db19); /* branch */ \n\ncoverage_0x49c6355c(0xb985c3fbc701a487587389c2e971be167c442ca6dec16379964ae9a34c32233f); /* line */ \n            coverage_0x49c6355c(0x7d9c1daf442aa2fa312f98ca1f767e1b4a0717ca9bd0eb9b8ceb6fbf1b396e95); /* statement */ \nreturn TransactionOperation.CreateNode;\n        } else {coverage_0x49c6355c(0x0055ad5d370526362c2ff2d2f08f664c3534458e39f02c4c010d064f2fd70181); /* statement */ \ncoverage_0x49c6355c(0x1f43bc07741e0ceb740321d09020105f9f70e6afcd4db5d6d6bd31026f927bf4); /* branch */ \nif (operationType == bytes1(uint8(16))) {coverage_0x49c6355c(0x17785d0cd0ab0d9a8f346fb5e27a371188ecd1a93878dd8debc2cd6d2eeab324); /* branch */ \n\ncoverage_0x49c6355c(0xbc1e61f49bba04714c66b01017380f2a5359c1d139459bcda7b09443e784b021); /* line */ \n            coverage_0x49c6355c(0xcfb49db730f984c0811658d6b33cbad109b4b5e683a29974d23726ca2fb95154); /* statement */ \nreturn TransactionOperation.CreateSchain;\n        }else { coverage_0x49c6355c(0x95673d84394cd74a9082fff4c6b80334339a3e7b03f779550db5f546e217cc0f); /* branch */ \n}}\n    }\n\n}\n"
    },
    ".coverage_contracts/ValidatorsFunctionality.sol": {
      "content": "/*\n    ValidatorsFunctionality.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./GroupsFunctionality.sol\";\nimport \"./interfaces/IConstants.sol\";\nimport \"./interfaces/INodesData.sol\";\nimport \"./interfaces/IValidatorsFunctionality.sol\";\n\ninterface IValidatorsData {\n    function addValidatedNode(bytes32 validatorIndex, bytes32 data) external;\n    function addVerdict(bytes32 validatorIndex, uint32 downtime, uint32 latency) external;\n    function removeValidatedNode(bytes32 validatorIndex, uint indexOfValidatedNode) external;\n    function removeAllValidatedNodes(bytes32 validatorIndex) external;\n    function removeAllVerdicts(bytes32 validatorIndex) external;\n    function getValidatedArray(bytes32 validatorIndex) external view returns (bytes32[] memory);\n    function getLengthOfMetrics(bytes32 validatorIndex) external view returns (uint);\n    function verdicts(bytes32 validatorIndex, uint numberOfVerdict, uint layer) external view returns (uint32);\n}\n\n\ncontract ValidatorsFunctionality is GroupsFunctionality, IValidatorsFunctionality {\nfunction coverage_0xdb799386(bytes32 c__0xdb799386) public pure {}\n\n\n    event ValidatorCreated(\n        uint nodeIndex,\n        bytes32 groupIndex,\n        uint numberOfValidators,\n        uint32 time,\n        uint gasSpend\n    );\n\n    event ValidatorUpgraded(\n        uint nodeIndex,\n        bytes32 groupIndex,\n        uint numberOfValidators,\n        uint32 time,\n        uint gasSpend\n    );\n\n    event ValidatorsArray(\n        uint nodeIndex,\n        bytes32 groupIndex,\n        uint[] nodesInGroup,\n        uint32 time,\n        uint gasSpend\n    );\n\n    event VerdictWasSent(\n        uint indexed fromValidatorIndex,\n        uint indexed toNodeIndex,\n        uint32 downtime,\n        uint32 latency,\n        bool status,\n        uint32 time,\n        uint gasSpend\n    );\n\n    event MetricsWereCalculated(\n        uint forNodeIndex,\n        uint32 averageDowntime,\n        uint32 averageLatency,\n        uint32 time,\n        uint gasSpend\n    );\n\n    event PeriodsWereSet(\n        uint rewardPeriod,\n        uint deltaPeriod,\n        uint32 time,\n        uint gasSpend\n    );\n\n\n    event ValidatorRotated(\n        bytes32 groupIndex,\n        uint newNode\n    );\n\n    constructor(\n        string memory newExecutorName,\n        string memory newDataName,\n        address newContractsAddress\n    )\n        GroupsFunctionality(\n            newExecutorName,\n            newDataName,\n            newContractsAddress\n        )\n    public\n    {coverage_0xdb799386(0x2c7f0d2d1848e85f5a6e2295efcb12deec04a775ff4c54bdc4fa18c486ed77e8); /* function */ \n\n\n    }\n\n    /**\n     * addValidator - setup validators of node\n     */\n    function addValidator(uint nodeIndex) external allow(executorName) {coverage_0xdb799386(0x29457460f30ba167511d4a762f9897ce89a81a88036ade3fa13ecfea59792831); /* function */ \n\ncoverage_0xdb799386(0x64b1450f477a87b078901356eb71d3eb7882a7cb4680e6fd5894d21d500563e7); /* line */ \n        coverage_0xdb799386(0x2ddbba330e5b56c29b1f95f5bb51c62d8ca7718f5f2864febfcca86ce1879f59); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0xdb799386(0x7113e3532e9ca6ee4f74dd5c9a1663acfb89f4c75a17996820ccb16be3f75ef4); /* line */ \n        coverage_0xdb799386(0x03ec2a1c2a8b63abc1662d3fb0b15b7fe83ae6846d2ec861985e6a69bf94b19a); /* statement */ \nIConstants constantsHolder = IConstants(constantsAddress);\ncoverage_0xdb799386(0x942e7036824f9387b15e35e8bf422473e244d7103ca511c0c08c1ce365583c26); /* line */ \n        coverage_0xdb799386(0xf87886c5488247fe798a11956f72acdcb58d8b9393d5be18da3db5a20f184a80); /* statement */ \nbytes32 groupIndex = keccak256(abi.encodePacked(nodeIndex));\ncoverage_0xdb799386(0x68bd267e3c895feff5191b4b91460ed9b1fb000a0b8147ab7323f11afd6a580e); /* line */ \n        coverage_0xdb799386(0xf9b4cebd3e6ab5c56b8bdb2aad37cb8e59fc9890e4f5428e9bd21497c7f25ed2); /* statement */ \nuint possibleNumberOfNodes = constantsHolder.NUMBER_OF_VALIDATORS();\ncoverage_0xdb799386(0x64023ec3a662db0007a5aa0cd8f28aec8b373aff71ae73251449a624e2658566); /* line */ \n        coverage_0xdb799386(0x4fcb5f52f66e136d4dd05a2da9677e1eabeccd391dec8491ebef7b446a21a6d6); /* statement */ \naddGroup(groupIndex, possibleNumberOfNodes, bytes32(nodeIndex));\ncoverage_0xdb799386(0xc60f3ee9615d027b98679708862caf7e1746869542997a7009a0966ea40011eb); /* line */ \n        coverage_0xdb799386(0x45774e5ada910135e8a2abd660b0353ad4f8030d68ca5db5cc7f91e43f4df79d); /* statement */ \nuint numberOfNodesInGroup = setValidators(groupIndex, nodeIndex);\ncoverage_0xdb799386(0xca66d036244c990ac864cdfc2b49688ce26f6ce1e7df8c8913fddc7a43351b2b); /* line */ \n        coverage_0xdb799386(0xa80b6ea832ca6c0ac227e9cba468a726d8277b1a5052b97858fbd4e036166249); /* statement */ \nemit ValidatorCreated(\n            nodeIndex,\n            groupIndex,\n            numberOfNodesInGroup,\n            uint32(block.timestamp), gasleft()\n        );\n    }\n\n    function upgradeValidator(uint nodeIndex) external allow(executorName) {coverage_0xdb799386(0x514d091b5b1cdb12af056d754370fb1b2b82897b1687b3b9561b6786cde84df1); /* function */ \n\ncoverage_0xdb799386(0xf8eeb776bcbb3a8f69577c5c17bbf11c166a1a1e707c0fe2b700e2c1c332d0cf); /* line */ \n        coverage_0xdb799386(0x2e235fa9b64c26087210a10e24cead3077a492139346ddb49f4d637717ef926d); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0xdb799386(0xc699ca0d50817b03cdc58a846940f33c6c6eee6f32695f5bf33627e2d0dca63a); /* line */ \n        coverage_0xdb799386(0x62d5e30149e1aaa0512d74c14ae636f5f3191c1e90fa81d2f74f076d296c0772); /* statement */ \nIConstants constantsHolder = IConstants(constantsAddress);\ncoverage_0xdb799386(0xa2b27db75ba4ee6041ca3b0f8751e0bdbc65ed13bcb6554eefe1dbd540368d1c); /* line */ \n        coverage_0xdb799386(0xb9a734023aad08224290f77824dc02b198c70e8781ed52f75755e93b8a490c0d); /* statement */ \nbytes32 groupIndex = keccak256(abi.encodePacked(nodeIndex));\ncoverage_0xdb799386(0x3dd4bd0844b0da2cc39acaf8134574db306bd70d85c000f26d48e0a4f5606f3d); /* line */ \n        coverage_0xdb799386(0x8251faab698bbd9377c9b26af2732fabb4610316575bcb3a6b4341c3d7d1eb48); /* statement */ \nuint possibleNumberOfNodes = constantsHolder.NUMBER_OF_VALIDATORS();\ncoverage_0xdb799386(0x7cce443af9b2ea3ae6c13863fb25d9874be212217d76a77a2788aaf3581c6eeb); /* line */ \n        coverage_0xdb799386(0x0fdd5a4631dc43c4e2d84d03b4dfe7b766a0f107b5b3623f266aa91a2bb7de99); /* statement */ \nupgradeGroup(groupIndex, possibleNumberOfNodes, bytes32(nodeIndex));\ncoverage_0xdb799386(0x6874dc86ab72b3a881c18f6f2cd475438f3df181a9fbaed1d11af27d802ce977); /* line */ \n        coverage_0xdb799386(0x2a4bd8dd759135778a3370e92014ae27add9882d8721726b8e79f3c4f83676b9); /* statement */ \nuint numberOfNodesInGroup = setValidators(groupIndex, nodeIndex);\ncoverage_0xdb799386(0xd4a7a55f5a1cc768717e220928b377920df47e27536425753fa9f6851a2db159); /* line */ \n        coverage_0xdb799386(0x6238e0ad1ce92298d5f282fa29badcc5b5440ed6981156522f63d34ece40fe32); /* statement */ \nemit ValidatorUpgraded(\n            nodeIndex,\n            groupIndex,\n            numberOfNodesInGroup,\n            uint32(block.timestamp), gasleft()\n        );\n    }\n\n    function deleteValidatorByRoot(uint nodeIndex) external allow(executorName) {coverage_0xdb799386(0xbaee61d14df7c39a2706053e162168d5aa2eb288c3d6f19fe0bd540f8b3a111d); /* function */ \n\ncoverage_0xdb799386(0xc829f66b8162968674e6a9006ab5043c6ec64c3bdf83683e91e470ca8db9329d); /* line */ \n        coverage_0xdb799386(0xa97a2887dacc0d68dc0f9957f1bce177b56dcb2781aafff99097b634a69acd39); /* statement */ \nbytes32 groupIndex = keccak256(abi.encodePacked(nodeIndex));\ncoverage_0xdb799386(0x7272c1c44e2ff7fcc0c0d7d4e549569c7f418c8245cd55029afcdc594828321e); /* line */ \n        coverage_0xdb799386(0x93045730a3adad216f2bb09278bfc480db3808990271403b9a2964ca11aaaf11); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0x00134afba40a5f5d3b23b23b9c9a9d7089da4c1e3280b3c2b59fb70a4363e826); /* line */ \n        coverage_0xdb799386(0x68ad32d9861cfe435ad50aafb1ac1272e37aa56a5dd6bae982e4ff1c9a53a2a9); /* statement */ \nIValidatorsData(dataAddress).removeAllVerdicts(groupIndex);\ncoverage_0xdb799386(0xdd73bf6d7b339f1473ae33d1a1993861e8db66c489a50841029c04cc332960c5); /* line */ \n        coverage_0xdb799386(0x21b463f40ea098e9db0c380d926feded19fdd535408b1f86f1a1b12597b3abcd); /* statement */ \nIValidatorsData(dataAddress).removeAllValidatedNodes(groupIndex);\ncoverage_0xdb799386(0xae3fc6c84c946d009ec507c79b0e436a041bce5dcc3131a3691204999eb25ba4); /* line */ \n        coverage_0xdb799386(0xb8aec668a6f18f291fe4c159499209b769417c6c2e43e9fd2447f3f4fa688f7c); /* statement */ \ndeleteGroup(groupIndex);\n    }\n\n    function sendVerdict(\n        uint fromValidatorIndex,\n        uint toNodeIndex,\n        uint32 downtime,\n        uint32 latency) external allow(executorName)\n    {coverage_0xdb799386(0xc1942441ae2bf717ab79c7efea92b4a2ce50c0e5ea347a6f021663ba47512c8b); /* function */ \n\ncoverage_0xdb799386(0xb8f586ca8f38c5c654722204123c22170b4dab63bfbb96158f4b6daba7fa19c3); /* line */ \n        coverage_0xdb799386(0xa889edb1625430680911479e2508ce9b90945ea80a46670635add85771f01f65); /* statement */ \nuint index;\ncoverage_0xdb799386(0x978b3634bec64ce70f4b414bea0c0d869525ebb14c76f70f6ce1c858c330bd24); /* line */ \n        coverage_0xdb799386(0xf6f17763aaa39f8d732cc393e00f19631599fa87b99bc84f2bfc99ea36ceb4ed); /* statement */ \nuint32 time;\ncoverage_0xdb799386(0x4d23aefbf067dd5ca5faa2fa1afc6f8ba9c0fdc3791c17ccacb215c2c5eee838); /* line */ \n        coverage_0xdb799386(0x3f88c403b88cb3c619a73d2d490566d6e254bb65d92db091175b038b295dd63a); /* statement */ \nbytes32 validatorIndex = keccak256(abi.encodePacked(fromValidatorIndex));\ncoverage_0xdb799386(0x443218065255aaf38cab6d4c988ec54c882abe57956bcf16e65648e5fcc7bb8e); /* line */ \n        coverage_0xdb799386(0xa837e8f1412450fb0c427ce7c2f4a86b6dc81a10d6cdb32bb7288f3fe56a5490); /* statement */ \n(index, time) = find(validatorIndex, toNodeIndex);\ncoverage_0xdb799386(0xfe00f57d175b7902e99e889d7ae8f7de61c22b14da4f010ee99e52c5d40fc93a); /* line */ \n        coverage_0xdb799386(0x2384717707af76d399c19b3c2c1c6a71191c930a3bdb2983a83658a6972829d3); /* assertPre */ \ncoverage_0xdb799386(0x4f94ab19e32abf3957f1937b128474a66ef484975f74ad2d519875870f0c9320); /* statement */ \nrequire(time > 0, \"Validated Node does not exist in ValidatorsArray\");coverage_0xdb799386(0x38ea9a504e861496e4cd2ac76d21931ac058cdc2c4d0013b32b6d392801a7382); /* assertPost */ \n\ncoverage_0xdb799386(0xa9a55f54344b6759d4bf74aabfe8fb1122fe90b03b9892b4621e9a1e0ca8eeec); /* line */ \n        coverage_0xdb799386(0xeac3004217d702c77069b01e983563c12492c001a9111a733c4dcb18f16c24c5); /* assertPre */ \ncoverage_0xdb799386(0x87dd1f1056cdb8e8b3e633e151b6909ecdc0d4514a83521145375e8d06088ae0); /* statement */ \nrequire(time <= block.timestamp, \"The time has not come to send verdict\");coverage_0xdb799386(0x8d2de3af9b5dbeaaaa76b383e05ec52f8ee2a3c35ad7c9e32dc120488caa63d6); /* assertPost */ \n\ncoverage_0xdb799386(0xa1c9570d8add1bb590228de2f541961be0e2d4c4da1819136224238a8b9afe8c); /* line */ \n        coverage_0xdb799386(0xf2b632f90da589ee14cc5682ca9a7ce202a11266fca57e2ffb51f24bc9927c95); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0xccac6a41b46d73322970947e2508ad3569b910781c97364db6d7a0c1e260f324); /* line */ \n        coverage_0xdb799386(0x949500a6e5c1e50e4725a1739e4a4da2e049a11d6740693e08d6426184a7bd9b); /* statement */ \nIValidatorsData(dataAddress).removeValidatedNode(validatorIndex, index);\ncoverage_0xdb799386(0xd9ededc12da29dc0de227abb483aa433a1597c01c1c346ab005f09a62b9a93b9); /* line */ \n        coverage_0xdb799386(0xee6e59146fc97980c5f8a3a8c5d126c0d98ab57a6068ebc31c972679504a7cce); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0xdb799386(0x9abd76538e8588e0347e34785f78c2cdbe4a34cc52fe45c5beff7c04b061bae1); /* line */ \n        coverage_0xdb799386(0x596a2c6e3d47c1ffcbb52c7f0572e0b1a13845dba4d33cf8d9f57a220701bd84); /* statement */ \nbool receiveVerdict = time + IConstants(constantsAddress).deltaPeriod() > uint32(block.timestamp);\ncoverage_0xdb799386(0x8ba3aea5e69897188400aafd8f3c6d9fa15cdf79345c3b9b9fcc2a6bd89a5645); /* line */ \n        coverage_0xdb799386(0x8f9f0a96026b82902a9599b3eb9c7d4612203e51e6446b5e8229dc2b9a7c0f4b); /* statement */ \nif (receiveVerdict) {coverage_0xdb799386(0x3faf9b7d674f52f39c764124bdd9fe288988a4bbdf2a07f722742fa01eb2a574); /* branch */ \n\ncoverage_0xdb799386(0x1cc275e1d1a1280e83dae4e91f997b740eba63fc1deb772129e9eef554c31705); /* line */ \n            coverage_0xdb799386(0x4228072299daffef591860f45633ab49f9e2ee17df520b7dfff84f0bc2408b11); /* statement */ \nIValidatorsData(dataAddress).addVerdict(keccak256(abi.encodePacked(toNodeIndex)), downtime, latency);\n        }else { coverage_0xdb799386(0x87bf889533f32cabd3ebbf568256e8bccc183f08f5076493b66cbb0e8f163365); /* branch */ \n}\ncoverage_0xdb799386(0x962185f57e1c81841ebe01a033952059e434ea84d73050af66e1833586ce974a); /* line */ \n        coverage_0xdb799386(0xa6f77d95f2798f3c6279de958cc1d758a6e8bb3890b76c42f0fe5a90a2a00d33); /* statement */ \nemit VerdictWasSent(\n            fromValidatorIndex,\n            toNodeIndex,\n            downtime,\n            latency,\n            receiveVerdict, uint32(block.timestamp), gasleft());\n    }\n\n    function calculateMetrics(uint nodeIndex) external allow(executorName) returns (uint32 averageDowntime, uint32 averageLatency) {coverage_0xdb799386(0x997e8dfab83241bb5a7b288e5e41d4dcd4003af354400d44e268b387f99ab4b7); /* function */ \n\ncoverage_0xdb799386(0xb935cfe7657ff1409b2fe0e9e8d7b0dc368fc2dab6e9f170a39090de0175b505); /* line */ \n        coverage_0xdb799386(0xb2295c59b927a7c7fd1d27c1e25ee2cd5a165d94a753ae7e3366684a0eb0d4ec); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0xee8687dc046fc3a4f3f7483dc2c59bf1176f2e985b615bb4202bb945f7c53f16); /* line */ \n        coverage_0xdb799386(0x8a505fc7e34029b42d3daf8ef2d38586d39d63877f27de6e4cd954ff3221649c); /* statement */ \nbytes32 validatorIndex = keccak256(abi.encodePacked(nodeIndex));\ncoverage_0xdb799386(0x014e1ac708b3e6f6e57f801a267359d3e72b356a9e7e97874dafdc086f3e04ed); /* line */ \n        coverage_0xdb799386(0xed4c32ce07be9f5f7952fc53f8abbb2f9873981850ca717a1d89ca7a82c9f350); /* statement */ \nuint lengthOfArray = IValidatorsData(dataAddress).getLengthOfMetrics(validatorIndex);\ncoverage_0xdb799386(0x96af5f0fc6da66f82ff0cfad2d8096764fc8c871f3536208c6538e6e06df3b4a); /* line */ \n        coverage_0xdb799386(0xa69bb706f8701d4deb4646b686491e5ac7a66a07f73f8879a2c2d6d1a69b13b3); /* statement */ \nuint32[] memory downtimeArray = new uint32[](lengthOfArray);\ncoverage_0xdb799386(0xeed544cbddf849d58ad3377844e6ad4c4b60a49a6bf3d3e8f8c73327d112e3ee); /* line */ \n        coverage_0xdb799386(0x0ee111dd3e05e367238b715d53aa5d801b93c125e3385668e018eccf36839b8f); /* statement */ \nuint32[] memory latencyArray = new uint32[](lengthOfArray);\ncoverage_0xdb799386(0xd6ee76a2986d97f328c052f6d5e0a52060d13b388d9804c9e5af8efc603c0b09); /* line */ \n        coverage_0xdb799386(0xdd504343614cbfbc09dbcca105a5c7150c32df5888a04b3f65623178e8a10411); /* statement */ \nfor (uint i = 0; i < lengthOfArray; i++) {\ncoverage_0xdb799386(0xcf0764164421e1f59e7711028c64416383c6e36bad989607cc644c393d305f4b); /* line */ \n            coverage_0xdb799386(0x902e1004977b79b60e70f640e8d1fb572a3ca1afc9adc526c4428d88bcd897a8); /* statement */ \ndowntimeArray[i] = IValidatorsData(dataAddress).verdicts(validatorIndex, i, 0);\ncoverage_0xdb799386(0x78a5c5f193f50d8399879c6f8d227d41cfb3161cc694319e8874f248b5fff01d); /* line */ \n            coverage_0xdb799386(0x34d9e2cc891f6a73d12926a3c401171c1885e47137e6da05cd5d5376af460225); /* statement */ \nlatencyArray[i] = IValidatorsData(dataAddress).verdicts(validatorIndex, i, 1);\n        }\ncoverage_0xdb799386(0xa08cc6f3b0d496f0556e190c2020d491d63a1d8e6f4fa5a8b40d6317e53d81e4); /* line */ \n        coverage_0xdb799386(0xc3fa9489a609ec3ee49a91d361d493444095ad39738908491644ba9f6d056625); /* statement */ \nif (lengthOfArray > 0) {coverage_0xdb799386(0x64860e171ba89a93773d02d4fa3858b1cba30dd221cb68e107bea1fc6b9784a1); /* branch */ \n\ncoverage_0xdb799386(0x97f195a0599ecfa2080fd62e71fcab727b712e9ad6488580678bb45ac7b555e3); /* line */ \n            coverage_0xdb799386(0xca76b7ee8fe7aa9d1efea30a70322406992678632ce1e65e858c1a20e008cb76); /* statement */ \naverageDowntime = median(downtimeArray);\ncoverage_0xdb799386(0x1d8e2d8a3a7d30bcb6b60981d1f88a4d1d8e6441b3747950e2b11bb9b6d92a3d); /* line */ \n            coverage_0xdb799386(0xee5a66f6c075a9aecea94d38bc49559410b8a081c7d2b685503413992808d502); /* statement */ \naverageLatency = median(latencyArray);\ncoverage_0xdb799386(0x602f0c7873da89ed75482da723acfb59d5eddde2f5d5fb85373e34c8b8f50fd8); /* line */ \n            coverage_0xdb799386(0xbe9b294c7f5aa7040d43f2336e751ea7c6e485eef8cfb3d8940136ecde7b41ae); /* statement */ \nIValidatorsData(dataAddress).removeAllVerdicts(validatorIndex);\n        }else { coverage_0xdb799386(0x6fbc4d7db8b1fc2934d5a1599298fc62d1389fe8be9748687c832a8e95fd4937); /* branch */ \n}\n    }\n\n    // function rotateNode(bytes32 schainId) external {\n    //     uint newNodeIndexEvent;\n    //     newNodeIndexEvent = selectNodeToGroup(schainId);\n    //     emit ValidatorRotated(schainId, newNodeIndexEvent);\n    // }\n\n    // function selectNodeToGroup(bytes32 groupIndex) internal returns (uint) {\n    //     address dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\n    //     require(IGroupsData(dataAddress).isGroupActive(groupIndex), \"Group is not active\");\n    //     bytes32 groupData = IGroupsData(dataAddress).getGroupData(groupIndex);\n    //     uint hash = uint(keccak256(abi.encodePacked(uint(blockhash(block.number - 1)), groupIndex)));\n    //     uint numberOfNodes;\n    //     (numberOfNodes, ) = setNumberOfNodesInGroup(groupIndex, groupData);\n    //     uint indexOfNode;\n    //     uint iterations = 0;\n    //     while (iterations < 200) {\n    //         indexOfNode = hash % numberOfNodes;\n    //         if (comparator(groupIndex, indexOfNode)) {\n    //             IGroupsData(dataAddress).setException(groupIndex, indexOfNode);\n    //             IGroupsData(dataAddress).setNodeInGroup(groupIndex, indexOfNode);\n    //             return indexOfNode;\n    //         }\n    //         hash = uint(keccak256(abi.encodePacked(hash, indexOfNode)));\n    //         iterations++;\n    //     }\n    //     require(iterations < 200, \"Old Validator is not replaced? Try it later\");\n    // }\n\n    function generateGroup(bytes32 groupIndex) internal allow(executorName) returns (uint[] memory) {coverage_0xdb799386(0xdb5fb823d6158593685cd5cb11e80dd86bdb0e65bf05979bcfb264ce158254a5); /* function */ \n\ncoverage_0xdb799386(0x9502eef1555ec60eccdb6887d2996a300df70f2b141ff41852ed80fa76943e8c); /* line */ \n        coverage_0xdb799386(0x5aeed069c96a13841a099b5d91b1102f3d1ab82d0daf138e87e80733590375b5); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0x8b088d683f067c5d7019265a76bc92a3bcec4c10b978682796a3f930701ccc9e); /* line */ \n        coverage_0xdb799386(0x9e074438dd4a0851757c5bf8590a12dcbe529ea3ba142e119e33a3ce1967e24e); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\n\ncoverage_0xdb799386(0xbf5a24381a7ffe62b4a619f3e7c6ee397ee79198c0f427ec205a460d13be8e2f); /* line */ \n        coverage_0xdb799386(0x6dd7571e0bcd0e466e4f857e4cfc324d6aac88bac534eb031a53079e543d6968); /* assertPre */ \ncoverage_0xdb799386(0x9538f8e179586c93055cbf1e08f06ebb71d139cd346b9a443890091624083983); /* statement */ \nrequire(IGroupsData(dataAddress).isGroupActive(groupIndex), \"Group is not active\");coverage_0xdb799386(0x050dfd2dd28eed0b37a0d7a0ad679f8b8f18e31deb4481d07e99ec1019df864f); /* assertPost */ \n\n\ncoverage_0xdb799386(0x54cfd331aa3257970593b1b07d6d27cfba3d7713d783156fd598dcdf2c9951b0); /* line */ \n        coverage_0xdb799386(0xb8530ad8b5326df30782fcc9b14f61faa4835e9c41fc7bf508807ab28cc6f110); /* statement */ \nuint exceptionNode = uint(IGroupsData(dataAddress).getGroupData(groupIndex));\ncoverage_0xdb799386(0x5f994baa4a034482d11ca4f34ba29cd5bd5d8dd1f9ed357ab665d0761657a36a); /* line */ \n        coverage_0xdb799386(0x20e6c272e45f18d2c2b61bb95c915fde1dbe799e29e5d7a42db5665d5d4095eb); /* statement */ \nuint[] memory activeNodes = INodesData(nodesDataAddress).getActiveNodeIds();\ncoverage_0xdb799386(0x7c2574901c7af8b0a809790de47a35ba76c71aa0240e1a294fbb093262d9dfca); /* line */ \n        coverage_0xdb799386(0x90df8a96313a9a7c1abf3be4192fd6f685e9df5fccee1ebc9b168cd7232101e9); /* statement */ \nuint numberOfNodesInGroup = IGroupsData(dataAddress).getRecommendedNumberOfNodes(groupIndex);\ncoverage_0xdb799386(0x25253d7b9e00997be74034347cf4c7a9bea164de76f3578794a1c60f5daa67e3); /* line */ \n        coverage_0xdb799386(0x9a231c1a1ac6d356fe77774e9bddc261d9fb27c164e03cec24992ea416ff5404); /* statement */ \nuint availableAmount = activeNodes.length - (INodesData(nodesDataAddress).isNodeActive(exceptionNode) ? 1 : 0);\ncoverage_0xdb799386(0x7f53523f993ac620261020f66c15a99d97c898be33ffe4dba0e5cef24121992e); /* line */ \n        coverage_0xdb799386(0x20727a35dec2a6bcdca322140583cff74ca58948a4426c8be2bd31dc5782c8b6); /* statement */ \nif (numberOfNodesInGroup > availableAmount) {coverage_0xdb799386(0xb1bddce66a20c783ec574150884b1a6b7eb4286ed7260348d2910b11a280ff10); /* branch */ \n\ncoverage_0xdb799386(0x03d81b282abac1bc74a2fecf072eeb4145a7a86364092650be4dd3084bc209ba); /* line */ \n            coverage_0xdb799386(0xb6f99299c89ac1b9eaba2c16d4f0523ad6ba8e1cd5e126deded3e6cc121d9e99); /* statement */ \nnumberOfNodesInGroup = availableAmount;\n        }else { coverage_0xdb799386(0xec942cde325be9526e3fcc8cb0285584c1e416209a776304481f8409c6bd7950); /* branch */ \n}\ncoverage_0xdb799386(0x879fc18a0d0b4a4b33ddcab9914bf1cd4024464a732a91e45ea68b459f0d356b); /* line */ \n        coverage_0xdb799386(0x9198961dcd3f45d0baa841dd2ecccb05100184a573342c57dde1d2dc29524d22); /* statement */ \nuint[] memory nodesInGroup = new uint[](numberOfNodesInGroup);\ncoverage_0xdb799386(0x0738786f41923659a0502d85078467f5d0611e00e0896a4edeb384e18a33476c); /* line */ \n        coverage_0xdb799386(0xf3688c2b0e104ccda610653e09634dd7ee767e58097ac1720537332a75cb44af); /* statement */ \nuint ignoringTail = 0;\ncoverage_0xdb799386(0x73d54368adc15f20f7f1d5521c91da20e584ead4b480ebaac7c7311d12ab9a40); /* line */ \n        coverage_0xdb799386(0xd7a97a639efbb78918c0f36948af4adb95682b25c7e4117db62aea296becc7e3); /* statement */ \nuint random = uint(keccak256(abi.encodePacked(uint(blockhash(block.number - 1)), groupIndex)));\ncoverage_0xdb799386(0x54099b5b866cc083753dd2651d74dba9641b551401feed42d4e586f83e73cc91); /* line */ \n        coverage_0xdb799386(0xe05b7b5d4e64ae727a0df2bafee53412ed7b207ea6a362caf61d5501c3df666f); /* statement */ \nfor (uint i = 0; i < nodesInGroup.length; ++i) {\ncoverage_0xdb799386(0x52adcf608d82e9e6dff0d893c4e433371377fbc9db400de779194a15e8dc748f); /* line */ \n            coverage_0xdb799386(0x1fecface6c836e2e16955d12afa9b8e79f2b8ba7e8a02d2c7f92be8036d4ffec); /* statement */ \nuint index = random % (activeNodes.length - ignoringTail);\ncoverage_0xdb799386(0x9b190d7266875b8268164a68bc94911b3e47564c3a556e9d9400f3f618c26a8e); /* line */ \n            coverage_0xdb799386(0x834648a1cbaf7a7fe9d22b6fbe5a77279fb805ba297108e5d0d4e04fcbf855d3); /* statement */ \nif (activeNodes[index] == exceptionNode) {coverage_0xdb799386(0xfa58fac22fbd24ae3b3dd2df2d7b78bd0f3bf51fea67422f7c812026949a626d); /* branch */ \n\ncoverage_0xdb799386(0x4eeb7f7f3626095b1317d3994a0fabe85d172db99afdfd531c830284f5a795f8); /* line */ \n                coverage_0xdb799386(0x86203068bbba031c41ed689d3ac6a0b4ef9208347186e4e036ee32c00f9278a4); /* statement */ \nswap(activeNodes, index, activeNodes.length - ignoringTail - 1);\ncoverage_0xdb799386(0xcb96c4405a87f5565bf3783ff3048c8daa4e31a156d7eeebe087eaa82d5b925c); /* line */ \n                ++ignoringTail;\ncoverage_0xdb799386(0x85a16c62ebdfee07b9cb28af141efc90b393534d0055c431fe13fe22a6149a90); /* line */ \n                coverage_0xdb799386(0x76ac542ecb43a8f917676b6a84a6d264ca3a4595a23666efeb680f37b46baae9); /* statement */ \nindex = random % (activeNodes.length - ignoringTail);\n            }else { coverage_0xdb799386(0x1b9b5a29b66b90ff55c1d79c8459060896faba5e153fbe1b195d4b9a658cacc7); /* branch */ \n}\ncoverage_0xdb799386(0x5e92f869fa658a332dc20b21f72c9156c72d59bcc798193f6a51ad2f1dec8cfb); /* line */ \n            coverage_0xdb799386(0xef3113a5e728b3a3bf33f1b76b6c4623063be2ca16909bf0d8d95044938802c0); /* statement */ \nnodesInGroup[i] = activeNodes[index];\ncoverage_0xdb799386(0x12b4d8d694c498233d56fba77eb34ed64dcbc699f6c58cd55ea68fd49fc2defc); /* line */ \n            coverage_0xdb799386(0x49c88f9c6f6c813c6150fcd64ea3f9545bd117221427c0398d065cc41228f4d5); /* statement */ \nswap(activeNodes, index, activeNodes.length - ignoringTail - 1);\ncoverage_0xdb799386(0x99620e4481e17679efdd734fb0897d4fe2d007ac984bb642640614c052f72d91); /* line */ \n            ++ignoringTail;\ncoverage_0xdb799386(0x3198ca269ada3821c18755d5a7b1cda28211c06c37ac1f24f3125f3f84c7e6b7); /* line */ \n            coverage_0xdb799386(0x3665fbb49491e7fe1c0951f13c6212607028089b95d03f0acaa0563a81488ca5); /* statement */ \nIGroupsData(dataAddress).setNodeInGroup(groupIndex, nodesInGroup[i]);\n        }\ncoverage_0xdb799386(0x9d6c0d0b2cee97fcadd910d656e9aa1164d8b390bb861f3162f07560abfca59f); /* line */ \n        coverage_0xdb799386(0x00083b8378c3f1eae55ba4506936e6934f3f52eaec74f505bd032d7ee05e0c95); /* statement */ \nemit GroupGenerated(\n            groupIndex,\n            nodesInGroup,\n            uint32(block.timestamp),\n            gasleft());\ncoverage_0xdb799386(0xea9a3e8d1bf7b7410d53fc97078344f96bf472a22b121aea8577e43d399c2db3); /* line */ \n        coverage_0xdb799386(0x768b6aad5358da202de79e21820e04f39e292e393122057b8c08a6202892b14e); /* statement */ \nreturn nodesInGroup;\n    }\n\n    function median(uint32[] memory values) internal pure returns (uint32) {coverage_0xdb799386(0xda8d9b5b141bee969ac4475f26a7ccc0678cf85284a6fd43dc80cfee06775d7d); /* function */ \n\ncoverage_0xdb799386(0xeae431c52f336f9f2c861b4dbcb3e056d7cb6e4c70ac5426d36a594a2e2c6598); /* line */ \n        coverage_0xdb799386(0x03f566b2726e7401861e048686772f76ba07f5aaf430e99fbf604f053edf17ba); /* statement */ \nif (values.length < 1) {coverage_0xdb799386(0x6210d94a9ca584f7b829ffbe4b415bbb2038b50cd3d291bc2e8a629d3cdbb590); /* branch */ \n\ncoverage_0xdb799386(0x0b40f235e60021b0132d7e03a3e097ee10a29de8e3b4487f1ecf9ae815c95649); /* line */ \n            coverage_0xdb799386(0x41f156dcf518405d72186b668d11864c5d4f731521f5488a8ab2a46dbd548e42); /* statement */ \nrevert(\"Can't calculate median of empty array\");\n        }else { coverage_0xdb799386(0x48d30222df3112ff7c01ae4b977164747c490b12885e6e4fe72ab83fbeecbc2e); /* branch */ \n}\ncoverage_0xdb799386(0x3724ad30aacd53bb474ce1f5b7798ee25bb584bc7a19a3cf012d7b19ddab3ccc); /* line */ \n        coverage_0xdb799386(0x517c2e2cc25b4daaf5d57ff70fd1e34662139415fbb685bafc6f9e855a571da4); /* statement */ \nquickSort(values, 0, values.length - 1);\ncoverage_0xdb799386(0xb0f7ece6847a60e50b2d1f79964ae35682f0ed13a20524321316301a1ea35110); /* line */ \n        coverage_0xdb799386(0x5e67021348f110d112ca02d0971c09a78ba77192873c4039b458d00b1508adad); /* statement */ \nreturn values[values.length / 2];\n    }\n\n    function setNumberOfNodesInGroup(bytes32 groupIndex, bytes32 groupData) internal view returns (uint numberOfNodes, uint finish) {coverage_0xdb799386(0x597e2597d580bc267dcb79fa44c1a64c49ff4727b2166ca8609cfefe3718fa4c); /* function */ \n\ncoverage_0xdb799386(0x03658338be971f84ad5fa74e4bc9402cd72a7fdd088c9e4b3737b74fbb52e612); /* line */ \n        coverage_0xdb799386(0x2b31ff367e94be904658e7af6e09b1bcbfbc65680c0c5be7c5a9c270482baf52); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0xdb799386(0x1f75080dfbab4a1906c8a550c34d98e4adecc9e6a2a2ad1e2073393d3a7d6de8); /* line */ \n        coverage_0xdb799386(0x2ca894b242e1ddbbb5abbf3cc16b33a386fa8570d179b19417579d156ebe1f02); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0x2887dacb5c5e08738479e33e4ce4905e6fb893658ccd56e91529a70a5db21c35); /* line */ \n        coverage_0xdb799386(0xeaecc347d35554d0e01f23d7854309846eb8206b508642502842d275f988e25f); /* statement */ \nnumberOfNodes = INodesData(nodesDataAddress).getNumberOfNodes();\ncoverage_0xdb799386(0x56815328d96b299f6e30be313e20a1101e63ec70cb2731c929514e7dd5c9c1a3); /* line */ \n        coverage_0xdb799386(0xbbb1e1aadeed05b90b4e2fc00548d5a71e74d28ef65a09783c1f55a4a3b21a41); /* statement */ \nuint numberOfActiveNodes = INodesData(nodesDataAddress).numberOfActiveNodes();\ncoverage_0xdb799386(0xfc2aa6961ea0a39344d25ed5642b7992bb967180b24d38c650410c2acf654239); /* line */ \n        coverage_0xdb799386(0x4fb5abb08b26306cceb5a4f17e4fbd305fbbb0ba6299062fac207093cfe5b815); /* statement */ \nuint numberOfExceptionNodes = (INodesData(nodesDataAddress).isNodeActive(uint(groupData)) ? 1 : 0);\ncoverage_0xdb799386(0xbb1ebc531e492ef538a535b2bcd9caa95b4a3728d92363f422ffdd767cfdc6d0); /* line */ \n        coverage_0xdb799386(0x9695f7175d44caae2af1f24b27e97f99db90cd3af709bea6ac2339a3c223e939); /* statement */ \nuint recommendedNumberOfNodes = IGroupsData(dataAddress).getRecommendedNumberOfNodes(groupIndex);\ncoverage_0xdb799386(0x66981df1eb0b899a043f39ea882ad1bc12a4efaa18eed86f4373f501e54f557a); /* line */ \n        coverage_0xdb799386(0x6dc8da3c6f1642429432dbec46bec8865a4fc916c9dbb42f5a20dfbaeadcec05); /* statement */ \nfinish = (recommendedNumberOfNodes > numberOfActiveNodes - numberOfExceptionNodes ?\n            numberOfActiveNodes - numberOfExceptionNodes : recommendedNumberOfNodes);\n    }\n\n    function comparator(bytes32 groupIndex, uint indexOfNode) internal view returns (bool) {coverage_0xdb799386(0xe227814983f9f239012d7f11ca3113a97061517e7dd87f91b891c8f29ad0401c); /* function */ \n\ncoverage_0xdb799386(0xb6fb9101c809c3c1313bfac337799ddd41bd88c1212d7fe0d3d5fdba33828ef4); /* line */ \n        coverage_0xdb799386(0xa85a05ef10860c09e9f2e1d1ed3ee898d5fce913afcbf84b8781cb44a6c4932a); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0xdb799386(0xa9acf277a02a04909b46bab8022d58ae476c91e9fca17538178d53a831a49a58); /* line */ \n        coverage_0xdb799386(0x6ea73b6ac30143d6bef92673cc14ea99ecdb7bda5b96b077aeb529f6374e18ae); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0xf53be6ccb9b570b5ea1b4ab473e41c6d455e51ac011e8d80b8e87a73a4637537); /* line */ \n        coverage_0xdb799386(0x5079e3544ef971cfe0f390b473ecc61098d54f9d4136b9f72b6fd11ffe1bfcb1); /* statement */ \nreturn INodesData(nodesDataAddress).isNodeActive(indexOfNode) && !IGroupsData(dataAddress).isExceptionNode(groupIndex, indexOfNode);\n    }\n\n    function setValidators(bytes32 groupIndex, uint nodeIndex) internal returns (uint) {coverage_0xdb799386(0x3987a79bffaa3b80f1a97ac874c5078e7290b56282b3a08d7451807647bf69da); /* function */ \n\ncoverage_0xdb799386(0x57d461d8b95736e5d397bb2d15ce68f7988488c191b6d215f13056fe226923a9); /* line */ \n        coverage_0xdb799386(0x242cfaa960389de90620435395f1ee883598753838078ce443a859e0048af6e5); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0x7c04efb30026b58020f6a91dc1d2548c554595f4e56645618ee28d0766000885); /* line */ \n        coverage_0xdb799386(0x9478404d09cefe9a81aa9777f30702a5d7804b4ac24c1ccd1f31f49fe2263ded); /* statement */ \nIGroupsData(dataAddress).setException(groupIndex, nodeIndex);\ncoverage_0xdb799386(0x449796b8874a573a2f0f9df0551e4fe60292a322b5e0f9c581e6c1b28ee4d62b); /* line */ \n        coverage_0xdb799386(0x815c1bf925e6e5f3a71e5275b9077a31111a4c332aeab549a09d31866fff9be5); /* statement */ \nuint[] memory indexOfNodesInGroup = generateGroup(groupIndex);\ncoverage_0xdb799386(0x28f577388dd718715783c6074571fb1b91806101551869f29acaa5ed58eb7988); /* line */ \n        coverage_0xdb799386(0x59d48ac98c9e38547efa7313d992140b76cd83c3eff25c5e3af4dd11df6aabd7); /* statement */ \nbytes32 bytesParametersOfNodeIndex = getDataToBytes(nodeIndex);\ncoverage_0xdb799386(0x94e88817a2f81921cce1c9a03925bc16187ca13f55dd95cc82469edc97246185); /* line */ \n        coverage_0xdb799386(0x0b4761e08cd4b9988246efd152f61af7a43c5a00d7e9e7a2d309ec6348fe3214); /* statement */ \nfor (uint i = 0; i < indexOfNodesInGroup.length; i++) {\ncoverage_0xdb799386(0x69297de224fe860fefb9f862c9077ed784eaa4b61ee69dd78008ea349197eee4); /* line */ \n            coverage_0xdb799386(0xa7dad0cb67e65d4753f36884aaf3eb101c3202a33bcda7461cc0ed2b1e1a9ac0); /* statement */ \nbytes32 index = keccak256(abi.encodePacked(indexOfNodesInGroup[i]));\ncoverage_0xdb799386(0xd4d85718e4b0c1d95804dc9ff85e388aedfedd39e66eea448c5cb2b2087a2fa7); /* line */ \n            coverage_0xdb799386(0x50104b93dcf6afc6daa4b324574e83073b02fa5077315eddf7a89606ae54bc38); /* statement */ \nIValidatorsData(dataAddress).addValidatedNode(index, bytesParametersOfNodeIndex);\n        }\ncoverage_0xdb799386(0xda37aad60a2917d22084499dc9d0c2cb41c20c9bb0ce0ce385d3bf3bdcf4b960); /* line */ \n        coverage_0xdb799386(0x5d9a1a88f4a5bc961e0f2cac5c96adae168233ef42243b0bc025e1e48edde3a7); /* statement */ \nemit ValidatorsArray(\n            nodeIndex,\n            groupIndex,\n            indexOfNodesInGroup,\n            uint32(block.timestamp),\n            gasleft());\ncoverage_0xdb799386(0x8c7c160fcdf2045c0c7a1e083377d2a78754e213bd83d1bcc5d58536724900d4); /* line */ \n        coverage_0xdb799386(0x89612df8087a160943b2bb2d37fea7b0274e5d936cb0f6488a618eb7652ef6cc); /* statement */ \nreturn indexOfNodesInGroup.length;\n    }\n\n    function find(bytes32 validatorIndex, uint nodeIndex) internal view returns (uint index, uint32 time) {coverage_0xdb799386(0x05cc50fd3592370c5cc1bac982f74ae82c70ae31510631cee38e6e01e1ade3f3); /* function */ \n\ncoverage_0xdb799386(0x8ff84ff45558a0e019d909b25e49219b67fcdcb1f6b1d327e545402a2ba4258a); /* line */ \n        coverage_0xdb799386(0xd18d0088a6d00c0e24e146111e381a07f3f02119f3a9bb63ede378ca4f71dda9); /* statement */ \naddress dataAddress = contractManager.contracts(keccak256(abi.encodePacked(dataName)));\ncoverage_0xdb799386(0xee95a077d9b0a0e3efaacbb70f51bf60d26aafbf5c4ad877c96b96441c24990f); /* line */ \n        coverage_0xdb799386(0x1b07b28d44af013e85eff7c5c2b8e771107353ed92284b45753573e37be8af3d); /* statement */ \nbytes32[] memory validatedNodes = IValidatorsData(dataAddress).getValidatedArray(validatorIndex);\ncoverage_0xdb799386(0xf219b811e170a429415ff2aea41dcec63e25e5c102946c76b1c73bb59dfebae1); /* line */ \n        coverage_0xdb799386(0x9f0db16bbb1902577ccdd4d7583e90cced1fa59dafa2381728506a305ee7aa4a); /* statement */ \nuint possibleIndex;\ncoverage_0xdb799386(0x62cb5cde7676cc63af484218ca4de86f4777d7bca3a1cc7c7f5ac0fefea0e513); /* line */ \n        coverage_0xdb799386(0x08390c7539ceaf94d899667a9a4f28f44a21768ccfacee5d90adb68adf548397); /* statement */ \nuint32 possibleTime;\ncoverage_0xdb799386(0xa7b0afd7f3c378f98c66ba3af7fcdb034aeddd9f9eb1b94d57a93d7f62a85832); /* line */ \n        coverage_0xdb799386(0xf1e53b2d815b110e5e5bb6cf6521eb684d76daa1baa440166af610667e4c0a33); /* statement */ \nfor (uint i = 0; i < validatedNodes.length; i++) {\ncoverage_0xdb799386(0xfae7ddc173087fd0ba5f46002ee261c5005eb32b5996530bdf1f5b4279107b0b); /* line */ \n            coverage_0xdb799386(0x970ae284cef7bdef3d172d8b5115459b4e2487d99f4db2e53929caa3da0423cb); /* statement */ \n(possibleIndex, possibleTime) = getDataFromBytes(validatedNodes[i]);\ncoverage_0xdb799386(0xd508fb6cd7012b6d7a94fd4978e342e439f1eb622dfdb547810f77d50b04a0b2); /* line */ \n            coverage_0xdb799386(0x8f72a66dccffc950dc3896ef0c9e7a31621740590f6ce95dc7304828faada578); /* statement */ \nif (possibleIndex == nodeIndex && (time == 0 || possibleTime < time)) {coverage_0xdb799386(0x5bd4cfb340a1a5c4a0ca08657a641240d19a311d199dd7025a52f3d469114b3e); /* branch */ \n\ncoverage_0xdb799386(0xdb2272c62d8f95f9d0dbc8c361374279368f033a80d805021f0dfa687bb28b5b); /* line */ \n                coverage_0xdb799386(0xb7117101b096fa2f957c7d99abefb814af456703c0cd0ae2a78aa3287d701cab); /* statement */ \nindex = i;\ncoverage_0xdb799386(0xa44e5529347f732bb7f3395282b373b6cae5bf53a560f10897646449b44b16a1); /* line */ \n                coverage_0xdb799386(0x34bde6f19a242f1ee062c84a3cdb7dbe9a706bf5c33d606b867a6824e4b13e79); /* statement */ \ntime = possibleTime;\n            }else { coverage_0xdb799386(0x00813bbdcebb12bf0042b2d7b052f792f78d1ba76dce1218de7e39a1e807b19f); /* branch */ \n}\n        }\n    }\n\n    function quickSort(uint32[] memory array, uint left, uint right) internal pure {coverage_0xdb799386(0x3d9bf1c8d2a9744fbaec41ace74ef4ddb1af0f5ad0c8d24fbeb4b9f8d3e7e40f); /* function */ \n\ncoverage_0xdb799386(0x790a17bb2d87519070b496fb72b8c53482f5bf70795709bd70c38fce75538f54); /* line */ \n        coverage_0xdb799386(0x7deccc7471714aea8bce222ad3912bad0cf0af9bb96796701f96fc103332fac1); /* statement */ \nuint leftIndex = left;\ncoverage_0xdb799386(0xecdf1c9227e15b5f14e26169d566bd3da868ed5c3234a0006321233316410b29); /* line */ \n        coverage_0xdb799386(0x2e0f3e8ba907b20fbe7607ba3e6ee83bad96bbae72e5a1056ad0d04588ca9ee1); /* statement */ \nuint rightIndex = right;\ncoverage_0xdb799386(0xdfc9b9a4e6fb4adac5ffb2824aa223fbf7f71eb2f3ea4cdbdca673314b212dc4); /* line */ \n        coverage_0xdb799386(0x34d3cc64dcc515d118924da173990f13b4ac4eecceedc1c7c45bcc0239767b9b); /* statement */ \nuint32 middle = array[(right + left) / 2];\ncoverage_0xdb799386(0x776bc5530669b98d8a3794d1877c8044d774c0a977f26c725d0e798ccb3c3f49); /* line */ \n        coverage_0xdb799386(0xa9825d02f20ae50bb8b925ff2f2d0e4c7f6bf011322d9dcfbbbe538855059479); /* statement */ \nwhile (leftIndex <= rightIndex) {\ncoverage_0xdb799386(0xfe5071a54f8207bc48c6408331ba613c938d64ac82fcd99d4bff1b78e6c2b1ec); /* line */ \n            coverage_0xdb799386(0x633886d58c532b90f6b1b49a711f13d1e289c168e437ba173aa5392e4e32fe60); /* statement */ \nwhile (array[leftIndex] < middle) {\ncoverage_0xdb799386(0xa71d7f61ac4708aba00b582b4924c9a8e3b6c48af81e6454446add12c37bf0b2); /* line */ \n                leftIndex++;\n                }\ncoverage_0xdb799386(0xd5dc903a68dad175c010c13bce32e51fced873b2e62f97c488912091e8047651); /* line */ \n            coverage_0xdb799386(0x955771cdc36a469630783de3c61225a48a8f3d48b71e2874563714165b650b2c); /* statement */ \nwhile (middle < array[rightIndex]) {\ncoverage_0xdb799386(0x3cff3b729fe1720eb455ed0fd8f489fbbdd1f157f4492fdedb0203bd5ce8705c); /* line */ \n                rightIndex--;\n                }\ncoverage_0xdb799386(0x0afe68caad3826cf30794070f24653097fd291289e74d1f998c9bbe0c9960bff); /* line */ \n            coverage_0xdb799386(0xeb6552692375bb27fec8839d534f36c11dc5bc29c9f3ae826185fba769e76b06); /* statement */ \nif (leftIndex <= rightIndex) {coverage_0xdb799386(0xc763f69a5044e7603b088d6cf0c1411fa038d9d1b82759d6cd4af82b555f2366); /* branch */ \n\ncoverage_0xdb799386(0xb38eb608ad572f0b5228575655b95b77a84336e8431a5f75f62b968c98155463); /* line */ \n                coverage_0xdb799386(0x4af950c75e4069a8680a63f02b2948b256a81a4468df24828a37b06af414da8d); /* statement */ \n(array[leftIndex], array[rightIndex]) = (array[rightIndex], array[leftIndex]);\ncoverage_0xdb799386(0x2425db648883230a259529d6c4d02880214b41066c8158cde1c9f8b8084e745b); /* line */ \n                leftIndex++;\ncoverage_0xdb799386(0xd18d8608fad54569852d4cbfd55a0e5b3d9597cf5280f1bbdf1019570c4c1004); /* line */ \n                coverage_0xdb799386(0xad57b1ef093c9a28e2886bc7d6816f2ecc5f435ac9104d6ff1144bc0c36ed75b); /* statement */ \nrightIndex = (rightIndex > 0 ? rightIndex - 1 : 0);\n            }else { coverage_0xdb799386(0x3af9d349c5a1885d379d7bf3f811910e44ca0326292d27b6e6c02688e438790f); /* branch */ \n}\n        }\ncoverage_0xdb799386(0xbcd1a5a4d70a896eeddeceffb88dda042722a266d914681ddbd66b7c04c4634c); /* line */ \n        coverage_0xdb799386(0x2630dfd413506f55ca1cfc4839e57410bdca2d9ec745f4ab575c47f1e9b35fb4); /* statement */ \nif (left < rightIndex)\n            {coverage_0xdb799386(0x1233731e3a35d8c5ec7c633f36767f23e16897c3798b8aadeb3f187a95e52aad); /* statement */ \ncoverage_0xdb799386(0x39edc5a2243d873edafe5b336ee395406a15127794f90da814dd9615317cbeae); /* branch */ \ncoverage_0xdb799386(0x341441cd162f3719042bfb63fd864c2ae672a4ca55fe1c0a70e617f228241898); /* line */ \nquickSort(array, left, rightIndex);}else { coverage_0xdb799386(0x3032716a313f328a71cf703f5c6cbd73b6a83b95e4850779c04808763502d3e8); /* branch */ \n}\ncoverage_0xdb799386(0xed1a67a297d3ae580017edd88d65e3525c901e6731d8e98a26057255601c9ffc); /* line */ \n        coverage_0xdb799386(0xe8fada8ce4a506ac4a0dc559ccffc97a604640b3d44ff0bc0f565933270e1057); /* statement */ \nif (leftIndex < right)\n            {coverage_0xdb799386(0xd1cc6ae6fe56e82653604898b44a79311664e91811a25ab7964634601c5fe32c); /* statement */ \ncoverage_0xdb799386(0xd9b356e03c8d3d8e199a45bf628532d9066fa165fbd53b0eff306dcdd9e82514); /* branch */ \ncoverage_0xdb799386(0xe1b9306fbc9969de7a02945d10cacd637fdc526e0abc343d09d3554be6907f23); /* line */ \nquickSort(array, leftIndex, right);}else { coverage_0xdb799386(0x0c59c7cbd5742f005941e7556ba8eaf704c736f8106e0c7439456fbeb03288c4); /* branch */ \n}\n    }\n\n    function getDataFromBytes(bytes32 data) internal pure returns (uint index, uint32 time) {coverage_0xdb799386(0x576938cd38a1c70436dbb12062617d725a8efa11be0dc2f1331e27b82ed12fc3); /* function */ \n\ncoverage_0xdb799386(0x4f3677ee132c2bbabc9586ef1c68984dcddc87623056603e6b9694ccd2f1e2e3); /* line */ \n        coverage_0xdb799386(0x784763a1bd6262fee0963de9d2bc0ac32831086d50d78c0604ff9db2287c8e89); /* statement */ \nbytes memory tempBytes = new bytes(32);\ncoverage_0xdb799386(0x904907572d50e8e1d3533d8a2f84d18ee44f28d3d98ff4794cd6e8941ca3bf9e); /* line */ \n        coverage_0xdb799386(0x3bec665cd8e4c9436d05346c66fa54ed964ddcb9780a61f0d99228597216cdd3); /* statement */ \nbytes14 bytesIndex;\ncoverage_0xdb799386(0x414187492d753ed46a522d8a622eb7bdf5fb3dd6c255ffcee1ef5fbe84087a31); /* line */ \n        coverage_0xdb799386(0xe3b9871457e6bff20e23e891bbf1853c1f8a5757cb16403cae9bcf41f1466848); /* statement */ \nbytes14 bytesTime;\ncoverage_0xdb799386(0xcfaed079adace342211f96dee76e4b73b95fc962e8f2b8ea4990858a7366ed21); /* line */ \n        assembly {\n            mstore(add(tempBytes, 32), data)\n            bytesIndex := mload(add(tempBytes, 32))\n            bytesTime := mload(add(tempBytes, 46))\n        }\ncoverage_0xdb799386(0x045625b6521633ee6c36c830e00bc9ad57420c4b007661a46b4696e695df0c0d); /* line */ \n        coverage_0xdb799386(0x455d75a25b30cc30c875e581be6ad28a6aa5d9d4277c8e8912008c629583d3b2); /* statement */ \nindex = uint112(bytesIndex);\ncoverage_0xdb799386(0x6533896d27034d0664c0797430322f9d019454455306845ee6fc35e0d1d98fd5); /* line */ \n        coverage_0xdb799386(0x1af5cc1375ba0a39879a4cfac80799a58bce05fe138fd0526a1717b57a2b23e6); /* statement */ \ntime = uint32(uint112(bytesTime));\n    }\n\n    function getDataToBytes(uint nodeIndex) internal view returns (bytes32 bytesParameters) {coverage_0xdb799386(0xbade6e6491424ac7181c89522aedfb9a95c7d0b9fbb53589f6d5230ecb654b4d); /* function */ \n\ncoverage_0xdb799386(0x9b5b83e9f07b1b4f1ae982efddac28aea306e3e5359e51d9c2e790529b2eeeae); /* line */ \n        coverage_0xdb799386(0xa0ca45acfd5188a655a7914b8b8f5d625f7740fe59b9d5e69e619ac816de9eac); /* statement */ \naddress constantsAddress = contractManager.contracts(keccak256(abi.encodePacked(\"Constants\")));\ncoverage_0xdb799386(0x383059935205358e86789a1e7136d3d06783676671f509b171a7d7341607af84); /* line */ \n        coverage_0xdb799386(0xc508db4d9a79ea046a8427d1e755076df7110ff4fc0599ad5f0262a5d06c4495); /* statement */ \naddress nodesDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"NodesData\")));\ncoverage_0xdb799386(0xb7a05a1ae043a2ff6c92db105026a3a9504cb342fd3f61761d2604f75fe418c6); /* line */ \n        coverage_0xdb799386(0xe8d27fb1006ab71172ccd6c83e508148bdb9bacc98fbbef749fe12211670beed); /* statement */ \nbytes memory tempData = new bytes(32);\ncoverage_0xdb799386(0xbdc475b730eb0c77b75581a3e18c66a30c4c2a103bc7f81561df1c117ff8b70b); /* line */ \n        coverage_0xdb799386(0x055b504e5a1d4a065aad309f6dc8f1b5c3f9e0534cf50185434743c1fda53439); /* statement */ \nbytes14 bytesOfIndex = bytes14(uint112(nodeIndex));\ncoverage_0xdb799386(0xdb79f03e1b57ae734d452e4c6f7f595264b5771f63d23b426b0cb1a9ccef0ab3); /* line */ \n        coverage_0xdb799386(0x3697427f14256958a74e016f2feea59409a9562fa793cc7c1354a46288fc0063); /* statement */ \nbytes14 bytesOfTime = bytes14(\n            uint112(INodesData(nodesDataAddress).getNodeNextRewardDate(nodeIndex) - IConstants(constantsAddress).deltaPeriod())\n        );\ncoverage_0xdb799386(0x9562bee0c0f7494f5e58b652847e700bdb8a1bd9fcb2a1cb0365dbc1a9e58fa9); /* line */ \n        coverage_0xdb799386(0x884228594cd82ce49394f668ef569ef14e0270054443b52c497667b1858276d9); /* statement */ \nbytes4 ip = INodesData(nodesDataAddress).getNodeIP(nodeIndex);\ncoverage_0xdb799386(0x5cd95950269210c984aeb0edd62c439e62e6de7af2a6b83fbe6bc05982f8995f); /* line */ \n        assembly {\n            mstore(add(tempData, 32), bytesOfIndex)\n            mstore(add(tempData, 46), bytesOfTime)\n            mstore(add(tempData, 60), ip)\n            bytesParameters := mload(add(tempData, 32))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    ".coverage_contracts/SkaleToken.sol": {
      "content": "/*\n    SkaleToken.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\n\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\nimport \"./Permissions.sol\";\n\n\n/**\n * @title SkaleToken is ERC777 Token implementation, also this contract in skale\n * manager system\n */\ncontract SkaleToken is ERC777, Permissions {\nfunction coverage_0x412b4656(bytes32 c__0x412b4656) public pure {}\n\n\n    string public constant NAME = \"SKALE\";\n\n    string public constant SYMBOL = \"SKL\";\n\n    uint public constant DECIMALS = 18;\n\n    uint public constant CAP = 7 * 1e9 * (10 ** DECIMALS); // the maximum amount of tokens that can ever be created\n\n    constructor(address contractsAddress, address[] memory defOps) Permissions(contractsAddress) ERC777(\"SKALE\", \"SKL\", defOps) public {coverage_0x412b4656(0x2a21076ba410e55791effedcd3450d9eb7836b5ac7a97b2042f13d0589ebadad); /* function */ \n\ncoverage_0x412b4656(0x0e3c677470e6e15d20d2091f6d767331510dbf2d490477368a7713a4cf2a818f); /* line */ \n        coverage_0x412b4656(0x88f0488caec03c319c805ce4730fc45f5826c80d0ad07b17ae1d48be5a8c2e11); /* statement */ \nuint money = 1e7 * 10 ** DECIMALS;\ncoverage_0x412b4656(0xfadd0a56229eb46c1328e3a300938070ec42c8bc6f1564a598cf1d344f99ac22); /* line */ \n        coverage_0x412b4656(0xdabaecef5e08245fe551a75ca2f26765bc60fa832b5a8a66858af5b6564ff6b1); /* statement */ \n_mint(\n            address(0),\n            address(msg.sender),\n            money, bytes(\"\"),\n            bytes(\"\")\n        );\n        // TODO remove after testing\n    }\n\n    /**\n     * @dev mint - create some amount of token and transfer it to specify address\n     * @param operator address operator requesting the transfer\n     * @param account - address where some amount of token would be created\n     * @param amount - amount of tokens to mine\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @return returns success of function call.\n     */\n    function mint(\n        address operator,\n        address account,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )\n        external\n        allow(\"SkaleManager\")\n        //onlyAuthorized\n        returns (bool)\n    {coverage_0x412b4656(0x6d5ed465864b51712a1d8f0859f09b3f637cfe8715f59adc6795aa5570dd2931); /* function */ \n\ncoverage_0x412b4656(0xb3989980b6169153e7221d9fec2d712482105d2218430a64a7aa1460ba2a547a); /* line */ \n        coverage_0x412b4656(0xa132e60a98cf79c9d4000832ed21bd7976af01fae9091696e801896f4ffdce46); /* assertPre */ \ncoverage_0x412b4656(0x3d8324fd82056f54c01e3ee1335aec72beba61671fe6e0d99d86c9edaf6083e2); /* statement */ \nrequire(amount <= CAP - totalSupply(), \"Amount is too big\");coverage_0x412b4656(0x89109d433cc09803186372ab889c305630591aa9ca1bdc5c51d8d66baf6acf6e); /* assertPost */ \n\ncoverage_0x412b4656(0x92585e7798f64bfa370ff99c388bbe1f0bab3eb5f70648cbcbeb45c7edb60482); /* line */ \n        coverage_0x412b4656(0xf9922205ea1d3dc83ff7d8c4e5134691f59913a9b7bd13e6f0e8d6ee3729c794); /* statement */ \n_mint(\n            operator,\n            account,\n            amount,\n            userData,\n            operatorData\n        );\n\ncoverage_0x412b4656(0x0127fe9aa95021e143073b732bd796ac392a443935a51b1833f3fcb49abcd42f); /* line */ \n        coverage_0x412b4656(0x2a465aac792ec3577b40fe2eb485ffdfb03fbf19bbe1c61b4f3a1c991e6d356c); /* statement */ \nreturn true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../../token/ERC20/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    IERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n    // See https://github.com/ethereum/solidity/issues/4024.\n\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        address[] memory defaultOperators\n    ) public {\n        _name = name;\n        _symbol = symbol;\n\n        _defaultOperatorsArray = defaultOperators;\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\n        }\n\n        // register interfaces\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20Detailed-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external {\n        _send(_msgSender(), _msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes calldata data) external {\n        _burn(_msgSender(), _msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(\n        address operator,\n        address tokenHolder\n    ) public view returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) external {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) external {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    )\n    external\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(_msgSender(), sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(_msgSender(), account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) external returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {Transfer} and {Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address operator,\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n    internal\n    {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        // Update state variables\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param operator address operator requesting the operation\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address operator,\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        private\n    {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[to] = _balances[to].add(amount);\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address holder, address spender, uint256 value) private {\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\n        // currently unnecessary.\n        //require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n        address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n *  their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    ".coverage_contracts/SkaleVerifier.sol": {
      "content": "/*\n    SkaleVerifier.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IGroupsData.sol\";\n\n\ncontract SkaleVerifier is Permissions {\nfunction coverage_0x20c6cd42(bytes32 c__0x20c6cd42) public pure {}\n\n\n\n    uint constant P = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    uint constant G2A = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint constant G2B = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint constant G2C = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint constant G2D = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n\n    uint constant TWISTBX = 19485874751759354771024239261021720505790618469301721065564631296452457478373;\n    uint constant TWISTBY = 266929791119991161246907387137283842545076965332900288569378510910307636690;\n\n    struct Fp2 {\n        uint x;\n        uint y;\n    }\n\n    constructor(address newContractsAddress) Permissions(newContractsAddress) public {coverage_0x20c6cd42(0x118c284c3566fc8b7126867b20973c4dd222fb1cc8ceacd71e73bf9bbcf437dd); /* function */ \n\n\n    }\n\n    function verifySchainSignature(\n        uint signA,\n        uint signB,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool)\n    {coverage_0x20c6cd42(0x143c059c599f8cfbfb6e0623838e3f3d23a17fd89ad3a20b7a30ecd354319701); /* function */ \n\ncoverage_0x20c6cd42(0xa34cb08d0812c71e39380d608948bd3f767777da1c0fa858b006f69940ebd47f); /* line */ \n        coverage_0x20c6cd42(0x0ea5b799ac1a234be6bb5977654b04199892498187e66b7b5fffe49c1494f698); /* statement */ \nif (!checkHashToGroupWithHelper(\n            hash,\n            counter,\n            hashA,\n            hashB\n            )\n        )\n        {coverage_0x20c6cd42(0x482cae97094beb767113a5afe5809540b62b393937a67a5a891d15a0777b1693); /* branch */ \n\ncoverage_0x20c6cd42(0x22fbdd586e730ff20032d21c2b2a3bf76dae6734d685404b9f60112944930073); /* line */ \n            coverage_0x20c6cd42(0xfbcf85346ae42649a911f87bb92e3c39ffc8f62a52cba87d15858f2e52e42738); /* statement */ \nreturn false;\n        }else { coverage_0x20c6cd42(0x0035591cbbf9bfaec80ea99c605fdaa8d807f2ffb88d6f6423d4ee00c126dee0); /* branch */ \n}\n\ncoverage_0x20c6cd42(0x2af6fe301bf9f5aad2f6c4338c527f5519bd3591b5f93709b1a2146cc0490457); /* line */ \n        coverage_0x20c6cd42(0x7c93d7b50223a110d68a8b3c2a8f36ed77336b75376255947ed5586085051dc2); /* statement */ \naddress schainsDataAddress = contractManager.contracts(keccak256(abi.encodePacked(\"SchainsData\")));\ncoverage_0x20c6cd42(0x4c1873d8341c38b45067b10911ee0fb9ef37304f96f2ad7f60fc2cc2c045db7a); /* line */ \n        coverage_0x20c6cd42(0x42068fe7ed6de9ea8b975d4c2056e41232a7efd742315dd0a2945a0cb6dadfdd); /* statement */ \n(uint pkA, uint pkB, uint pkC, uint pkD) = IGroupsData(schainsDataAddress).getGroupsPublicKey(\n            keccak256(abi.encodePacked(schainName))\n        );\ncoverage_0x20c6cd42(0xb2c150d0b83b479fb1ffc225f3be7804c80577aa5c7b0290d6c580c051fd0f8a); /* line */ \n        coverage_0x20c6cd42(0xdd3a054b6a53ed811b60c767cbf10da2b3f227b431244e562ed5ddaad3f75d9d); /* statement */ \nreturn verify(\n            signA,\n            signB,\n            hash,\n            counter,\n            hashA,\n            hashB,\n            pkA,\n            pkB,\n            pkC,\n            pkD\n        );\n    }\n\n    function verify(\n        uint signA,\n        uint signB,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        uint pkA,\n        uint pkB,\n        uint pkC,\n        uint pkD) public view returns (bool)\n    {coverage_0x20c6cd42(0x4da6c0dceaaff43c7125488954ddbe3fa7f49f9c92f2d98b5b67568e6058517e); /* function */ \n\ncoverage_0x20c6cd42(0xbb5eb9bab693260d7a8442e73f872bb21b1f2813dc2eda9bf7cd39856bb36365); /* line */ \n        coverage_0x20c6cd42(0x3df9d53916102a6245617b41cd6ebc537823c317ab135e5aa5afe4f6aec1acdb); /* statement */ \nif (!checkHashToGroupWithHelper(\n            hash,\n            counter,\n            hashA,\n            hashB\n            )\n        )\n        {coverage_0x20c6cd42(0xf61c1e616f744ec418b4bb14f90cdbc20fe5a6c436f80f5fe8f6933521b74b71); /* branch */ \n\ncoverage_0x20c6cd42(0x62108339cb3ba922e3002f893f9070e38cf5a2db5a2d5be1d96326002a8fb811); /* line */ \n            coverage_0x20c6cd42(0x0aa45f220e54fb90165c909688ed453e78aec1a44d1c1c45fcbad875da2222fe); /* statement */ \nreturn false;\n        }else { coverage_0x20c6cd42(0xc476da5dce0d149bf6e504d9812e68adba3a4a233858909468b8835f01e855d3); /* branch */ \n}\n\ncoverage_0x20c6cd42(0x9ca09c4babcf6c229c6256357b2f699e1bb57f82f5955d0e7646866dd138fd6e); /* line */ \n        coverage_0x20c6cd42(0x4ad31606b9748baf0a331a96351be107c8282755677925a041652a511ea50fa2); /* statement */ \nuint newSignB;\ncoverage_0x20c6cd42(0x812e133056b65502ce4a4820009ea101fd958934625ebdb7aaedb0efe958e556); /* line */ \n        coverage_0x20c6cd42(0x8abbd5b691a0986102379064dd433aacc0c584ee6de939c0fb31ce9fdbb54131); /* statement */ \nif (!(signA == 0 && signB == 0)) {coverage_0x20c6cd42(0x5f1ed13f80921bc51d9314d003991d132385244a5941f7889f26c8227e650d76); /* branch */ \n\ncoverage_0x20c6cd42(0x84ceb75bd86549e182b35606fd4bf1435a1b0f8daf453f92415d3825ff6537b3); /* line */ \n            coverage_0x20c6cd42(0xcc35f86fb5cb7b3a8a6f78d21aada01cd2a556e3353cb3d2497bf5dbe95d209d); /* statement */ \nnewSignB = P - (signB % P);\n        } else {coverage_0x20c6cd42(0xbb8ec62efe54dcf74a5b0491006ba640260ed0f7482eb512b2f4f833b95069ce); /* branch */ \n\ncoverage_0x20c6cd42(0xe2940c16a441e4b1c1cc37a4de5a4c52b396186dae9cbdc9815adc46a5ce9bc8); /* line */ \n            coverage_0x20c6cd42(0x64f83f305a762940893a611ac799bf01858b53f306a37fb0e8cb7e94d6782d0e); /* statement */ \nnewSignB = signB;\n        }\n\ncoverage_0x20c6cd42(0x39ce27de5843857fb211521a647e7f3aa16484eabd32aef70ae8a69cfa725763); /* line */ \n        coverage_0x20c6cd42(0xe9f813d81572082daf682460d94eadd4f0dac3e401e270f19844b958e19d658d); /* assertPre */ \ncoverage_0x20c6cd42(0x922e88be7d94d95408f8fe4cef9317a4f073a46d69d243e7c1363fed346d6b65); /* statement */ \nrequire(isG1(signA, newSignB), \"Sign not in G1\");coverage_0x20c6cd42(0xe41a4fa400e1bdd1dc957bc5b9c9eca0354b1a253b9dcc17852b57367f1fb477); /* assertPost */ \n\ncoverage_0x20c6cd42(0x6f0ce373c42566565b5c09d36944f2758ce43b1410f940b62d9750adf88a1606); /* line */ \n        coverage_0x20c6cd42(0x3446b1769d7373c74c9ae3a161bb37744ec2a6a22945559fc56c7d87b1f0b9ff); /* assertPre */ \ncoverage_0x20c6cd42(0x0048ea53c1132953f5c88ac63346086c94af7f098cfbde7acb4d8882b87e51a5); /* statement */ \nrequire(isG1(hashA, hashB), \"Hash not in G1\");coverage_0x20c6cd42(0xc02e860c869c5489cd868dd38663aa0fe40942c83d02320df7424febd0cd6ca0); /* assertPost */ \n\n\ncoverage_0x20c6cd42(0x4d9f984499030f01bde85fa77bc2ccf526322357655026d828fbea9e0c912888); /* line */ \n        coverage_0x20c6cd42(0x887e1d9a1ea05159b1bb9989255752d8bb1552863d8b0c2e2ea8d987b045f0b2); /* assertPre */ \ncoverage_0x20c6cd42(0x175bfa2014c11690b1a8769d2335125c8ec01cee2ac57f0dcd9caa524fe8066c); /* statement */ \nrequire(isG2(Fp2({x: G2A, y: G2B}), Fp2({x: G2C, y: G2D})), \"G2.one not in G2\");coverage_0x20c6cd42(0xedd3018fe35f25d96b740d7ab57b69fed778793f4afc26e51e6fbd28730ab2f7); /* assertPost */ \n\ncoverage_0x20c6cd42(0xe913726b4416ec7ebdba8cba7581d874021814d8ec3cba46877bf374bb292f79); /* line */ \n        coverage_0x20c6cd42(0x2fb4f10117d0d818022b8f104f1e7ac12d640c5e2895c427efd032ccd1fe4c0d); /* assertPre */ \ncoverage_0x20c6cd42(0xfc6a6f130c76f2c807433aab6f99c26522202440ce9b566b1911ebc5e5e986a0); /* statement */ \nrequire(isG2(Fp2({x: pkA, y: pkB}), Fp2({x: pkC, y: pkD})), \"Public Key not in G2\");coverage_0x20c6cd42(0xae67d284fa26436d41b8db302f17efafc76d14ec6b6a901a706b4ad2bfd1f91b); /* assertPost */ \n\n\ncoverage_0x20c6cd42(0x98fefaa6f92fb9f2aa20e1aa51dec95286777e12b35d936cb26704c6678f3a22); /* line */ \n        coverage_0x20c6cd42(0x1b7c87feb0f198efdd978ccfabd53c7fa963cfeededde8d165683759c0dbdcd8); /* statement */ \nbool success;\ncoverage_0x20c6cd42(0x56ecafab7f6ee5bdce30aba48baf04192c71bf09c59e095d990fc3fc2e7d457f); /* line */ \n        coverage_0x20c6cd42(0x9b944a22766f2089228a3b8314d7c281c0cd766e70ae036dfa1a3e606a5dc1c4); /* statement */ \nuint[12] memory inputToPairing;\ncoverage_0x20c6cd42(0xfbda5e78e1f21586a7cbf6eb5df1a2af3fd830dc8ea722086df91be65b367573); /* line */ \n        coverage_0x20c6cd42(0x9517bf64be4332c5ee484320450b242c5fa6213d4403e86929b7d32882ab7d6a); /* statement */ \ninputToPairing[0] = signA;\ncoverage_0x20c6cd42(0x7a2511327386c16712fcacd4102f5524e79dcf463e9a7aee2a61306c2e9717fa); /* line */ \n        coverage_0x20c6cd42(0x22e25e2bce46fc9754cb420d379a9f65bbf4047ec3d90219e3353827667635ec); /* statement */ \ninputToPairing[1] = newSignB;\ncoverage_0x20c6cd42(0xf29236cdf288682bebf09d1266f4f774f3dc09148f82ef64bff046216f5d3b8e); /* line */ \n        coverage_0x20c6cd42(0x4781d9c34e6a67b1de87dc7281dc3e2abf06f0bdc39e50bf3e581d9e8230842f); /* statement */ \ninputToPairing[2] = G2B;\ncoverage_0x20c6cd42(0xbf947cebb14b5406fc5250f65b9ad64127c7f978514b6e1eff38b0356e69cd50); /* line */ \n        coverage_0x20c6cd42(0x18570a08a73af731830585f48a2bdcffd9ecaac4b60fccd1025b66a54a2aea2d); /* statement */ \ninputToPairing[3] = G2A;\ncoverage_0x20c6cd42(0xc36303669be66e79ba5cad02f63ad5feffbfae755695c33ee1836cb4992ba5f3); /* line */ \n        coverage_0x20c6cd42(0x840b14d3f466e702d934892b5026eeca223dae98687bff3e60427200e15d1e01); /* statement */ \ninputToPairing[4] = G2D;\ncoverage_0x20c6cd42(0x033546e41c5ff6d18031756f51bfa828dfad983d5d0234711aed95c70705e706); /* line */ \n        coverage_0x20c6cd42(0x7474084f955a9f83436619b7627114add19c8523a95e055d8b57069e47bcaf09); /* statement */ \ninputToPairing[5] = G2C;\ncoverage_0x20c6cd42(0xcd7705c521899254c78bbc7a9f3bcc0d56b0f62be5541750de81bf76a3c05cf4); /* line */ \n        coverage_0x20c6cd42(0xb5ff053faa12e0d3a8d326d0a691a7ddb569dff63814968b8f1fc853e1b91c4e); /* statement */ \ninputToPairing[6] = hashA;\ncoverage_0x20c6cd42(0x46a9a9cd2a8b52c896261363eff13f1c37ed5a040af96d41d00af4ce4d4c2175); /* line */ \n        coverage_0x20c6cd42(0x0c7dbbda06ac298cd923bf698ee76d9c716d4c217674203892ea678031e172c9); /* statement */ \ninputToPairing[7] = hashB;\ncoverage_0x20c6cd42(0x16227358649d6d6fb92a7dc6c98aa789a93cebd40ffa986241e100bebfe70e13); /* line */ \n        coverage_0x20c6cd42(0x4723f81f7af0103cc82e89a3d588ecb95b7e691c86d67e748fede381978b96e6); /* statement */ \ninputToPairing[8] = pkB;\ncoverage_0x20c6cd42(0xef0bb15a34d60c902cdc97848db335ff4a4235f13f438d5b08daa7932eb34c93); /* line */ \n        coverage_0x20c6cd42(0xa74d4dc9bf9c884d772db2542399606079164a63db64a16a095a668bb8f46881); /* statement */ \ninputToPairing[9] = pkA;\ncoverage_0x20c6cd42(0xf156078f8d204124b482172a5c919b7505639ce9b12fa5112cd0fd51824c81c9); /* line */ \n        coverage_0x20c6cd42(0x037f4dc0e8dd4591cdcdbe5de95104cd8b6afa588b24fc535b4f2196dd8d6f7a); /* statement */ \ninputToPairing[10] = pkD;\ncoverage_0x20c6cd42(0xc5428e07e662e27b1ef85efd38abff3a1aa2416b2fa08067c663e63e78948bf4); /* line */ \n        coverage_0x20c6cd42(0x6997330212309f0a996680024975b6ab18d16c75f781343444b9da5ea8c283bc); /* statement */ \ninputToPairing[11] = pkC;\ncoverage_0x20c6cd42(0xf69482edb97392f08d31e0e13200b97815c7cde3b0795c7c7527f3e029c3afc9); /* line */ \n        coverage_0x20c6cd42(0x5e143df715fb96929d09d491b8a46c694906411cf8869080ff7e6297b4a89c76); /* statement */ \nuint[1] memory out;\ncoverage_0x20c6cd42(0x7a8efdaac5f40e8d325a923475a94234f57959977ea9ab6f8779694c76f1e93b); /* line */ \n        assembly {\n            success := staticcall(not(0), 8, inputToPairing, mul(12, 0x20), out, 0x20)\n        }\ncoverage_0x20c6cd42(0xe069dfce46c3f0109bf13f7eb60cb7247446083ddccc72d9e49a7f7c3991fbcd); /* line */ \n        coverage_0x20c6cd42(0x9edb73d6eae13f2f0708fbb85b03b07372b041b5234863af1a087997386f0ace); /* assertPre */ \ncoverage_0x20c6cd42(0xa83a1990dbaaafde52b7cb03f4d648d5b9acfec3fcb5db52758854fa17798d8a); /* statement */ \nrequire(success, \"Pairing check failed\");coverage_0x20c6cd42(0xea1f7390d7facc7e3ca5f4c75544c0a34fdd82ef53e124acc847d54960b78e38); /* assertPost */ \n\ncoverage_0x20c6cd42(0x02fab8fa6144512aa0dd5950c7def4ca0db3890c963303fa5439efbedab617e0); /* line */ \n        coverage_0x20c6cd42(0x9b0798f8a0fd290a30f5d33b084a71094a4fe34b7dcd47afa348eef9b56020cf); /* statement */ \nreturn out[0] != 0;\n    }\n\n    function checkHashToGroupWithHelper(\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB\n    )\n        internal\n        pure\n        returns (bool)\n    {coverage_0x20c6cd42(0x04ac6f0155cfc09d4e5d5615d4242887200b69c9bd027ec8f74b023b27f359a7); /* function */ \n\ncoverage_0x20c6cd42(0xd8244ab4fca6fa5d4e275e964011b2b6ac0cb9bf9a32a5585056c36a826752ca); /* line */ \n        coverage_0x20c6cd42(0xbdb3c01fcfe06b0b66c8798ebd159949cd86a9a0745c11174130a46dcaba50bf); /* statement */ \nuint xCoord = uint(hash) % P;\ncoverage_0x20c6cd42(0x03c6e470080299d76da106f646995b596c62968d8e6c242f4b4cd508ccd30b22); /* line */ \n        coverage_0x20c6cd42(0x7945b4a95f5ef363385d0648300e0fce26d9af6b9bd827635ef8285d2ce06cd1); /* statement */ \nxCoord = (xCoord + counter) % P;\n\ncoverage_0x20c6cd42(0x8468301fbf139f5dbb47082f05234ab779506c9707716ad1a9be4af28f26ef9f); /* line */ \n        coverage_0x20c6cd42(0x652b4e38e43decf31bb97b374356d0a78b367c412dc19f9ff15ca000c59b335f); /* statement */ \nuint ySquared = addmod(mulmod(mulmod(xCoord, xCoord, P), xCoord, P), 3, P);\ncoverage_0x20c6cd42(0x95c336f0d55572abe823da8a07ad791d9fb9056be5873ed6e556d1618ff307be); /* line */ \n        coverage_0x20c6cd42(0x14521b7b0e64df65d5b90786138a5beeb4d7125467130659346442b5fa49c4e2); /* statement */ \nif (hashB < P / 2 || mulmod(hashB, hashB, P) != ySquared || xCoord != hashA) {coverage_0x20c6cd42(0x902ed15db837247099d31b704b70de5a85dcda87ece0ffde265125781d75a8ab); /* branch */ \n\ncoverage_0x20c6cd42(0x93d790d9320e50142b3b34e8409f27a54067cb5917f4861e3f678dab8b44e3f6); /* line */ \n            coverage_0x20c6cd42(0xba994b05da92710df5efd31065db11cc093550f4824cc040eacdf5a2de14355c); /* statement */ \nreturn false;\n        }else { coverage_0x20c6cd42(0x58a78b1fbc2249bb0903e4566906125a8a376548c53af29479955679279eeccd); /* branch */ \n}\n\ncoverage_0x20c6cd42(0xd0c0eace80f2027ed3c33f9015d9530034c72d057665d4053e3c34f399482040); /* line */ \n        coverage_0x20c6cd42(0x8428a0aa55cc81aac5514d41032abab45927607627528bc2ad400ae177953f31); /* statement */ \nreturn true;\n    }\n\n    // Fp2 operations\n\n    function addFp2(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {coverage_0x20c6cd42(0x3e2c46f286cfbce1490de862bd382aecb230968c71d8c7fc37710ca0d293ed9e); /* function */ \n\ncoverage_0x20c6cd42(0xbba6f4aca173d2b90e90366462ad0f88983705ae664d37d90167e31635997980); /* line */ \n        coverage_0x20c6cd42(0x3f356305ab23bd375a8b83c00a337a5bba7d576dae50f0103a474f1b335a732e); /* statement */ \nreturn Fp2({ x: addmod(a.x, b.x, P), y: addmod(a.y, b.y, P) });\n    }\n\n    function scalarMulFp2(uint scalar, Fp2 memory a) internal pure returns (Fp2 memory) {coverage_0x20c6cd42(0x5d0439c6d6eb5f0968c7edf3768650d5197d7fca27c00f5ba10f69104ef13bbc); /* function */ \n\ncoverage_0x20c6cd42(0x68f77d300c918f9c56a07c54325929dcaa158db2a45af0f75e870ecd1df855d8); /* line */ \n        coverage_0x20c6cd42(0x0412fec114fa81e705229fce0a68ae11b6257f7f2ff7f12435b38f4e15d8be12); /* statement */ \nreturn Fp2({ x: mulmod(scalar, a.x, P), y: mulmod(scalar, a.y, P) });\n    }\n\n    function minusFp2(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {coverage_0x20c6cd42(0x877ebe72fe024235884d63924c0c0a06952d38f5068158b763f178c0eb0c8608); /* function */ \n\ncoverage_0x20c6cd42(0xc666322bab91e9503dab14579a7dba0bc339777c3c6335b422937a9d56cadebf); /* line */ \n        coverage_0x20c6cd42(0x3d7ceb4d8a91cd91ae83bb3f6395a7b0a44c0fa161d56e9f33e13fa1260823aa); /* statement */ \nuint first;\ncoverage_0x20c6cd42(0xab51583eba9bf11da99884d26ba993ca8c4be585b9c8071348ae8357367cc923); /* line */ \n        coverage_0x20c6cd42(0xcc9c21f891950cc09054055c29d41942b993e55f4928a00eaf0d926acc8f7984); /* statement */ \nuint second;\ncoverage_0x20c6cd42(0x2f3a0f6106deab62fb7d9b62b21c70586406249c05ce72b5458b5f7557fb19b2); /* line */ \n        coverage_0x20c6cd42(0x17206fc0ddf9ea409b7147f076494649285bca71d578886880528a8592e4527e); /* statement */ \nif (a.x >= b.x) {coverage_0x20c6cd42(0xda1c9aa0a1d39f0a29e9b0c4d556b66f5fa7541270d6df2f88327b49f6f6fb4e); /* branch */ \n\ncoverage_0x20c6cd42(0xf6161e71f157adb852ce46154968d7c4dd0e2942760f4e4a365e9ddd9697d223); /* line */ \n            coverage_0x20c6cd42(0xacd337b5f42f9150cb17c82cceef546a1be0350edf1e27c7f5bea5d105112d3f); /* statement */ \nfirst = addmod(a.x, P - b.x, P);\n        } else {coverage_0x20c6cd42(0x4e409e8a97fe9103cf5fe7021ffb41bd98399e8d65255ed42ebc054eed717951); /* branch */ \n\ncoverage_0x20c6cd42(0xc245ebf2b3a10fbbe891cbbf42b3e090530111b3abfac16f5dfd210ea33d00b3); /* line */ \n            coverage_0x20c6cd42(0xb0e142d5814360877feaa60643cb768950c1e973c864d10d881ec200fb537f28); /* statement */ \nfirst = P - addmod(b.x, P - a.x, P);\n        }\ncoverage_0x20c6cd42(0x4210c7d42974b0c14a044d18fb57d5e4f0380f16871e3bb74ce67460f1a52d16); /* line */ \n        coverage_0x20c6cd42(0xb73045125f31cb803e04e5e27b86c5755148455833e69493bdc30f1a4608fbfd); /* statement */ \nif (a.y >= b.y) {coverage_0x20c6cd42(0xb0529dc5ddb1a664561204ebe94d9e32cf3689e50e38090fe3b9cd57e0c93940); /* branch */ \n\ncoverage_0x20c6cd42(0x570232e604fe987b93cfcc8116ec9ccad70388f614c5d2210034010364d056e6); /* line */ \n            coverage_0x20c6cd42(0xce45655e317a89c4bd26092df6680d6b6299f6ee821adf4eaf823331e9d2a989); /* statement */ \nsecond = addmod(a.y, P - b.y, P);\n        } else {coverage_0x20c6cd42(0xdc9b9da2f086207e0c94311ee8a1bac8856186668a94546d5591f3973d5af449); /* branch */ \n\ncoverage_0x20c6cd42(0xc6a2fa189f606bcd0e8426aa3f6954b82541b7e677b0593232b0203cfd3c5ef2); /* line */ \n            coverage_0x20c6cd42(0x04437cea6bcc8598a8b4112bb317585578ddac120303c3a74cf4340a2018a221); /* statement */ \nsecond = P - addmod(b.y, P - a.y, P);\n        }\ncoverage_0x20c6cd42(0xac85d587bb435d90697e13f8d8c0270e0a5f3fb4b47ebb19dcb29ba6ad33b5ca); /* line */ \n        coverage_0x20c6cd42(0x08fd1053a8c16ef43b8f76f427519e3763e0dbb881282b2012ffaf0c691e8cfd); /* statement */ \nreturn Fp2({ x: first, y: second });\n    }\n\n    function mulFp2(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {coverage_0x20c6cd42(0x45e556942e4657602cc0bef744c8decbfb98f2210ef2a373773670d73b6ce32a); /* function */ \n\ncoverage_0x20c6cd42(0x0a5be28c6e6936f3254d2c0d865ee74f59dc96f2d89c089c09fb02869eb67df5); /* line */ \n        coverage_0x20c6cd42(0xd282ebebfe4d29bb600c650175fc8f747b95da0cd71b2a9f9ee884b441b2319c); /* statement */ \nuint aA = mulmod(a.x, b.x, P);\ncoverage_0x20c6cd42(0x61d436d731ddbb8c6ddc66d9ce067b6d8cb2eb1ab7c7e55866c35933f7da02d0); /* line */ \n        coverage_0x20c6cd42(0x9adef4065c2d178786a02a347433947f7ef4ff4932efbf3194c791a2f1912a2d); /* statement */ \nuint bB = mulmod(a.y, b.y, P);\ncoverage_0x20c6cd42(0x50478266a2cfba5bb543f6de0fe57d0be64985a80601e2dfee9b2910977be30a); /* line */ \n        coverage_0x20c6cd42(0x4b2d467613f14cafce37075c36b6460de9b868f3faeb4d856bb3cb29fbf5f15d); /* statement */ \nreturn Fp2({\n            x: addmod(aA, mulmod(P - 1, bB, P), P),\n            y: addmod(mulmod(addmod(a.x, a.y, P), addmod(b.x, b.y, P), P), P - addmod(aA, bB, P), P)\n        });\n    }\n\n    function squaredFp2(Fp2 memory a) internal pure returns (Fp2 memory) {coverage_0x20c6cd42(0x0c2c18ace38ac7aafba155b7823a9e619e82e3888cdfdbb63e80aa63ff646f1b); /* function */ \n\ncoverage_0x20c6cd42(0x8dd81f4e62544fbe1a1fe1a25dc2ac2d210f2d19d3081dd13cfe120612566d74); /* line */ \n        coverage_0x20c6cd42(0xfe77cabda073b998b8c9f5e36bb1c3bfec34b6e33e5c78721765c4ab88ef4abf); /* statement */ \nuint ab = mulmod(a.x, a.y, P);\ncoverage_0x20c6cd42(0x16dc2fafc29a2ccf51e64087fd546be717b7122c5dc8f8d325d3016d40b266d4); /* line */ \n        coverage_0x20c6cd42(0x2d1d4badc7a2d40b533a7bb219f25d38b4e3109cdf9006bba9d7d84d93bdf29d); /* statement */ \nuint mult = mulmod(addmod(a.x, a.y, P), addmod(a.x, mulmod(P - 1, a.y, P), P), P);\ncoverage_0x20c6cd42(0xae50f59d3a154463f96cbbda80bc4b47a07fd5e8fc4c1b8cfcc14c89bee67464); /* line */ \n        coverage_0x20c6cd42(0x197ecd541e89a99e9503957eab8d494d84ceb130b6898ab78a77aee611b13345); /* statement */ \nreturn Fp2({ x: mult, y: addmod(ab, ab, P) });\n    }\n\n    function inverseFp2(Fp2 memory a) internal view returns (Fp2 memory x) {coverage_0x20c6cd42(0x9866cf725f161aba1a4351958c74f61e69fc24d26c308a3ff8a52761dc71ca45); /* function */ \n\ncoverage_0x20c6cd42(0x25d0cdf8760d3e71c03f26c2f74590c5c5e12b89f0b9dd32d336b97ecec543df); /* line */ \n        coverage_0x20c6cd42(0x57f52a7fc0e6f7f1abc426093b6413196d442a7159a161feff61f1dad3131e1f); /* statement */ \nuint t0 = mulmod(a.x, a.x, P);\ncoverage_0x20c6cd42(0x75722fb4a66ce5165801a928675f9a4664de4269486d0a0f01385500faeb1349); /* line */ \n        coverage_0x20c6cd42(0xf7c5d6b1e3950e3fe5832d5e28987dd325ca44391bd0a37d64ecea2d9aa6c13b); /* statement */ \nuint t1 = mulmod(a.y, a.y, P);\ncoverage_0x20c6cd42(0x2633620db5c4f4c50ce2e7ddecd3f9152b5471e9bf0280914b8f3f8533873217); /* line */ \n        coverage_0x20c6cd42(0x4ea2c9e0a59919b5d6e9f87c141364df587bfb970bf333e4b892c659df31c8f6); /* statement */ \nuint t2 = mulmod(P - 1, t1, P);\ncoverage_0x20c6cd42(0xe9ef4090e6538e233c18b5aaf4acc4f82f00e7b2d5f60279a548755cd1395852); /* line */ \n        coverage_0x20c6cd42(0xd7e11384a0dad4b2a57750e8ce35c1557754cefde40c9bfc09b8367511bcaa3b); /* statement */ \nif (t0 >= t2) {coverage_0x20c6cd42(0x6546c77a1494bc371ffa651f503d83ab935e7646071beeddc5e92c6ea61773f7); /* branch */ \n\ncoverage_0x20c6cd42(0x6e33538e95d8980bcffebb869fe4e14cc825adee8d381b6d2ffb0ebd419badf7); /* line */ \n            coverage_0x20c6cd42(0xd3402318e5e48aa0df59e733e94f2694cb166dfbe54d2e5f7122f7e11f1dff65); /* statement */ \nt2 = addmod(t0, P - t2, P);\n        } else {coverage_0x20c6cd42(0xd47481660f6183eb354ada490b152bc884c50c1df5be39e6ddaac611c02ce8da); /* branch */ \n\ncoverage_0x20c6cd42(0xcbe211a02cab32023e4f54587cbe98950dfe89b13fe543f0c5f7f883085e65c9); /* line */ \n            coverage_0x20c6cd42(0x174f6a0ef6675df2bca28f144764dae614a84fe86cb1464fb2d634233aaa3a53); /* statement */ \nt2 = P - addmod(t2, P - t0, P);\n        }\ncoverage_0x20c6cd42(0x27aed675dfa687b40a42139775943ba0b5d79002ca89a4c0259c021e9e35df95); /* line */ \n        coverage_0x20c6cd42(0x9242c2e414705e42f87faa66240df9f747044ae06432386a5274415951dc9101); /* statement */ \nuint t3 = bigModExp(t2, P - 2);\ncoverage_0x20c6cd42(0x7547fe151925430ef905e428a4e94f70a4f603e096ffc18e9de87c5141e52cb7); /* line */ \n        coverage_0x20c6cd42(0x0c81ac7e2a8ce389217183b853d89091809e88ca636f4d69ab20c114f2ed74fe); /* statement */ \nx.x = mulmod(a.x, t3, P);\ncoverage_0x20c6cd42(0x720af863147b316c267e056b21d504544cda4342932c62954158841335dadc68); /* line */ \n        coverage_0x20c6cd42(0x35754a3d3f522aece1ccf6dee0fe3957fddea214bef904fc0f0a60ee7cd62865); /* statement */ \nx.y = P - mulmod(a.y, t3, P);\n    }\n\n    // End of Fp2 operations\n\n    function isG1(uint x, uint y) internal pure returns (bool) {coverage_0x20c6cd42(0x03c87dadbafe636d27b81bbf7aae63491db3ee450400fa3c4591dfda5efc6908); /* function */ \n\ncoverage_0x20c6cd42(0xc1b5eb9c3fa98d6919039e669f5d15414a4be5cf1598744ebbd0aa74038d188a); /* line */ \n        coverage_0x20c6cd42(0xf06c160fd1947286a579b2b0f67052a2b533519657c2aade8a113e53c639f60a); /* statement */ \nreturn mulmod(y, y, P) == addmod(mulmod(mulmod(x, x, P), x, P), 3, P);\n    }\n\n    function isG2(Fp2 memory x, Fp2 memory y) internal pure returns (bool) {coverage_0x20c6cd42(0x41706f283ef1c169e026c25fa35b3cb506a234aaf0648aadbe2abd75f7de425d); /* function */ \n\ncoverage_0x20c6cd42(0x6e054204ee7482980f3765ce18b334cb19762022aec7df01ac0ae6cd7c909b62); /* line */ \n        coverage_0x20c6cd42(0xab8d3f2b11ffb04fcbf0638243e908ec59a141f7211a6d92217866436a2e66eb); /* statement */ \nif (isG2Zero(x, y)) {coverage_0x20c6cd42(0xfe57c71f5a3c9a51c2aedb39ca60023b8589ea641fa12f00ab515760ecc66687); /* branch */ \n\ncoverage_0x20c6cd42(0x2cd04bee06a1bb13a286784ad673f13eb7178c2333743179432c2511daf920db); /* line */ \n            coverage_0x20c6cd42(0xd576a6a96534948f4611cd2a3e3de033fc939a01fa8f700a1d36b59a1c63b096); /* statement */ \nreturn true;\n        }else { coverage_0x20c6cd42(0x8c17d5fe1d819d6f518369c45f2699465215aa15d10da361e41bb419487c77d6); /* branch */ \n}\ncoverage_0x20c6cd42(0xb6a1887757226163b13a74daed0d6d21c4547c20333d0c5d706b667159ca3fe0); /* line */ \n        coverage_0x20c6cd42(0xc2b2e44122b061871b6aa6c6da703826e6c4f19125ced7fef78164c668850f21); /* statement */ \nFp2 memory squaredY = squaredFp2(y);\ncoverage_0x20c6cd42(0xd11f0a3e1231df97d422422bfc02e41411a5eac805ab402d98d8b7e230928c05); /* line */ \n        coverage_0x20c6cd42(0x7ca149bda894625742316991259a1be33fa7c8e5162ae7d4ad9d62880c4294c5); /* statement */ \nFp2 memory res = minusFp2(minusFp2(squaredY, mulFp2(squaredFp2(x), x)), Fp2({x: TWISTBX, y: TWISTBY}));\ncoverage_0x20c6cd42(0x85f0ece7e0f0bf832ec9648ea754f51b31b6b3bf520ad6b32f1de1427d956d4f); /* line */ \n        coverage_0x20c6cd42(0x46e9691e38ce9b18d9877f44ee8204484cce333f6c81396fd9e4abb6b8f22e3a); /* statement */ \nreturn res.x == 0 && res.y == 0;\n    }\n\n    function isG2Zero(Fp2 memory x, Fp2 memory y) internal pure returns (bool) {coverage_0x20c6cd42(0x73b22f9c23ef66b96283b52ba0cff471733715c67c798771bc86ec03d9439433); /* function */ \n\ncoverage_0x20c6cd42(0x198f07c2120692a224e73c1563c9818ee796f9dec415cf88c573cf34ec3df98f); /* line */ \n        coverage_0x20c6cd42(0x280c70ce653471a33173b3901e851105f7f08e241d37c305220b0a53ef37853e); /* statement */ \nreturn x.x == 0 && x.y == 0 && y.x == 1 && y.y == 0;\n    }\n\n    function bigModExp(uint base, uint power) internal view returns (uint) {coverage_0x20c6cd42(0xffef0c5096da2d5b328dc6859c8447edfac298f0a21167a24e171df7ca999651); /* function */ \n\ncoverage_0x20c6cd42(0x8a5ed9b0dd28c9a2543f5b41d2d3f577dee45af841b63f46a70330c0a3a7c74b); /* line */ \n        coverage_0x20c6cd42(0x15584f6dc8f76b424fbff23e469004700bde26314c1896b9c3e805adff075231); /* statement */ \nuint[6] memory inputToBigModExp;\ncoverage_0x20c6cd42(0xdf5284c0e9fee390b33c9f52f7da812c9dca5cc35959a24cba8b65f704e60529); /* line */ \n        coverage_0x20c6cd42(0xa1df995bfd4a83aef2eed3c44d9132f5a8cf0de505d350747be780461ea4fae0); /* statement */ \ninputToBigModExp[0] = 32;\ncoverage_0x20c6cd42(0x0a62728f19eef98a11888a2808e4aa163e0ab801cea386156814d1db8343d3e0); /* line */ \n        coverage_0x20c6cd42(0x611b1336f4f52a5bcbb93b55fb7a60aed2f89ccc3de2f9a683ed9602dcc518b3); /* statement */ \ninputToBigModExp[1] = 32;\ncoverage_0x20c6cd42(0xe1d40b961c259d826b592d20691146ce3c6548b90fc0876c2167365c90de6e27); /* line */ \n        coverage_0x20c6cd42(0x1916aa599962740c63eecb72ca2cdabcfadbbeddf074302df1e0b5a5ddd27acc); /* statement */ \ninputToBigModExp[2] = 32;\ncoverage_0x20c6cd42(0xe2b1e5655df1897e393cff4fe4b51757cb98c5bcfdc9ebef78bd3d7f03e33784); /* line */ \n        coverage_0x20c6cd42(0x127552f30785e7dd2d3473b6019b414174de5c6615d241f09118d401feec78b8); /* statement */ \ninputToBigModExp[3] = base;\ncoverage_0x20c6cd42(0x1437510028220292bbdce67d442ce1234be7020c57fa5a58bd94d1ea93489e65); /* line */ \n        coverage_0x20c6cd42(0x96bd206b4379d3aea00e5716d7a243f0c0088be9f53384448c0d3473f0aa933e); /* statement */ \ninputToBigModExp[4] = power;\ncoverage_0x20c6cd42(0xfeb2e4f144dfa76155f435096cac0b35d2d4b5380b909092002939203873e273); /* line */ \n        coverage_0x20c6cd42(0x963f23be6ad9bab998d1e186c3145e2f17423abade78c7e92e662bbadc175231); /* statement */ \ninputToBigModExp[5] = P;\ncoverage_0x20c6cd42(0xf62ffad48ab4816cd6e684e32ff2eb5a4000421aaa4900158ea74d506c4542e8); /* line */ \n        coverage_0x20c6cd42(0x7d9b4ad89c9409ae8f63d9df4691a11ef5bdce4bc2e82d0e1d667c7cbe299dd6); /* statement */ \nuint[1] memory out;\ncoverage_0x20c6cd42(0x67b69e8d9d29b8b1e2fed1e2fb3186df6b48630eb0639580fc38aa80fad62123); /* line */ \n        coverage_0x20c6cd42(0x6e157341a02a4c7172eb92717f0b9cd8ab2dffb5f9d893f6ab797c2003a6bd43); /* statement */ \nbool success;\ncoverage_0x20c6cd42(0x7398d772ca2562ea58df6acf3d8250f265589fd3c4a04644b8bae61b0bff3967); /* line */ \n        assembly {\n            success := staticcall(not(0), 5, inputToBigModExp, mul(6, 0x20), out, 0x20)\n        }\ncoverage_0x20c6cd42(0x1836a5c51a8a76d861ee8789713b67adecc1ad886168b4665b16f72a8b0d7519); /* line */ \n        coverage_0x20c6cd42(0x62e5eb9ba65d163c375b1a19cf6e32f8fb890d6b31193211dc69f340d9054c59); /* assertPre */ \ncoverage_0x20c6cd42(0xc42275bb6f237d75acb956a8c9f7569d80cd986a20d08e547fa5001d081739ad); /* statement */ \nrequire(success, \"BigModExp failed\");coverage_0x20c6cd42(0x6066cb76ab63a8a3cd583d449346e38f85a37a5aaab5cfc08e43cdf8b4e9688b); /* assertPost */ \n\ncoverage_0x20c6cd42(0xf891dad7809357bda8854f15e80fb72b00d14a0637708159fbd1fd1b6031efd5); /* line */ \n        coverage_0x20c6cd42(0x75663ce065d5b9b0502a72a4ef1453be03cd737267217b8becb75cf9ef864570); /* statement */ \nreturn out[0];\n    }\n}\n"
    },
    ".coverage_contracts/ValidatorsData.sol": {
      "content": "/*\n    ValidatorsData.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity ^0.5.0;\n\nimport \"./GroupsData.sol\";\n\n\ncontract ValidatorsData is GroupsData {\nfunction coverage_0xe3388ada(bytes32 c__0xe3388ada) public pure {}\n\n\n\n    struct Metrics {\n        uint32 downtime;\n        uint32 latency;\n    }\n\n    struct Validator {\n        uint nodeIndex;\n        bytes32[] validatedNodes;\n        Metrics[] verdicts;\n    }\n\n    mapping (bytes32 => bytes32[]) public validatedNodes;\n    //mapping (bytes32 => Metrics[]) public verdicts;\n    mapping (bytes32 => uint32[][]) public verdicts;\n\n    constructor(string memory newExecutorName, address newContractsAddress) GroupsData(newExecutorName, newContractsAddress) public {coverage_0xe3388ada(0xa8509c2930d1a91832bcf57c0aafa4f00558722ed0b7d728275c635f51dbe173); /* function */ \n\n\n    }\n\n    /**\n     *  Add validated node or update existing one if it is already exits\n     */\n    function addValidatedNode(bytes32 validatorIndex, bytes32 data) external allow(executorName) {coverage_0xe3388ada(0x37ffffa0724709a902cd744facbeddf3e0ca0a160543a1fe23032538dc3f41c9); /* function */ \n\ncoverage_0xe3388ada(0xac033af74a215d802a045711433ed9c076a72b6a8093c5094938fec316150625); /* line */ \n        coverage_0xe3388ada(0xc5b25ed2e99e548d3a4d63fceb12e38185e2d00cf25279130f6fe54fbe4b21ec); /* statement */ \nuint indexLength = 14;\ncoverage_0xe3388ada(0xc0f750682b1d2433b3e065c38191ac94e5db8df327939910eb1119280da348fc); /* line */ \n        coverage_0xe3388ada(0xb6fbe4653dd9a459a23d4fd5bef20bf6edbdef3533f17a6fb5805e064194d075); /* assertPre */ \ncoverage_0xe3388ada(0x3916a4c564d6363b7bab0396ddd24baba7cba1cde486ceff0716ba948b1c252b); /* statement */ \nrequire(data.length >= indexLength, \"data is too small\");coverage_0xe3388ada(0xf633cb714fca38a3fb4e2865fafde57831d426b9de92e9285ecaf80646086ab9); /* assertPost */ \n\ncoverage_0xe3388ada(0xdbd5ce3c6cb7be6bd2dfd17dc948fefea54ce422638a1a8cc932314f6b093610); /* line */ \n        coverage_0xe3388ada(0x13e0c8110174bb3271fc0319b0a6faa0d6b14a56fa313f8f3220bfe2a40e9bd0); /* statement */ \nfor (uint i = 0; i < validatedNodes[validatorIndex].length; ++i) {\ncoverage_0xe3388ada(0x13a640ad4429e0c5d4cdd2b245282a94c46047eac917c563394a523996a204ef); /* line */ \n            coverage_0xe3388ada(0xe3234bd2bd473765707eb64fb92a89608a5d16ff149e1a984452030b4dbbc804); /* assertPre */ \ncoverage_0xe3388ada(0xf5017f544e850bd8f181d3db8dd22f3bd73a8cba6df02f1da3538bb4dae0d0ea); /* statement */ \nrequire(validatedNodes[validatorIndex][i].length >= indexLength, \"validated nodes data is too small\");coverage_0xe3388ada(0x00bab582ff81ec64351144a97bef88e922ce8d34c2dc4731b421f76db844db1a); /* assertPost */ \n\ncoverage_0xe3388ada(0x812b12a433d39917b9e3371bc328133ae609d94925bc68b5910a31721e3ce529); /* line */ \n            coverage_0xe3388ada(0xdc2e5c6f60c9d334d7da0d95d599972f04a914f4abaa432a7a3d8229c0aaacc0); /* statement */ \nuint shift = (32 - indexLength) * 8;\ncoverage_0xe3388ada(0x2816d3f7bee7d561c96c6f12b21b0f3d115b5176bd237294e2349950e886f8c8); /* line */ \n            coverage_0xe3388ada(0x8bf9348c60d78356e99bb779dae88374f918290651340059d9ba2a073923f6dc); /* statement */ \nbool equalIndex = validatedNodes[validatorIndex][i] >> shift == data >> shift;\ncoverage_0xe3388ada(0xb62126001116f86aceefc29b06bec6047308812090fa5a0366a0a18e08d9a619); /* line */ \n            coverage_0xe3388ada(0x7d26b8861682f81f038be5efc70d1d1f471645132ea3db543f4a6894352be9d5); /* statement */ \nif (equalIndex) {coverage_0xe3388ada(0x7736a2d5ce46148c00c1d4aaeadebfb7aa118b6213fe27bc5208996d02d6bb09); /* branch */ \n\ncoverage_0xe3388ada(0xc6b8e342b6e647d0d867569220af9fc9d20e218328c4aacf796d57ad0d19b47f); /* line */ \n                coverage_0xe3388ada(0x6cecb1584d7bb7d9269dca4af4287ef91e125e479f784166f58504824cdf54b6); /* statement */ \nvalidatedNodes[validatorIndex][i] = data;\ncoverage_0xe3388ada(0x55929ae1b71f09cb32192248132343e038d88b19c61b06a681c73aa50d60370f); /* line */ \n                coverage_0xe3388ada(0x2fe48a0d50940a8769590512943b6b9dea9a7c59419443da6a3514690ac0bd93); /* statement */ \nreturn;\n            }else { coverage_0xe3388ada(0x0b0c4512bbaf49832efb5593fd6441f78be4ae0d1eea9441074ff1530ea70fd3); /* branch */ \n}\n        }\ncoverage_0xe3388ada(0xb9fad465fde7eb3a2314e7934abe9121e2a8ab74dbff309caf3cb791753d5081); /* line */ \n        coverage_0xe3388ada(0x09def50ddd9bad0a304f0f0d3fb0a3779dcc8e8aae6f5294b3013b187523fbea); /* statement */ \nvalidatedNodes[validatorIndex].push(data);\n    }\n\n    function addVerdict(bytes32 validatorIndex, uint32 downtime, uint32 latency) external allow(executorName) {coverage_0xe3388ada(0xfee4575939bc8a0e2e6162bba9ffe61b459f6878092f3722c55f45dfb697792c); /* function */ \n\ncoverage_0xe3388ada(0x88184481cfcc3845571fd91888fbaa314c1f0819edfadab9594061e09eb4b6ee); /* line */ \n        coverage_0xe3388ada(0x23432cb37ea09f01824d01367778bb921292d34f580e31a88c48bb04e7a81ef7); /* statement */ \nverdicts[validatorIndex].push([downtime, latency]);\n    }\n\n    function removeValidatedNode(bytes32 validatorIndex, uint indexOfValidatedNode) external allow(executorName) {coverage_0xe3388ada(0x06bb59a099c1d3dd2cc90ae40765a246fbce26fc3500b1c0f57eda8771fb1541); /* function */ \n\ncoverage_0xe3388ada(0xde09e22898102ae048771229e93eceabfc58283069ea394d222575f9ba2b13d1); /* line */ \n        coverage_0xe3388ada(0x20826b21a92b18f52d7310b766595f613ad2405097e7d31e7df38af16b591e3f); /* statement */ \nif (indexOfValidatedNode != validatedNodes[validatorIndex].length - 1) {coverage_0xe3388ada(0xf50b6ab6fe1c567ab583776294ff640e95db56c1d5fb7feef12ee0cd9e8e90ec); /* branch */ \n\ncoverage_0xe3388ada(0x388bad1bfc404b79bc80d334b371b8536d6cc1d42a2aa0ffa8b1ce4f83ad1933); /* line */ \n            coverage_0xe3388ada(0x28f619e12c496aadde48dd5a457a4af9b6a2731aa04860bb5af2099de8b74ddc); /* statement */ \nvalidatedNodes[validatorIndex][indexOfValidatedNode] = validatedNodes[validatorIndex][validatedNodes[validatorIndex].length - 1];\n        }else { coverage_0xe3388ada(0x1a59076111d8cc3b16406cfa279ebe85a37dbfdc59d79184a80e34498f420887); /* branch */ \n}\ncoverage_0xe3388ada(0x93f584f603b89374538c3d2f4e078333e42ac1c90c193c080ca2de3945f86b82); /* line */ \n        delete validatedNodes[validatorIndex][validatedNodes[validatorIndex].length - 1];\ncoverage_0xe3388ada(0xa725136c015bf764c06ddd3eab628ed03b21fc0ab13fba38705a9fcce59cf092); /* line */ \n        validatedNodes[validatorIndex].length--;\n    }\n\n    function removeAllValidatedNodes(bytes32 validatorIndex) external allow(executorName) {coverage_0xe3388ada(0x411efbdb9d56e19b5e187a64c0901c5745c92d4dfe27264280b70be4d9238e3c); /* function */ \n\ncoverage_0xe3388ada(0xda2a90e6c196c6179e028c4b05231e677d802385861dc6ffb5af1b90c704d943); /* line */ \n        delete validatedNodes[validatorIndex];\n    }\n\n    function removeAllVerdicts(bytes32 validatorIndex) external allow(executorName) {coverage_0xe3388ada(0xcb4f7013f1e5cd9fee8f5135f763c911d120de9c529c687bfc6c7f932dca0a9d); /* function */ \n\ncoverage_0xe3388ada(0x02d50d94c50f863c48b8c4d034c9563690e3645d3104ae1d78d473efc1fe8d18); /* line */ \n        coverage_0xe3388ada(0x190ec7574eb8be0802c145630aee29d7f4da5b18f5f278f63c31e4806e4abdfa); /* statement */ \nverdicts[validatorIndex].length = 0;\n    }\n\n    function getValidatedArray(bytes32 validatorIndex) external view returns (bytes32[] memory) {coverage_0xe3388ada(0x92da98d813e4c10b1530922fb96a89567f954eb81f9d744a441e7b14d5a0c205); /* function */ \n\ncoverage_0xe3388ada(0x5844f46c9a35e4c098d5779e5dfa784969a75c4cc724960ab3b41982c37e5149); /* line */ \n        coverage_0xe3388ada(0x23edf05f5b527b35ec11d66c55bee92c9e3eb6a8414161f28fa34db4c9275154); /* statement */ \nreturn validatedNodes[validatorIndex];\n    }\n\n    function getLengthOfMetrics(bytes32 validatorIndex) external view returns (uint) {coverage_0xe3388ada(0x1077ebe5a9f160316935c80c1f19f6c5ac274e3135574e8d9dab6eba14ba2eea); /* function */ \n\ncoverage_0xe3388ada(0x1c6b193a4cf853d0e140009e370a146992af01a66384b3c4ddb60e1ffdb2286c); /* line */ \n        coverage_0xe3388ada(0xf70ec38a46e9e8c58010b4de7ded5711b69b0fe051c6b79562b4bb8724d6469c); /* statement */ \nreturn verdicts[validatorIndex].length;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    },
    "evmVersion": "petersburg"
  }
}